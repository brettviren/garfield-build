CDECK  ID>, GRTXHIGZ.
       SUBROUTINE GRTX(X,Y,STRING)
*-----------------------------------------------------------------------
*   GRTX   - Calls ITX, version for HIGZ.
*   (Last changed on 24/ 1/12.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL USERX0,USERX1,USERY0,USERY1,FRXMIN,FRXMAX,FRYMIN,FRYMAX,
     -      ARRANG,ARRLEN,BARFRC,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT
       LOGICAL LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,
     -      LWAITA,LWAITB,LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      WKMULT(MXWKLS)
       INTEGER NWK,WKID(MXWKLS),WKCON(MXWKLS),WKFREF(MXWKLS),
     -         WKLUN(MXWKLS),WKSTAT(MXWKLS),WKSREQ(MXWKLS),
     -         NCWKNM(MXWKLS),NCSTMP,IGHIST,IGBAR,NCGKS
       CHARACTER*20 WKNAME(MXWKLS),WKATTR(MXWKLS)
       CHARACTER*80 STAMP
       CHARACTER*(MXNAME) GKSLOG
       COMMON /GRADAT/ USERX0,USERX1,USERY0,USERY1,ARRANG,ARRLEN,
     -      BARFRC,
     -      FRXMIN,FRXMAX,FRYMIN,FRYMAX,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT,
     -      LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,LWAITA,LWAITB,
     -      LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      NWK,WKID,WKCON,WKFREF,WKLUN,WKSTAT,WKSREQ,NCWKNM,NCSTMP,
     -      IGHIST,IGBAR,NCGKS,WKMULT
       COMMON /GRACHR/ WKNAME,WKATTR,STAMP,GKSLOG
       CHARACTER*(*) STRING
       CHARACTER*256 STROUT
       LOGICAL UNIT
       INTEGER NOUT,INEXT,I
       REAL X,Y
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE GRTX (HIGZ version) ///'
*** Debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GRTX   DEBUG   : In:  "'',A,
     -      ''",'')') STRING
*** Do not process empty strings.
       IF(LEN(STRING).LT.1)RETURN
*** Simply copy the string if control characters are to be executed.
       IF(LXCCH)THEN
            NOUT=MIN(256,LEN(STRING))
            STROUT=STRING
*** Convert the control characters in the string if requested.
       ELSE
            NOUT=0
            UNIT=.FALSE.
*   Loop over the string.
            INEXT=1
            DO 10 I=1,LEN(STRING)
*   Skip a few characters.
            IF(I.LT.INEXT)GOTO 10
*   Check for excessive length.
            IF(NOUT+9.GT.256)GOTO 20
*   Fix SGML controls.
            IF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'<SUB>'.OR.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'<sub>')THEN
                 STROUT(NOUT+1:NOUT+1)='?'
                 INEXT=I+5
                 NOUT=NOUT+1
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'<SUP>'.OR.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'<sup>')THEN
                 STROUT(NOUT+1:NOUT+1)='^'
                 INEXT=I+5
                 NOUT=NOUT+1
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'</SUB>'.OR.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'</sub>')THEN
                 STROUT(NOUT+1:NOUT+1)='!'
                 INEXT=I+6
                 NOUT=NOUT+1
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'</SUP>'.OR.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'</sup>')THEN
                 STROUT(NOUT+1:NOUT+1)='!'
                 INEXT=I+6
                 NOUT=NOUT+1
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'<BACK>'.OR.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'<back>')THEN
                 STROUT(NOUT+1:NOUT+1)='&'
                 INEXT=I+6
                 NOUT=NOUT+1
*   Fix a series of control characters.
            ELSEIF(STRING(I:I).EQ.'|')THEN
                 STROUT(NOUT+1:NOUT+3)='"B#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'$')THEN
                 STROUT(NOUT+1:NOUT+3)='"D#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'!')THEN
                 STROUT(NOUT+1:NOUT+3)='"E#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'#')THEN
                 STROUT(NOUT+1:NOUT+3)='"F#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'>')THEN
                 STROUT(NOUT+1:NOUT+3)='"G#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'?')THEN
                 STROUT(NOUT+1:NOUT+3)='"H#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.':')THEN
                 STROUT(NOUT+1:NOUT+3)='"J#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'<')THEN
                 STROUT(NOUT+1:NOUT+3)='"L#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'[')THEN
                 STROUT(NOUT+1:NOUT+3)='"M#'
                 UNIT=.TRUE.
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.']')THEN
                 STROUT(NOUT+1:NOUT+3)='"N#'
                 UNIT=.FALSE.
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'{')THEN
                 STROUT(NOUT+1:NOUT+3)='"P#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'}')THEN
                 STROUT(NOUT+1:NOUT+3)='"Q#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'%')THEN
                 STROUT(NOUT+1:NOUT+3)='"Y#'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'''')THEN
                 STROUT(NOUT+1:NOUT+5)='"<9>#'
                 NOUT=NOUT+5
            ELSEIF(STRING(I:I).EQ.'"')THEN
                 STROUT(NOUT+1:NOUT+6)='"<99>#'
                 NOUT=NOUT+6
*   SGML entities, first accented letters "a" and "A".
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&aacute;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\366'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Aacute;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\367'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&acirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\276'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Acirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\300'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&agrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\260'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Agrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\265'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&aring;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\357'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Aring;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\362'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&auml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\311'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Auml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\314'
                 INEXT=I+6
                 NOUT=NOUT+4
*   Accented letters "c" and "C".
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&ccedil;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\321'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Ccedil;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\322'
                 INEXT=I+8
                 NOUT=NOUT+4
*   Accented letters "e" and "E".
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&eacute;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\323'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Eacute;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\324'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&ecirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\327'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Ecirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\330'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&egrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\325'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Egrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\326'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&euml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\331'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Euml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\332'
                 INEXT=I+6
                 NOUT=NOUT+4
*   Accented letters "i" and "I".
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&icirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\333'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Icirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\334'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&iuml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\335'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Iuml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\336'
                 INEXT=I+6
                 NOUT=NOUT+4
*   Accented letters "l" and "L".
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&lstrok;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\370'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Lstrok;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\350'
                 INEXT=I+8
                 NOUT=NOUT+4
*   Accented letters "n" and "N".
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&ntilde;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\337'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Ntilde;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\340'
                 INEXT=I+8
                 NOUT=NOUT+4
*   Accented letters "o" and "O".
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&ocirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\342'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Ocirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\344'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&oslash;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\371'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Oslash;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\351'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&ouml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\345'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Ouml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\346'
                 INEXT=I+6
                 NOUT=NOUT+4
*   Accented letters "u" and "U".
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&ucirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\347'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Ucirc;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\354'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&ugrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\374'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Ugrave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\375'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&uuml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\355'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Uuml;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\356'
                 INEXT=I+6
                 NOUT=NOUT+4
*   Ligatures.
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&aelig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\361'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&AElig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\341'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&filig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\256'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&fllig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\257'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&oelig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\372'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&OElig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\352'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&szlig;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\373'
                 INEXT=I+7
                 NOUT=NOUT+4
*   Lower case Greek characters.
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&alpha;')THEN
                 STROUT(NOUT+1:NOUT+3)='[a]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&beta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[b]'
                 INEXT=I+6
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&eta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[c]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&delta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[d]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&epsilon;')THEN
                 STROUT(NOUT+1:NOUT+3)='[e]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&phi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[f]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&gamma;')THEN
                 STROUT(NOUT+1:NOUT+3)='[g]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&chi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[h]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&iota;')THEN
                 STROUT(NOUT+1:NOUT+3)='[i]'
                 INEXT=I+6
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&kappa;')THEN
                 STROUT(NOUT+1:NOUT+3)='[k]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&lambda;')THEN
                 STROUT(NOUT+1:NOUT+3)='[l]'
                 INEXT=I+8
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&mu;')THEN
                 STROUT(NOUT+1:NOUT+3)='[m]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&nu;')THEN
                 STROUT(NOUT+1:NOUT+3)='[n]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&omicron;')THEN
                 STROUT(NOUT+1:NOUT+3)='[o]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&pi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[p]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&theta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[q]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+9.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+9)).EQ.'&thetasym;')THEN
                 STROUT(NOUT+1:NOUT+6)='[\\112]'
                 INEXT=I+10
                 NOUT=NOUT+6
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&rho;')THEN
                 STROUT(NOUT+1:NOUT+3)='[r]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&sigma;')THEN
                 STROUT(NOUT+1:NOUT+3)='[s]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&sigmaf;')THEN
                 STROUT(NOUT+1:NOUT+6)='[\\126]'
                 INEXT=I+8
                 NOUT=NOUT+6
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&tau;')THEN
                 STROUT(NOUT+1:NOUT+3)='[t]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&upsilon;')THEN
                 STROUT(NOUT+1:NOUT+3)='[u]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&omega;')THEN
                 STROUT(NOUT+1:NOUT+3)='[w]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&ksi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[x]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&xi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[x]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&psi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[y]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&zeta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[z]'
                 INEXT=I+6
                 NOUT=NOUT+3
*   Upper case Greek characters.
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Alpha;')THEN
                 STROUT(NOUT+1:NOUT+3)='[A]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Beta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[B]'
                 INEXT=I+6
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Eta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[E]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Delta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[D]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&Epsilon;')THEN
                 STROUT(NOUT+1:NOUT+3)='[E]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Phi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[F]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Gamma;')THEN
                 STROUT(NOUT+1:NOUT+3)='[G]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Chi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[H]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Iota;')THEN
                 STROUT(NOUT+1:NOUT+3)='[I]'
                 INEXT=I+6
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Kappa;')THEN
                 STROUT(NOUT+1:NOUT+3)='[K]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&Lambda;')THEN
                 STROUT(NOUT+1:NOUT+3)='[L]'
                 INEXT=I+8
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&Mu;')THEN
                 STROUT(NOUT+1:NOUT+3)='[M]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&Nu;')THEN
                 STROUT(NOUT+1:NOUT+3)='[N]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&Omicron;')THEN
                 STROUT(NOUT+1:NOUT+3)='[O]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&Pi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[P]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Theta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[Q]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Rho;')THEN
                 STROUT(NOUT+1:NOUT+3)='[R]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Sigma;')THEN
                 STROUT(NOUT+1:NOUT+3)='[S]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Tau;')THEN
                 STROUT(NOUT+1:NOUT+3)='[T]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&Upsilon;')THEN
                 STROUT(NOUT+1:NOUT+3)='[U]'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&Omega;')THEN
                 STROUT(NOUT+1:NOUT+3)='[W]'
                 INEXT=I+7
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Ksi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[X]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&Xi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[X]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&Psi;')THEN
                 STROUT(NOUT+1:NOUT+3)='[Y]'
                 INEXT=I+5
                 NOUT=NOUT+3
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&Zeta;')THEN
                 STROUT(NOUT+1:NOUT+3)='[Z]'
                 INEXT=I+6
                 NOUT=NOUT+3
*   Some special symbols.
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&amp;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\046'
                 INEXT=I+5
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&commat;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\100'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&copy;')THEN
                 STROUT(NOUT+1:NOUT+6)='[\\323]'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&darr;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\257#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&deg;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\312'
                 INEXT=I+5
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&dollar;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\044'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&euro;')THEN
                 STROUT(NOUT+1:NOUT+6)='[\\360]'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+1.LE.LEN(STRING).AND.
     -           (STRING(I:MIN(LEN(STRING),I+1)).EQ.'>='.OR.
     -            STRING(I:MIN(LEN(STRING),I+1)).EQ.'=>'))THEN
                 STROUT(NOUT+1:NOUT+3)='"O#'
                 INEXT=I+2
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&ge;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\263#'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&gt;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\076#'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&harr;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\071#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'_integral')THEN
                 STROUT(NOUT+1:NOUT+3)='"I#'
                 INEXT=I+9
                 NOUT=NOUT+3
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&int;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\111#'
                 INEXT=I+5
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&larr;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\067#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+1.LE.LEN(STRING).AND.
     -           (STRING(I:MIN(LEN(STRING),I+1)).EQ.'<='.OR.
     -            STRING(I:MIN(LEN(STRING),I+1)).EQ.'=<'))THEN
                 STROUT(NOUT+1:NOUT+3)='"o#'
                 INEXT=I+2
                 NOUT=NOUT+3
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&le;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\243#'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&lsqb;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\133'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'&lt;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\074#'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&num;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\043'
                 INEXT=I+5
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&percnt;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\045'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&permil;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\275'
                 INEXT=I+8
                 NOUT=NOUT+4
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           (STRING(I:MIN(LEN(STRING),I+2)).EQ.'_+-'.OR.
     -            STRING(I:MIN(LEN(STRING),I+2)).EQ.'_pm'))THEN
                 STROUT(NOUT+1:NOUT+3)='"A#'
                 INEXT=I+3
                 NOUT=NOUT+3
            ELSEIF(I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&plusmn;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\261#'
                 INEXT=I+8
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&rarr;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\065#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'&reg;')THEN
                 STROUT(NOUT+1:NOUT+8)='^[\\322]!'
                 INEXT=I+5
                 NOUT=NOUT+8
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&rsqb;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\135'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&radic;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\122#'
                 INEXT=I+7
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&sqrt;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\122#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&trade;')THEN
                 STROUT(NOUT+1:NOUT+8)='^[\\324]!'
                 INEXT=I+7
                 NOUT=NOUT+8
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'&partial;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\144#'
                 INEXT=I+9
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&part;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\144#'
                 INEXT=I+6
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'&approx;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\145#'
                 INEXT=I+8
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&asymp;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\145#'
                 INEXT=I+7
                 NOUT=NOUT+6
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'_sum')THEN
                 STROUT(NOUT+1:NOUT+3)='[S]'
                 INEXT=I+4
                 NOUT=NOUT+3
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&times;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\264#'
                 INEXT=I+7
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&uarr;')THEN
                 STROUT(NOUT+1:NOUT+6)='"\\255#'
                 INEXT=I+6
                 NOUT=NOUT+6
*   Punctuation and accents.
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&excl;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\041'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'&apos;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\047'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&grave;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\301'
                 INEXT=I+7
                 NOUT=NOUT+4
            ELSEIF(I+6.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+6)).EQ.'&acute;')THEN
                 STROUT(NOUT+1:NOUT+4)='\\302'
                 INEXT=I+7
                 NOUT=NOUT+4
*   Particle names.
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'electron-')THEN
                 STROUT(NOUT+1:NOUT+4)='e^-!'
                 INEXT=I+9
                 NOUT=NOUT+4
            ELSEIF(I+8.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+8)).EQ.'electron+')THEN
                 STROUT(NOUT+1:NOUT+4)='e^+!'
                 INEXT=I+9
                 NOUT=NOUT+4
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'mu-')THEN
                 STROUT(NOUT+1:NOUT+6)='[m]^-!'
                 INEXT=I+3
                 NOUT=NOUT+6
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'mu+')THEN
                 STROUT(NOUT+1:NOUT+6)='[m]^+!'
                 INEXT=I+3
                 NOUT=NOUT+6
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'tau-')THEN
                 STROUT(NOUT+1:NOUT+6)='[t]^-!'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'tau+')THEN
                 STROUT(NOUT+1:NOUT+6)='[t]^+!'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'pi-')THEN
                 STROUT(NOUT+1:NOUT+6)='[p]^-!'
                 INEXT=I+3
                 NOUT=NOUT+6
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'pi0')THEN
                 STROUT(NOUT+1:NOUT+6)='[p]^0!'
                 INEXT=I+3
                 NOUT=NOUT+6
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'pi+')THEN
                 STROUT(NOUT+1:NOUT+6)='[p]^+!'
                 INEXT=I+3
                 NOUT=NOUT+6
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'photon')THEN
                 STROUT(NOUT+1:NOUT+3)='[g]'
                 INEXT=I+7
                 NOUT=NOUT+3
*   Names of chemical compounds.
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'He-3')THEN
                 STROUT(NOUT+1:NOUT+5)='^3!He'
                 INEXT=I+4
                 NOUT=NOUT+5
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'He-4')THEN
                 STROUT(NOUT+1:NOUT+5)='^4!He'
                 INEXT=I+4
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'CO2')THEN
                 STROUT(NOUT+1:NOUT+5)='CO?2!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'CS2')THEN
                 STROUT(NOUT+1:NOUT+5)='CS?2!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'CH4')THEN
                 STROUT(NOUT+1:NOUT+5)='CH?4!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'CD4')THEN
                 STROUT(NOUT+1:NOUT+5)='CD?4!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'CH3OH')THEN
                 STROUT(NOUT+1:NOUT+7)='CH?3!OH'
                 INEXT=I+5
                 NOUT=NOUT+7
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'CF4')THEN
                 STROUT(NOUT+1:NOUT+5)='CF?4!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'CF3Br')THEN
                 STROUT(NOUT+1:NOUT+7)='CF?3!Br'
                 INEXT=I+5
                 NOUT=NOUT+7
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'CHF3')THEN
                 STROUT(NOUT+1:NOUT+6)='CHF?3!'
                 INEXT=I+4
                 NOUT=NOUT+6
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'BF3')THEN
                 STROUT(NOUT+1:NOUT+5)='BF?3!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'SF6')THEN
                 STROUT(NOUT+1:NOUT+5)='SF?6!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'H2O')THEN
                 STROUT(NOUT+1:NOUT+5)='H?2!O'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'N2O')THEN
                 STROUT(NOUT+1:NOUT+5)='N?2!O'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'C2H6')THEN
                 STROUT(NOUT+1:NOUT+8)='C?2!H?6!'
                 INEXT=I+4
                 NOUT=NOUT+8
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'C2F6')THEN
                 STROUT(NOUT+1:NOUT+8)='C?2!F?6!'
                 INEXT=I+4
                 NOUT=NOUT+8
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'C2F4H2')THEN
                 STROUT(NOUT+1:NOUT+12)='C?2!F?4!H?2!'
                 INEXT=I+6
                 NOUT=NOUT+12
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'C2H2F4')THEN
                 STROUT(NOUT+1:NOUT+12)='C?2!H?2!F?4!'
                 INEXT=I+6
                 NOUT=NOUT+12
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'C2F5H')THEN
                 STROUT(NOUT+1:NOUT+9)='C?2!F?5!H'
                 INEXT=I+5
                 NOUT=NOUT+9
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'C2HF5')THEN
                 STROUT(NOUT+1:NOUT+9)='C?2!HF?5!'
                 INEXT=I+5
                 NOUT=NOUT+9
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'C2H5OH')THEN
                 STROUT(NOUT+1:NOUT+10)='C?2!H?5!OH'
                 INEXT=I+6
                 NOUT=NOUT+10
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'C2H4')THEN
                 STROUT(NOUT+1:NOUT+8)='C?2!H?4!'
                 INEXT=I+4
                 NOUT=NOUT+8
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'C2H2')THEN
                 STROUT(NOUT+1:NOUT+8)='C?2!H?2!'
                 INEXT=I+4
                 NOUT=NOUT+8
            ELSEIF(I+3.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+3)).EQ.'C3H8')THEN
                 STROUT(NOUT+1:NOUT+8)='C?3!H?8!'
                 INEXT=I+4
                 NOUT=NOUT+8
            ELSEIF(I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'C3H7OH')THEN
                 STROUT(NOUT+1:NOUT+10)='C?3!H?7!OH'
                 INEXT=I+6
                 NOUT=NOUT+10
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'C4H10')THEN
                 STROUT(NOUT+1:NOUT+9)='C?4!H?10!'
                 INEXT=I+5
                 NOUT=NOUT+9
            ELSEIF(I+4.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+4)).EQ.'C5H12')THEN
                 STROUT(NOUT+1:NOUT+9)='C?5!H?12!'
                 INEXT=I+5
                 NOUT=NOUT+9
            ELSEIF(I+1.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+1)).EQ.'O2')THEN
                 STROUT(NOUT+1:NOUT+4)='O?2!'
                 INEXT=I+2
                 NOUT=NOUT+4
*   Units which need special formatting.
            ELSEIF(UNIT.AND.I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'cm2')THEN
                 STROUT(NOUT+1:NOUT+5)='cm^2!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(UNIT.AND.I+2.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+2)).EQ.'cm3')THEN
                 STROUT(NOUT+1:NOUT+5)='cm^3!'
                 INEXT=I+3
                 NOUT=NOUT+5
            ELSEIF(UNIT.AND.I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'microsec')THEN
                 STROUT(NOUT+1:NOUT+6)='[m]sec'
                 INEXT=I+8
                 NOUT=NOUT+6
            ELSEIF(UNIT.AND.I+5.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+5)).EQ.'micron')THEN
                 STROUT(NOUT+1:NOUT+4)='[m]m'
                 INEXT=I+6
                 NOUT=NOUT+4
            ELSEIF(UNIT.AND.I+7.LE.LEN(STRING).AND.
     -           STRING(I:MIN(LEN(STRING),I+7)).EQ.'microamp')THEN
                 STROUT(NOUT+1:NOUT+4)='[m]A'
                 INEXT=I+8
                 NOUT=NOUT+4
*   Now also replace underscores and ampersands that remain.
            ELSEIF(STRING(I:I).EQ.'_')THEN
                 STROUT(NOUT+1:NOUT+3)='[-]'
                 NOUT=NOUT+3
            ELSEIF(STRING(I:I).EQ.'&')THEN
                 STROUT(NOUT+1:NOUT+3)='"W#'
                 NOUT=NOUT+3
*   Copy all other characters as such.
            ELSE
                 STROUT(NOUT+1:NOUT+1)=STRING(I:I)
                 NOUT=NOUT+1
            ENDIF
10          CONTINUE
       ENDIF
*** Now plot the converted string.
20     CONTINUE
*   Debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Out: "'',A,''"''/26X,
     -      ''Plot location: '',2E10.3)') STROUT(1:NOUT),X,Y
*   Plot the string.
       CALL ITX(X,Y,STROUT(1:NOUT))
       END
CDECK  ID>, PLAEXP.
       SUBROUTINE PLAEXP(IVOL,IOFCOL)
*-----------------------------------------------------------------------
*   PLAEXP - Generates a table of polygons for an extrusion.
*   (Last changed on 12/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       REAL USERX0,USERX1,USERY0,USERY1,FRXMIN,FRXMAX,FRYMIN,FRYMAX,
     -      ARRANG,ARRLEN,BARFRC,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT
       LOGICAL LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,
     -      LWAITA,LWAITB,LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      WKMULT(MXWKLS)
       INTEGER NWK,WKID(MXWKLS),WKCON(MXWKLS),WKFREF(MXWKLS),
     -         WKLUN(MXWKLS),WKSTAT(MXWKLS),WKSREQ(MXWKLS),
     -         NCWKNM(MXWKLS),NCSTMP,IGHIST,IGBAR,NCGKS
       CHARACTER*20 WKNAME(MXWKLS),WKATTR(MXWKLS)
       CHARACTER*80 STAMP
       CHARACTER*(MXNAME) GKSLOG
       COMMON /GRADAT/ USERX0,USERX1,USERY0,USERY1,ARRANG,ARRLEN,
     -      BARFRC,
     -      FRXMIN,FRXMAX,FRYMIN,FRYMAX,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT,
     -      LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,LWAITA,LWAITB,
     -      LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      NWK,WKID,WKCON,WKFREF,WKLUN,WKSTAT,WKSREQ,NCWKNM,NCSTMP,
     -      IGHIST,IGBAR,NCGKS,WKMULT
       COMMON /GRACHR/ WKNAME,WKATTR,STAMP,GKSLOG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IREF,IOFCOL,N,IVOL,ICOL,IFAIL,I,IRPL,IORI
       DOUBLE PRECISION ZL,X0,Y0,Z0,A,B,C,CT,ST,CP,SP,FNORM,WW,
     -      U,V,W,XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),
     -      XN,YN
*** Locate the conductor.
       IF(IVOL.LT.1.OR.IVOL.GT.MXSOLI)THEN
            PRINT *,' !!!!!! PLAEXP WARNING : Volume reference is out'//
     -           ' of range ; not plotted.'
            RETURN
       ENDIF
       IREF=ISTART(IVOL)
       IF(IREF.LT.0.OR.IREF+9.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXP WARNING : Volume address is out'//
     -           ' of range ; not plotted.'
            RETURN
       ENDIF
*** Locate the extrusion parameters, first the half length in z.
       ZL=ABS(CBUF(IREF+2))
*   Centre.
       X0=CBUF(IREF+3)
       Y0=CBUF(IREF+4)
       Z0=CBUF(IREF+5)
*   Direction vector.
       FNORM=SQRT(CBUF(IREF+6)**2+CBUF(IREF+7)**2+CBUF(IREF+8)**2)
       IF(FNORM.LE.0)THEN
            PRINT *,' !!!!!! PLAEXP WARNING : Extrusion ',IVOL,' has'//
     -           ' a zero norm direction vector; not plotted.'
            RETURN
       ENDIF
       A= CBUF(IREF+6)/FNORM
       B= CBUF(IREF+7)/FNORM
       C= CBUF(IREF+8)/FNORM
*   Number of points
       N = NINT(CBUF(IREF+9))
       IF(N.GT.MXEDGE.OR.IREF+23+2*N.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXP WARNING : Volume address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*   Orientation
       IORI=NINT(CBUF(IREF+1))
*   Shorthand for the rotations.
       CT=CBUF(IREF+10)
       ST=CBUF(IREF+11)
       CP=CBUF(IREF+12)
       SP=CBUF(IREF+13)
*   Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEXP DEBUG   : Drawing'',
     -      '' an extrusion of volume '',I4/26X,
     -      '', N='',I5,'', Half-length='',E10.3/26X,''Centre='',3E10.3/
     -      26X,''Direction='',3E10.3)') IVOL,N,ZL,X0,Y0,Z0,A,B,C
*** Create the top lid.
       IF(CBUF(IREF+22).GT.0.5)THEN
            DO 10 I=1,N
*   Local coordinates,
            U=CBUF(IREF+23+2*I-1)
            V=CBUF(IREF+23+2*I)
            W=ZL
*   Rotate into place.
            XPL(I)=X0+CP*CT*U-SP*V+CP*ST*W
            YPL(I)=Y0+SP*CT*U+CP*V+SP*ST*W
            ZPL(I)=Z0   -ST*U        +CT*W
10          CONTINUE
*   Compute colour index.
            CALL COLWGT(A,B,C,WW)
            IF(WW.GT.0)THEN
                 ICOL=IOFCOL+NINT(MIN(1.0D0,WW)*(NPRCOL-1))
            ELSE
                 ICOL=IOFCOL
            ENDIF  
*   Store the plane.
            CALL PLABU1('STORE',IRPL,N,XPL,YPL,ZPL,A,B,C,ICOL,IVOL,
     -          IFAIL)
            IF(IFAIL.NE.0)PRINT *,' !!!!!! PLAEXP WARNING : Unable'//
     -          ' to store the top lid of an extrusion.'
       ENDIF
*** Create the bottom lid.
       IF(CBUF(IREF+23).GT.0.5)THEN
            DO 20 I=1,N
*   Local coordinates,
            U=CBUF(IREF+23+2*I-1)
            V=CBUF(IREF+23+2*I)
            W=-ZL
*   Rotate into place.
            XPL(I)=X0+CP*CT*U-SP*V+CP*ST*W
            YPL(I)=Y0+SP*CT*U+CP*V+SP*ST*W
            ZPL(I)=Z0   -ST*U        +CT*W
20          CONTINUE
*   Compute colour index.
            CALL COLWGT(-A,-B,-C,WW)
            IF(WW.GT.0)THEN
                 ICOL=IOFCOL+NINT(MIN(1.0D0,WW)*(NPRCOL-1))
            ELSE
                 ICOL=IOFCOL
            ENDIF  
*   Store the plane.
            CALL PLABU1('STORE',IRPL,N,XPL,YPL,ZPL,-A,-B,-C,
     -           ICOL,IVOL,IFAIL)
            IF(IFAIL.NE.0)PRINT *,' !!!!!! PLAEXP WARNING : Unable to'//
     -           ' store the bottom lid of an extrusion.'
       ENDIF
*** Create the side panels.
       IF(ZL.GT.0)THEN
            U=CBUF(IREF+23+2*N-1)
            V=CBUF(IREF+23+2*N)
            W=ZL
*   Rotate into place.
            XPL(1)=X0+CP*CT*U-SP*V+CP*ST*W
            YPL(1)=Y0+SP*CT*U+CP*V+SP*ST*W
            ZPL(1)=Z0   -ST*U        +CT*W
            XPL(2)=X0+CP*CT*U-SP*V-CP*ST*W
            YPL(2)=Y0+SP*CT*U+CP*V-SP*ST*W
            ZPL(2)=Z0   -ST*U        -CT*W
**  Go around the extrusion.
            DO 30 I=1,N
*   Bottom and top of the line along the axis of the extrusion.
            U=CBUF(IREF+23+2*I-1)
            V=CBUF(IREF+23+2*I)
            W=ZL
*   Rotated into place.
            XPL(3)=X0+CP*CT*U-SP*V-CP*ST*W
            YPL(3)=Y0+SP*CT*U+CP*V-SP*ST*W
            ZPL(3)=Z0   -ST*U        -CT*W
            XPL(4)=X0+CP*CT*U-SP*V+CP*ST*W
            YPL(4)=Y0+SP*CT*U+CP*V+SP*ST*W
            ZPL(4)=Z0   -ST*U        +CT*W
*   Compute the colour index for this segment.
            XN=CBUF(IREF+23+1+MOD(2*I-3+2*N,2*N))-
     -         CBUF(IREF+23+1+MOD(2*I-1+2*N,2*N))
            YN=CBUF(IREF+23+1+MOD(2*I-2+2*N,2*N))-
     -         CBUF(IREF+23+1+MOD(2*I-4+2*N,2*N))
            FNORM=SQRT(XN**2+YN**2)
            IF(FNORM.LE.0)THEN
                 PRINT *,' !!!!!! PLAEXP WARNING : Zero norm edge'//
     -              ' in extrusion ',IVOL
            ELSE
                 XN=-IORI*XN/FNORM
                 YN=-IORI*YN/FNORM
            ENDIF
            CALL COLWGT(CP*CT*XN-SP*YN,SP*CT*XN+CP*YN,-ST*XN,WW)
            IF(WW.GT.0)THEN
                 ICOL=IOFCOL+NINT(MIN(1.0D0,WW)*(NPRCOL-1))
            ELSE
                 ICOL=IOFCOL
            ENDIF  
*   Store the plane.
            CALL PLABU1('STORE',IRPL,4,XPL,YPL,ZPL,
     -             CP*CT*XN-SP*YN,SP*CT*XN+CP*YN,-ST*XN,ICOL,IVOL,IFAIL)
            IF(IFAIL.NE.0)PRINT *,' !!!!!! PLAEXP WARNING : Unable to'//
     -           ' store a panel of a extrusion.'
*   Shift the points.
            XPL(1)=XPL(4)
            YPL(1)=YPL(4)
            ZPL(1)=ZPL(4)
            XPL(2)=XPL(3)
            YPL(2)=YPL(3)
            ZPL(2)=ZPL(3)
30          CONTINUE
       ENDIF
*** Look for intersections with the outside box, x=xmin.
       CALL PLAEXC(IVOL,GXMIN,(GYMIN+GYMAX)/2,(GZMIN+GZMAX)/2,
     -      -1.0D0,0.0D0,0.0D0,IOFCOL+1)
*   x=xmax.
       CALL PLAEXC(IVOL,GXMAX,(GYMIN+GYMAX)/2,(GZMIN+GZMAX)/2,
     -      +1.0D0,0.0D0,0.0D0,IOFCOL+1)
*   y=ymin.
       CALL PLAEXC(IVOL,(GXMIN+GXMAX)/2,GYMIN,(GZMIN+GZMAX)/2,
     -      0.0D0,-1.0D0,0.0D0,IOFCOL+1)
*   y=ymax.
       CALL PLAEXC(IVOL,(GXMIN+GXMAX)/2,GYMAX,(GZMIN+GZMAX)/2,
     -      0.0D0,+1.0D0,0.0D0,IOFCOL+1)
*   z=zmin.
       CALL PLAEXC(IVOL,(GXMIN+GXMAX)/2,(GYMIN+GYMAX)/2,GZMIN,
     -      0.0D0,0.0D0,-1.0D0,IOFCOL+1)
*   z=zmax.
       CALL PLAEXC(IVOL,(GXMIN+GXMAX)/2,(GYMIN+GYMAX)/2,GZMAX,
     -      0.0D0,0.0D0,+1.0D0,IOFCOL+1)
       END
CDECK  ID>, PLAEXC.
       SUBROUTINE PLAEXC(IVOL,X0PL,Y0PL,Z0PL,APL,BPL,CPL,ICOL)
*-----------------------------------------------------------------------
*   PLAEXC - Cuts extrusion IVOL with a plane.
*   (Last changed on  8/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       REAL USERX0,USERX1,USERY0,USERY1,FRXMIN,FRXMAX,FRYMIN,FRYMAX,
     -      ARRANG,ARRLEN,BARFRC,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT
       LOGICAL LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,
     -      LWAITA,LWAITB,LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      WKMULT(MXWKLS)
       INTEGER NWK,WKID(MXWKLS),WKCON(MXWKLS),WKFREF(MXWKLS),
     -         WKLUN(MXWKLS),WKSTAT(MXWKLS),WKSREQ(MXWKLS),
     -         NCWKNM(MXWKLS),NCSTMP,IGHIST,IGBAR,NCGKS
       CHARACTER*20 WKNAME(MXWKLS),WKATTR(MXWKLS)
       CHARACTER*80 STAMP
       CHARACTER*(MXNAME) GKSLOG
       COMMON /GRADAT/ USERX0,USERX1,USERY0,USERY1,ARRANG,ARRLEN,
     -      BARFRC,
     -      FRXMIN,FRXMAX,FRYMIN,FRYMAX,DISPX0,DISPX1,DISPY0,DISPY1,
     -      GPXN,GPXN10,GPYN,GPYN10,GPXL,GPYL,GPXT,
     -      LGRID,LGRALL,LOGX,LOGY,LSTAMP,LGCLRB,LGCLRA,LWAITA,LWAITB,
     -      LXCCH,LGLCLP,LGMCLP,LGACLP,LGTCLP,
     -      NWK,WKID,WKCON,WKFREF,WKLUN,WKSTAT,WKSREQ,NCWKNM,NCSTMP,
     -      IGHIST,IGBAR,NCGKS,WKMULT
       COMMON /GRACHR/ WKNAME,WKATTR,STAMP,GKSLOG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IREF,N,IVOL,IFAIL,I,NPL,ICOL,IRPL
       DOUBLE PRECISION ZL,X0,Y0,Z0,A,B,C,CT,ST,CP,SP,FNORM,
     -      U,V,W,X1,Y1,Z1,X2,Y2,Z2,XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),
     -      X0PL,Y0PL,Z0PL,APL,BPL,CPL,XCUT,YCUT,ZCUT
*** Locate the conductor.
       IF(IVOL.LT.1.OR.IVOL.GT.MXSOLI)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Volume reference is out'//
     -           ' of range ; not plotted.'
            RETURN
       ENDIF
       IREF=ISTART(IVOL)
       IF(IREF.LT.0.OR.IREF+9.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Volume address is out'//
     -           ' of range ; not plotted.'
            RETURN
       ENDIF
*** Locate the extrusion parameters, first the half length in z.
       ZL=ABS(CBUF(IREF+2))
*   Centre.
       X0=CBUF(IREF+3)
       Y0=CBUF(IREF+4)
       Z0=CBUF(IREF+5)
*   Direction vector.
       FNORM=SQRT(CBUF(IREF+6)**2+CBUF(IREF+7)**2+CBUF(IREF+8)**2)
       IF(FNORM.LE.0)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Extrusion ',IVOL,' has'//
     -           ' a zero norm direction vector; not plotted.'
            RETURN
       ENDIF
       A= CBUF(IREF+6)/FNORM
       B= CBUF(IREF+7)/FNORM
       C= CBUF(IREF+8)/FNORM
*   Number of points
       N = NINT(CBUF(IREF+9))
       IF(N.GT.MXEDGE.OR.IREF+23+2*N.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Volume address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*   Shorthand for the rotations.
       CT=CBUF(IREF+10)
       ST=CBUF(IREF+11)
       CP=CBUF(IREF+12)
       SP=CBUF(IREF+13)
*   Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEXC DEBUG   : Drawing'',
     -      '' an extrusion of volume '',I4/26X,
     -      '', N='',I5,'', Half-length='',E10.3/26X,''Centre='',3E10.3/
     -      26X,''Direction='',3E10.3)') IVOL,N,ZL,X0,Y0,Z0,A,B,C
*** Initialise the number of points.
       NPL=0
*** Go through the lines of the top lid, first point.
       U=CBUF(IREF+23+2*N-1)
       V=CBUF(IREF+23+2*N)
       W=ZL
       X1=X0+CP*CT*U-SP*V+CP*ST*W
       Y1=Y0+SP*CT*U+CP*V+SP*ST*W
       Z1=Z0   -ST*U        +CT*W
*   Loop over the points.
       DO 10 I=1,N
*   Local coordinates,
       U=CBUF(IREF+23+2*I-1)
       V=CBUF(IREF+23+2*I)
       W=ZL
*   Rotate into place.
       X2=X0+CP*CT*U-SP*V+CP*ST*W
       Y2=Y0+SP*CT*U+CP*V+SP*ST*W
       Z2=Z0   -ST*U        +CT*W
*   Cut with the plane.
       CALL PLALIN(X1,Y1,Z1,X2,Y2,Z2,X0PL,Y0PL,Z0PL,APL,BPL,CPL,
     -      XCUT,YCUT,ZCUT,IFAIL)
*   Store the result if there is one.
       IF(IFAIL.EQ.0.AND.NPL.LE.MXEDGE)THEN
            NPL=NPL+1
            XPL(NPL)=XCUT
            YPL(NPL)=YCUT
            ZPL(NPL)=ZCUT
       ELSEIF(NPL.GE.MXEDGE)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Too many intersects'//
     -           ' between extrusion and plane; stopped.'
            RETURN
       ENDIF
*   Shift the coordinates.
       X1=X2
       Y1=Y2
       Z1=Z2
10     CONTINUE
*** Go through the lines of the bottom lid, first point.
       IF(ZL.GT.0)THEN
            U=CBUF(IREF+23+2*N-1)
            V=CBUF(IREF+23+2*N)
            W=-ZL
            X1=X0+CP*CT*U-SP*V+CP*ST*W
            Y1=Y0+SP*CT*U+CP*V+SP*ST*W
            Z1=Z0   -ST*U        +CT*W
*   Loop over the points.
            DO 20 I=1,N
*   Local coordinates,
            U=CBUF(IREF+23+2*I-1)
            V=CBUF(IREF+23+2*I)
            W=-ZL
*   Rotate into place.
            X2=X0+CP*CT*U-SP*V+CP*ST*W
            Y2=Y0+SP*CT*U+CP*V+SP*ST*W
            Z2=Z0   -ST*U        +CT*W
*   Cut with the plane.
            CALL PLALIN(X1,Y1,Z1,X2,Y2,Z2,X0PL,Y0PL,Z0PL,APL,BPL,CPL,
     -           XCUT,YCUT,ZCUT,IFAIL)
*   Store the result if there is one.
            IF(IFAIL.EQ.0.AND.NPL.LE.MXEDGE)THEN
                 NPL=NPL+1
                 XPL(NPL)=XCUT
                 YPL(NPL)=YCUT
                 ZPL(NPL)=ZCUT
            ELSEIF(NPL.GE.MXEDGE)THEN
                 PRINT *,' !!!!!! PLAEXC WARNING : Too many'//
     -                ' intersects between extrusion and plane;'//
     -                ' stopped.'
                 RETURN
            ENDIF
*   Shift the coordinates.
            X1=X2
            Y1=Y2
            Z1=Z2
20          CONTINUE
       ENDIF
*** Go through the ribs.
       DO 30 I=1,N
*   Bottom and top of the line along the axis of the extrusion.
       U=CBUF(IREF+23+2*N-1)
       V=CBUF(IREF+23+2*N)
       W=ZL
*   Rotated into place.
       X1=X0+CP*CT*U-SP*V-CP*ST*W
       Y1=Y0+SP*CT*U+CP*V-SP*ST*W
       Z1=Z0   -ST*U        -CT*W
       X2=X0+CP*CT*U-SP*V+CP*ST*W
       Y2=Y0+SP*CT*U+CP*V+SP*ST*W
       Z2=Z0   -ST*U        +CT*W
*   Cut with the plane.
       CALL PLALIN(X1,Y1,Z1,X2,Y2,Z2,X0PL,Y0PL,Z0PL,APL,BPL,CPL,
     -      XCUT,YCUT,ZCUT,IFAIL)
*   Store the result if there is one.
       IF(IFAIL.EQ.0.AND.NPL.LE.MXEDGE)THEN
            NPL=NPL+1
            XPL(NPL)=XCUT
            YPL(NPL)=YCUT
            ZPL(NPL)=ZCUT
       ELSEIF(NPL.GE.MXEDGE)THEN
            PRINT *,' !!!!!! PLAEXC WARNING : Too many intersects'//
     -           ' between extrusion and plane; stopped.'
            RETURN
       ENDIF
30     CONTINUE
*** Get rid of butterflies.
       CALL BUTFLD(NPL,XPL,YPL,ZPL)
*** Store the plane.
       IF(NPL.GE.3)THEN
            CALL PLABU1('STORE',IRPL,NPL,XPL,YPL,ZPL,
     -           APL,BPL,CPL,ICOL,IVOL,IFAIL)
            IF(IFAIL.NE.0)PRINT *,' !!!!!! PLAEXC WARNING : Failed to'//
     -           ' store a side cut of an extrusion.'
       ENDIF
       END
CDECK  ID>, PLAEXI.
       SUBROUTINE PLAEXI(IVOL,XPOS,YPOS,ZPOS,INSIDE)
*-----------------------------------------------------------------------
*   PLAEXI - Determines whether a point is located inside an extrusion.
*   (Last changed on  8/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IREF,IVOL,I,N
       DOUBLE PRECISION ZL,X0,Y0,Z0,CT,ST,CP,SP,XPOS,YPOS,ZPOS,U,V,W,
     -      XPL(MXEDGE),YPL(MXEDGE)
       LOGICAL INSIDE,EDGE
*** Locate the conductor.
       IF(IVOL.LT.1.OR.IVOL.GT.MXSOLI)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume reference is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
       IREF=ISTART(IVOL)
       IF(IREF.LT.0.OR.IREF+9.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*** Locate the extrusion parameters, first the half length in z.
       ZL=ABS(CBUF(IREF+2))
*   Centre.
       X0=CBUF(IREF+3)
       Y0=CBUF(IREF+4)
       Z0=CBUF(IREF+5)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEXI DEBUG   : Checking'',
     -      '' extrusion volume '',I4/26X,
     -      '', Half-length='',E10.3/26X,''Centre=   '',3E10.3)')
     -      IVOL,ZL,X0,Y0,Z0
*   Number of points
       N = NINT(CBUF(IREF+9))
       IF(N.GT.MXEDGE.OR.IREF+23+2*N.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*   Shorthand for the rotations.
       CT=CBUF(IREF+10)
       ST=CBUF(IREF+11)
       CP=CBUF(IREF+12)
       SP=CBUF(IREF+13)
*** Transform the point to local coordinates.
       U=+CP*CT*(XPOS-X0)+SP*CT*(YPOS-Y0)-ST*(ZPOS-Z0)
       V=-SP   *(XPOS-X0)+CP*   (YPOS-Y0)
       W=+CP*ST*(XPOS-X0)+SP*ST*(YPOS-Y0)+CT*(ZPOS-Z0)
*** See whether the point is inside.
       DO 10 I=1,N
       XPL(I)=CBUF(IREF+23+2*I-1)
       YPL(I)=CBUF(IREF+23+2*I)
 10    CONTINUE
       CALL INTERD(N,XPL,YPL,U,V,INSIDE,EDGE)
       END
CDECK  ID>, PLAEXE.
       SUBROUTINE PLAEXE(IVOL,XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX)
*-----------------------------------------------------------------------
*   PLAEXE - Computes an enveloping box of an extrusion.
*   (Last changed on  9/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IREF,IVOL,I,N
       DOUBLE PRECISION ZL,X0,Y0,Z0,XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,
     -      XEMIN,YEMIN,XEMAX,YEMAX
*** Locate the conductor.
       IF(IVOL.LT.1.OR.IVOL.GT.MXSOLI)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume reference is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
       IREF=ISTART(IVOL)
       IF(IREF.LT.0.OR.IREF+9.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*** Locate the extrusion parameters, first the half length in z.
       ZL=ABS(CBUF(IREF+2))
*   Centre.
       X0=CBUF(IREF+3)
       Y0=CBUF(IREF+4)
       Z0=CBUF(IREF+5)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEXE DEBUG   :'',
     -      '' Extrusion volume '',I4/26X,
     -      '', Half-length='',E10.3/26X,''Centre=   '',3E10.3)')
     -      IVOL,ZL,X0,Y0,Z0
*   Number of points
       N = NINT(CBUF(IREF+9))
       IF(N.LT.3.OR.N.GT.MXEDGE.OR.IREF+23+2*N.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXI WARNING : Volume address is out'//
     -           ' of range or N is not valid ; not checked.'
            RETURN
       ENDIF
*** Find range of the curve
       XEMIN=CBUF(IREF+24)
       XEMAX=CBUF(IREF+24)
       YEMIN=CBUF(IREF+25)
       YEMAX=CBUF(IREF+25)
       DO 10 I=2,N
       IF(XEMIN.GT.CBUF(IREF+23+2*I-1))XEMIN=CBUF(IREF+23+2*I-1)
       IF(XEMAX.LT.CBUF(IREF+23+2*I-1))XEMAX=CBUF(IREF+23+2*I-1)
       IF(YEMIN.GT.CBUF(IREF+23+2*I))  YEMIN=CBUF(IREF+23+2*I)
       IF(YEMAX.LT.CBUF(IREF+23+2*I))  YEMAX=CBUF(IREF+23+2*I)
 10    CONTINUE
*** Take the margins wide.
       XMIN=X0-SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       YMIN=Y0-SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       ZMIN=Z0-SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       XMAX=X0+SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       YMAX=Y0+SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       ZMAX=Z0+SQRT(MAX(XEMIN,YEMIN,XEMAX,YEMAX)**2+ZL**2)
       END
CDECK  ID>, PLAEXD.
       SUBROUTINE PLAEXD(ISOL,NVTX,XVTX,YVTX,ZVTX,XNORM,YNORM,ZNORM,DIS)
*-----------------------------------------------------------------------
*   PLAEXD - Returns the discretisation level required for a primitive.
*   (Last changed on  9/ 10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER ISOL,NVTX,IREF
       DOUBLE PRECISION XVTX(*), YVTX(*), ZVTX(*), XNORM, YNORM, ZNORM,
     -      CT,ST,CP,SP,U,V,W,DIS
*** Locate the conductor.
       IF(ISOL.LT.1.OR.ISOL.GT.MXSOLI)THEN
            PRINT *,' !!!!!! PLAEXD WARNING : Solid reference is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
       IREF=ISTART(ISOL)
       IF(IREF.LT.0.OR.IREF+21.GT.MXSBUF)THEN
            PRINT *,' !!!!!! PLAEXD WARNING : Solid address is out'//
     -           ' of range ; not checked.'
            RETURN
       ENDIF
*** Locate the extrusion rotation parameters.
       CT=CBUF(IREF+10)
       ST=CBUF(IREF+11)
       CP=CBUF(IREF+12)
       SP=CBUF(IREF+13)
*** Transform the normal vector to local coordinates.
       U=+CP*CT*XNORM+SP*CT*YNORM-ST*ZNORM
       V=-SP   *XNORM+CP*   YNORM
       W=+CP*ST*XNORM+SP*ST*YNORM+CT*ZNORM
C      print *,' Axis vector: ',u,v,w
*** Identify the vector.
       IF(W.GT.MAX(ABS(U),ABS(V)))THEN
            DIS=CBUF(IREF+19)
       ELSEIF(W.LT.-MAX(ABS(U),ABS(V)))THEN
            DIS=CBUF(IREF+20)
       ELSE
            DIS=CBUF(IREF+21)
       ENDIF
*   Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEXD DEBUG   :'',
     -      '' Discretisation of solid '',I5,'' (extrusion)''/
     -      '' Norm vector: '',3F10.3/
     -      '' Discretisation: '',E12.5)')
     -      ISOL,U,V,W,DIS
       END
CDECK  ID>, PLABEM.
       SUBROUTINE PLABEM(IFAIL)
*-----------------------------------------------------------------------
*   PLABEM - Prepares panels for BEM applications: removes the contacts
*            and cuts polygons to rectangles and right-angle triangles.
*   (Last changed on 21/10/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XPL1(MXEDGE),YPL1(MXEDGE),ZPL1(MXEDGE),
     -      XPL2(MXEDGE),YPL2(MXEDGE),ZPL2(MXEDGE),
     -      XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),
     -      EPSANG,EPSXYZ,AN1,BN1,CN1,DN1,AN2,BN2,CN2,DN2,ROT(3,3),ZM,
     -      VLIST(MXPLAN,4),EPSX,EPSY
       INTEGER I,J,K,L,NREF,NPL1,NPL2,NREFO,IREFO(MXPLAN),ITYPO(MXPLAN),
     -      ICOL1,ICOL2,IVOL1,IVOL2,IREF1,REFOLD(MXPLAN),NOLD,M,
     -      IFAIL,IFAIL1,LIST(MXPLAN,4),NLIST,JMIN,NREFOO,IREFOO(MXPLAN)
       LOGICAL MARK(MXPLAN),EQUAL1,EQUAL2,EQUAL3,EQUAL4,CHANGE
*** Assume failure.
       IFAIL=1
*** Establish tolerances.
       EPSANG = BEMEPA
       EPSXYZ = BEMEPD
       CALL EPSSET('SET',EPSXYZ,EPSXYZ,EPSXYZ)
*** Count panels.
       CALL PLABU1('QUERY',NREF,NPL1,XPL1,YPL1,ZPL1,AN1,BN1,CN1,
     -      ICOL1,IVOL1,IFAIL1)
C       print *,' Found ',nref,' panels.'
*   Set the flags.
       DO 60 I=1,NREF
       MARK(I)=.FALSE.
60     CONTINUE
*   Keep track of the existing panels.
       NOLD=0
*** Pick up panels which coincide potentially.
       DO 10 I=1,NREF
*   Fetch one panel.
       CALL PLABU1('READ',I,NPL1,XPL1,YPL1,ZPL1,AN1,BN1,CN1,
     -      ICOL1,IVOL1,IFAIL1)
       IF(IFAIL1.NE.0)GOTO 10
C       print *,' *** Checking from panel ',i,' with ',npl1,' nodes'
*   Keep the references
       NOLD=NOLD+1
       REFOLD(NOLD)=I
*   Skip panels already done.
       IF(MARK(I))GOTO 10
*   Clear buffer 2.
       CALL PLABU2('RESET',IREF1,NPL1,XPL2,YPL2,ZPL2,
     -      AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
*   Establish its norm and offset.
       DN1=AN1*XPL1(1)+BN1*YPL1(1)+CN1*ZPL1(1)
C       print *,' Norm vector: ',AN1,BN1,CN1,DN1
*   Rotation matrix.
       IF(ABS(CN1).LE.ABS(AN1).AND.ABS(CN1).LE.ABS(BN1))THEN
C            print *,' Rotation: removing C'
            ROT(1,1)= BN1/SQRT(AN1*AN1+BN1*BN1)
            ROT(2,1)=-AN1/SQRT(AN1*AN1+BN1*BN1)
            ROT(3,1)= 0.0
       ELSEIF(ABS(BN1).LE.ABS(AN1).AND.ABS(BN1).LE.ABS(CN1))THEN
C            print *,' Rotation: removing B'
            ROT(1,1)= CN1/SQRT(AN1*AN1+CN1*CN1)
            ROT(2,1)= 0.0
            ROT(3,1)=-AN1/SQRT(AN1*AN1+CN1*CN1)
       ELSE
C            print *,' Rotation: removing A'
            ROT(1,1)= 0.0
            ROT(2,1)= CN1/SQRT(BN1*BN1+CN1*CN1)
            ROT(3,1)=-BN1/SQRT(BN1*BN1+CN1*CN1)
       ENDIF
       ROT(1,3)=AN1
       ROT(2,3)=BN1
       ROT(3,3)=CN1
       ROT(1,2)=ROT(2,3)*ROT(3,1)-ROT(3,3)*ROT(2,1)
       ROT(2,2)=ROT(3,3)*ROT(1,1)-ROT(1,3)*ROT(3,1)
       ROT(3,2)=ROT(1,3)*ROT(2,1)-ROT(2,3)*ROT(1,1)
C       do k=1,3
C       print '(3f10.3)',(rot(k,l),l=1,3)
C       enddo
*   Rotate it in place.
       ZM=0
       DO 30 K=1,NPL1
       XPL(K)=ROT(1,1)*XPL1(K)+ROT(2,1)*YPL1(K)+ROT(3,1)*ZPL1(K)
       YPL(K)=ROT(1,2)*XPL1(K)+ROT(2,2)*YPL1(K)+ROT(3,2)*ZPL1(K)
       ZPL(K)=ROT(1,3)*XPL1(K)+ROT(2,3)*YPL1(K)+ROT(3,3)*ZPL1(K)
       ZM=ZM+ZPL(K)
30     CONTINUE
       ZM=ZM/NPL1
*   Store it and keep reference data.
       NLIST=1
       CALL PLABU2('STORE',LIST(NLIST,3),NPL1,XPL,YPL,ZPL,
     -      0.0D0,0.0D0,1.0D0,ZM,ICOL1,IFAIL1)
       LIST(NLIST,1)=IVOL1
       LIST(NLIST,2)=0
       VLIST(NLIST,1)=AN1
       VLIST(NLIST,2)=BN1
       VLIST(NLIST,3)=CN1
       VLIST(NLIST,4)=DN1
*** Pick up all matching planes.
       DO 20 J=I+1,NREF
       IF(MARK(J))GOTO 20
C       print *,' Checking against ',j
       CALL PLABU1('READ',J,NPL2,XPL2,YPL2,ZPL2,AN2,BN2,CN2,
     -      ICOL2,IVOL2,IFAIL1)
*   See whether this matches the first.
       DN2=AN2*XPL2(1)+BN2*YPL2(1)+CN2*ZPL2(1)
C       print *,' Norm vector: ',AN2,BN2,CN2,DN2
C       print *,' inner product = ',AN1*AN2+BN1*BN2+CN1*CN2
C       print *,' plane offset  = ',
C     -      DN1-DN2*(AN1*AN2+BN1*BN2+CN1*CN2)
       IF(ABS(ABS(AN1*AN2+BN1*BN2+CN1*CN2)-1.0).GT.EPSANG.OR.
     -      ABS(DN1-DN2*(AN1*AN2+BN1*BN2+CN1*CN2)).GT.EPSXYZ)
     -      GOTO 20
*   Found a match
C       print *,' Found a matching plane'
       MARK(J)=.TRUE.
*   Rotate this plane too.
       ZM=0
       DO 40 K=1,NPL2
       XPL(K)=ROT(1,1)*XPL2(K)+ROT(2,1)*YPL2(K)+ROT(3,1)*ZPL2(K)
       YPL(K)=ROT(1,2)*XPL2(K)+ROT(2,2)*YPL2(K)+ROT(3,2)*ZPL2(K)
       ZPL(K)=ROT(1,3)*XPL2(K)+ROT(2,3)*YPL2(K)+ROT(3,3)*ZPL2(K)
       ZM=ZM+ZPL(K)
40     CONTINUE
       ZM=ZM/NPL2
*   Store it.
       IF(NLIST+1.GT.MXPLAN)THEN
            PRINT *,' !!!!!! PLABEM WARNING : Too many panels.'
            RETURN
       ENDIF
       NLIST=NLIST+1
       CALL PLABU2('STORE',LIST(NLIST,3),NPL2,XPL,YPL,ZPL,
     -      0.0D0,0.0D0,1.0D0,ZM,ICOL2,IFAIL1)
       LIST(NLIST,1)=IVOL2
       LIST(NLIST,2)=0
       VLIST(NLIST,1)=AN2
       VLIST(NLIST,2)=BN2
       VLIST(NLIST,3)=CN2
       VLIST(NLIST,4)=DN2
20     CONTINUE
C       print *,' Listing of panels before cutting:'
C       do j=1,nlist
C       print *,' Panel ',j,': volumes ',list(j,1),list(j,2)
C       enddo
*** Cut them as long as needed till no contacts remain.
       JMIN=1
100    CONTINUE
       DO 110 J=1,NLIST
       IF(LIST(J,3).LE.0.OR.
     -      J.LT.JMIN.OR.
     -      (LIST(J,1).GT.0.AND.LIST(J,2).GT.0))GOTO 110
       DO 120 K=J+1,NLIST
       IF(LIST(K,3).LE.0.OR.
     -      (LIST(K,1).GT.0.AND.LIST(K,2).GT.0))GOTO 120
C       print *,' Cutting ',list(j,3),list(k,3)
*   Separate contact and non-contact areas.
       CALL PLAOVL(LIST(J,3),LIST(K,3),NREFO,IREFO,ITYPO,
     -      EPSX,EPSY,IFAIL1)
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'('' Input volumes: '',2I4,4X,2I4)')
     -          LIST(J,1),LIST(J,2),LIST(K,1),LIST(K,2)
            WRITE(LUNOUT,'('' Norm 1: '',4F10.3)')
     -          VLIST(J,1),VLIST(J,2),VLIST(J,3),VLIST(J,4)
            WRITE(LUNOUT,'('' Norm 2: '',4F10.3)')
     -          VLIST(K,1),VLIST(K,2),VLIST(K,3),VLIST(K,4)
            WRITE(LUNOUT,'('' Output panels: '',I4)') NREFO
            DO 310 L=1,NREFO
            WRITE(LUNOUT,'('' Primitive '',I2,'' type '',I2)')
     -           IREFO(L),ITYPO(L)
            CALL PLABU2('READ',IREFO(L),NPL2,XPL2,YPL2,ZPL2,
     -                 AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            DO 320 M=1,NPL2
            WRITE(LUNOUT,'(2X,I2,'': '',3F10.3)') 
     -           M,XPL2(M),YPL2(M),ZPL2(M)
320         CONTINUE
310         CONTINUE
       ENDIF
*   If there are just 2 panels, see whether there is a new one
       IF(NREFO.EQ.2)THEN
            CALL PLAEQU(LIST(J,3),IREFO(1),EPSX,EPSY,EQUAL1)
            CALL PLAEQU(LIST(J,3),IREFO(2),EPSX,EPSY,EQUAL2)
            CALL PLAEQU(LIST(K,3),IREFO(1),EPSX,EPSY,EQUAL3)
            CALL PLAEQU(LIST(K,3),IREFO(2),EPSX,EPSY,EQUAL4)
            IF((EQUAL1.OR.EQUAL3).AND.(EQUAL2.OR.EQUAL4))THEN
                 CHANGE=.FALSE.
            ELSE
                 CHANGE=.TRUE.
            ENDIF
       ELSE
            CHANGE=.TRUE.
       ENDIF
C      print *,' Change flag: ',change
*   If there is no change, delete them.
       IF(.NOT.CHANGE)THEN
C            print *,' 2 output planes - removing them'
            CALL PLABU2('DELETE',IREFO(1),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            CALL PLABU2('DELETE',IREFO(2),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
*   Buffer overflow
       ELSEIF(NLIST+NREFO.GT.MXPLAN)THEN
            PRINT *,' !!!!!! PLABEM WARNING : Overflow of panel'//
     -           ' buffer; abandoned.'
            IFAIL=1
            RETURN
*   Otherwise delete the existing planes and restart the loops
       ELSE
C            print *,' ',nrefo,' output planes, removing old planes'
            CALL PLABU2('DELETE',LIST(J,3),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            CALL PLABU2('DELETE',LIST(K,3),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            LIST(J,3)=-ABS(LIST(J,3))
            LIST(K,3)=-ABS(LIST(K,3))
            DO 130 L=1,NREFO
            IF(ITYPO(L).EQ.1)THEN
                 LIST(NLIST+L,1)=MAX(LIST(J,1),LIST(J,2))
                 LIST(NLIST+L,2)=0
                 VLIST(NLIST+L,1)=VLIST(J,1)
                 VLIST(NLIST+L,2)=VLIST(J,2)
                 VLIST(NLIST+L,3)=VLIST(J,3)
                 VLIST(NLIST+L,4)=VLIST(J,4)
            ELSEIF(ITYPO(L).EQ.2)THEN
                 LIST(NLIST+L,1)=MAX(LIST(K,1),LIST(K,2))
                 LIST(NLIST+L,2)=0
                 VLIST(NLIST+L,1)=VLIST(K,1)
                 VLIST(NLIST+L,2)=VLIST(K,2)
                 VLIST(NLIST+L,3)=VLIST(K,3)
                 VLIST(NLIST+L,4)=VLIST(K,4)
            ELSE
                 LIST(NLIST+L,1)=MAX(LIST(J,1),LIST(J,2))
                 LIST(NLIST+L,2)=MAX(LIST(K,1),LIST(K,2))
                 VLIST(NLIST+L,1)=VLIST(J,1)
                 VLIST(NLIST+L,2)=VLIST(J,2)
                 VLIST(NLIST+L,3)=VLIST(J,3)
                 VLIST(NLIST+L,4)=VLIST(J,4)
            ENDIF
            LIST(NLIST+L,3)=IREFO(L)
            IF(LDEBUG)WRITE(LUNOUT,'('' Panel '',I3,'' volume flags: '',
     -           2I4,'' NORM: '',4F10.3)')
     -           L,LIST(NLIST+L,1),LIST(NLIST+L,2),
     -           VLIST(NLIST+L,1),VLIST(NLIST+L,2),
     -           VLIST(NLIST+L,3),VLIST(NLIST+L,4)
130         CONTINUE
            NLIST=NLIST+NREFO
            JMIN=J+1
            GOTO 100
       ENDIF
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'('' Listing of panels after cutting:'')')
            DO 330 L=1,NLIST
            IF(LIST(L,3).GT.0)THEN
                 CALL PLABU2('READ',LIST(L,3),NPL2,XPL2,YPL2,ZPL2,
     -                AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
                 WRITE(LUNOUT,'('' Panel '',I3,'': with volumes '',2I4,
     -                '', buf 2 ref = '',I4,'' corners: '',I4)')
     -                L,LIST(L,1),LIST(L,2),LIST(L,3),NPL2
            ENDIF
330         CONTINUE
       ENDIF
120    CONTINUE
110    CONTINUE
*** And rotate the panels back in place.
       DO 200 J=1,NLIST
       IF(LIST(J,3).LE.0)GOTO 200
*   Reduce to rectangles and right-angle triangles
       CALL PLATRC(LIST(J,3),NREFO,IREFO,IFAIL1)
       IF(IFAIL1.NE.0)PRINT *,' !!!!!! PLABEM WARNING : Reduction of'//
     -      ' polygons to rectangles and triangles failed.'
*   Loop over the rectangles and triangles.
       DO 220 L=1,NREFO
       if(.false.)then
*   Improve their quality by further cutting.
            CALL PLATRQ(IREFO(L),NREFOO,IREFOO,IFAIL1)
            DO 230 M=1,NREFOO
*   Fetch
            CALL PLABU2('READ',IREFOO(M),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! PLABEM WARNING : Failed'//
     -           ' to find a panel.'
*   Rotate.
C            print *,' After rotating back'
            DO 210 K=1,NPL2
            XPL(K)=ROT(1,1)*XPL2(K)+ROT(1,2)*YPL2(K)+ROT(1,3)*ZPL2(K)
            YPL(K)=ROT(2,1)*XPL2(K)+ROT(2,2)*YPL2(K)+ROT(2,3)*ZPL2(K)
            ZPL(K)=ROT(3,1)*XPL2(K)+ROT(3,2)*YPL2(K)+ROT(3,3)*ZPL2(K)
C            print '(3f10.3)',xpl1(k),ypl1(k),zpl1(k)
210         CONTINUE
*   Store.
            CALL PLABU1('STORE',IREF1,NPL2,XPL,YPL,ZPL,AN1,BN1,CN1,
     -           LIST(J,2),LIST(J,1),IFAIL1)
C            print *,' Buf 1 ref = ',iref1,', Buf 2 ref = ',list(j,3),
C     -           ', vol: ',LIST(J,1),LIST(J,2),' length: ',npl2
230          CONTINUE
       else
            CALL PLABU2('READ',IREFO(L),NPL2,XPL2,YPL2,ZPL2,
     -           AN2,BN2,CN2,DN2,ICOL2,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! PLABEM WARNING : Failed'//
     -           ' to find a panel.'
*   Rotate.
C            print *,' After rotating back'
            DO 211 K=1,NPL2
            XPL(K)=ROT(1,1)*XPL2(K)+ROT(1,2)*YPL2(K)+ROT(1,3)*ZPL2(K)
            YPL(K)=ROT(2,1)*XPL2(K)+ROT(2,2)*YPL2(K)+ROT(2,3)*ZPL2(K)
            ZPL(K)=ROT(3,1)*XPL2(K)+ROT(3,2)*YPL2(K)+ROT(3,3)*ZPL2(K)
C            print '(3f10.3)',xpl1(k),ypl1(k),zpl1(k)
211         CONTINUE
*   Store.
            CALL PLABU1('STORE',IREF1,NPL2,XPL,YPL,ZPL,
     -           VLIST(J,1),VLIST(J,2),VLIST(J,3),
     -           LIST(J,2),LIST(J,1),IFAIL1)
C            print *,' Buf 1 ref = ',iref1,', Buf 2 ref = ',IREFO(L),
C     -           ', vol: ',LIST(J,1),LIST(J,2),' length: ',npl2
       endif
220    CONTINUE
200    CONTINUE
*   Transfer the new panels.
10     CONTINUE
*** Delete the original panels.
       DO 300 I=1,NOLD
       CALL PLABU1('DELETE',REFOLD(I),NPL2,XPL,YPL,ZPL,
     -      AN2,BN2,CN2,ICOL2,IVOL2,IFAIL1)
C       if(ifail1.ne.0)print *,' Deleting old ',refold(i),' failed.'
300    CONTINUE
*** Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, PLAOVL.
       SUBROUTINE PLAOVL(IREF1,IREF2,NREFO,IREFO,ITYPO,EPSX,EPSY,IFAIL)
*-----------------------------------------------------------------------
*   PLAOVL - Isolates the parts of plane 1 that are not hidden by 2.
*   (Last changed on 13/ 5/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       INTEGER MXCORN
       PARAMETER(MXCORN=3*MXEDGE)
       DOUBLE PRECISION
     -      XPL1(MXEDGE),YPL1(MXEDGE),ZPL1(MXEDGE),APL1,BPL1,CPL1,DPL1,
     -      XPL2(MXEDGE),YPL2(MXEDGE),ZPL2(MXEDGE),APL2,BPL2,CPL2,DPL2,
     -      XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),
     -      EPSD,XMEAN,YMEAN,ZMEAN,XL(MXCORN,2),YL(MXCORN,2),
     -      Q(MXCORN,2),QMIN,XAUX,YAUX,QAUX,
     -      XC,YC,EPSX,EPSY,EPSZ,XMIN,YMIN,XMAX,YMAX,
     -      XMIN1,YMIN1,XMAX1,YMAX1,
     -      XMIN2,YMIN2,XMAX2,YMAX2
       INTEGER NPL1,NPL2,NPL,IFAIL1,IFAIL2,IFAIL,I,J,K,N1,N2,IP1,IP2,NP,
     -      IP1L,IP1LL,IS1,IS2,IL,M1,M2,IQMIN,IAUX,IT(MXCORN,2),
     -      IREF(MXCORN,2,2),NFOUND,IREFO(MXPLAN),ITYPO(MXPLAN),
     -      IREF1,IREF2,NREFO,ICOL1,ICOL2,IDIR,JP1,JP2,KP1,KP2,IMAX
C    -      ,l
       LOGICAL ADD,ONLIND,OK,KEEP,MARK1(MXEDGE),MARK2(MXEDGE),
     -      ADDED,INSIDE,EDGE,FIRST,CROSS
       EXTERNAL ONLIND
*** Initial setting of the number of produced planes.
       NREFO=0
*** Retrieve both planes.
       CALL PLABU2('READ',IREF1,NPL1,XPL1,YPL1,ZPL1,APL1,BPL1,CPL1,DPL1,
     -      ICOL1,IFAIL1)
       CALL PLABU2('READ',IREF2,NPL2,XPL2,YPL2,ZPL2,APL2,BPL2,CPL2,DPL2,
     -      ICOL2,IFAIL2)
       IF(IFAIL1.NE.0.OR.IFAIL2.NE.0)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Unable to retrieve a'//
     -           ' projected polygon; skipped.'
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAOVL DEBUG   :''//
     -           '' Reference numbers: '',2I4)') IREF1,IREF2
            IFAIL=1
            RETURN
       ENDIF
*** If the size of either is 0, simply return.
       IF(NPL1.LE.2.OR.NPL2.LE.2)THEN
            KEEP=.TRUE.
            IFAIL=0
            RETURN
       ENDIF
*** Compute the various tolerances.
       XMIN1=XPL1(1)
       YMIN1=YPL1(1)
       XMAX1=XPL1(1)
       YMAX1=YPL1(1)
       XMEAN=0
       YMEAN=0
       ZMEAN=0
       DO 10 I=1,NPL1
       XMIN1=MIN(XMIN1,XPL1(I))
       YMIN1=MIN(YMIN1,YPL1(I))
       XMAX1=MAX(XMAX1,XPL1(I))
       YMAX1=MAX(YMAX1,YPL1(I))
       XMEAN=XMEAN+XPL1(I)
       YMEAN=YMEAN+YPL1(I)
       ZMEAN=ZMEAN+ZPL1(I)
10     CONTINUE
       XMIN2=XPL2(1)
       YMIN2=YPL2(1)
       XMAX2=XPL2(1)
       YMAX2=YPL2(1)
       DO 20 I=1,NPL2
       XMIN2=MIN(XMIN2,XPL2(I))
       YMIN2=MIN(YMIN2,YPL2(I))
       XMAX2=MAX(XMAX2,XPL2(I))
       YMAX2=MAX(YMAX2,YPL2(I))
       XMEAN=XMEAN+XPL2(I)
       YMEAN=YMEAN+YPL2(I)
       ZMEAN=ZMEAN+ZPL2(I)
20     CONTINUE
       XMIN=MIN(XMIN1,XMIN2)
       YMIN=MIN(YMIN1,YMIN2)
       XMAX=MAX(XMAX1,XMAX2)
       YMAX=MAX(YMAX1,YMAX2)
       IF(LEPSG)THEN
            EPSX=EPSGX
            EPSY=EPSGY
       ELSE
            EPSX=1.0D-6*MAX(ABS(XMAX),ABS(XMIN))
            EPSY=1.0D-6*MAX(ABS(YMAX),ABS(YMIN))
       ENDIF
       XMEAN=XMEAN/DBLE(NPL1+NPL2)
       YMEAN=YMEAN/DBLE(NPL1+NPL2)
       ZMEAN=ZMEAN/DBLE(NPL1+NPL2)
*   Override the z-tolerance.
       EPSD=1.0E-6
       EPSZ=1.0E-6
*   Debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAOVL DEBUG   :'',
     -      '' Tolerances: x='',E12.5,'', y='',E12.5)')
     -      EPSX,EPSY
*   Preset the ZPL array to the mean z value.
       DO 40 I=1,MXEDGE
       ZPL(I)=ZMEAN
40     CONTINUE
*** Establish the list of special points around polygon 1.
       N1=0
       OK=.TRUE.
       DO 100 I=1,NPL1
*   Add the vertex.
       IF(N1+1.GT.MXCORN)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -           ' points around a polygon ; list reduced.'
            OK=.FALSE.
            GOTO 150
       ENDIF
       N1=N1+1
       XL(N1,1)=XPL1(I)
       YL(N1,1)=YPL1(I)
       IT(N1,1)=1
       Q(N1,1)=0
*   If also on 2 or vertex of 2, flag it as crossing or foreign.
       DO 160 J=1,NPL2
       IF(ABS(XPL2(J)-XPL1(I)).LT.EPSX.AND.
     -      ABS(YPL2(J)-YPL1(I)).LT.EPSY)IT(N1,1)=2
       IF(ONLIND(XPL2(1+MOD(J-1,NPL2)),YPL2(1+MOD(J-1,NPL2)),
     -           XPL2(1+MOD(J  ,NPL2)),YPL2(1+MOD(J  ,NPL2)),
     -           XPL1(I              ),YPL1(I)             ).AND.
     -      (ABS(XPL2(1+MOD(J-1,NPL2))-XPL1(I)).GT.EPSX.OR.
     -       ABS(YPL2(1+MOD(J-1,NPL2))-YPL1(I)).GT.EPSY).AND.
     -      (ABS(XPL2(1+MOD(J  ,NPL2))-XPL1(I)).GT.EPSX.OR.
     -       ABS(YPL2(1+MOD(J  ,NPL2))-YPL1(I)).GT.EPSY))IT(N1,1)=3
160    CONTINUE
*   Remember the starting point for the next list.
       M1=N1+1
*   Go over the line segments of the other polygon.
       DO 110 J=1,NPL2
*   Add vertices of 2 that are on this line.
       IF(ONLIND(XPL1(1+MOD(I-1,NPL1)),YPL1(1+MOD(I-1,NPL1)),
     -      XPL1(1+MOD(I,NPL1)),YPL1(1+MOD(I,NPL1)),
     -      XPL2(J),YPL2(J)).AND.
     -      (ABS(XPL1(1+MOD(I-1,NPL1))-XPL2(J)).GT.EPSX.OR.
     -       ABS(YPL1(1+MOD(I-1,NPL1))-YPL2(J)).GT.EPSY).AND.
     -      (ABS(XPL1(1+MOD(I  ,NPL1))-XPL2(J)).GT.EPSX.OR.
     -       ABS(YPL1(1+MOD(I  ,NPL1))-YPL2(J)).GT.EPSY))THEN
            IF(N1+1.GT.MXCORN)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -                ' points around a polygon ; list reduced.'
                 OK=.FALSE.
                 GOTO 150
            ENDIF
            N1=N1+1
            XL(N1,1)=XPL2(J)
            YL(N1,1)=YPL2(J)
            IT(N1,1)=2
       ENDIF
*   Add crossing points.
       CALL CRSPND(
     -      XPL1(1+MOD(I-1,NPL1)),YPL1(1+MOD(I-1,NPL1)),
     -      XPL1(1+MOD(I  ,NPL1)),YPL1(1+MOD(I  ,NPL1)),
     -      XPL2(1+MOD(J-1,NPL2)),YPL2(1+MOD(J-1,NPL2)),
     -      XPL2(1+MOD(J  ,NPL2)),YPL2(1+MOD(J  ,NPL2)),
     -      XC,YC,ADD)
       IF(ADD)THEN
            IF((ABS(XPL1(1+MOD(I-1,NPL1))-XC).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I-1,NPL1))-YC).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(I  ,NPL1))-XC).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I  ,NPL1))-YC).LT.EPSY))ADD=.FALSE.
            IF((ABS(XPL2(1+MOD(J-1,NPL2))-XC).LT.EPSX.AND.
     -          ABS(YPL2(1+MOD(J-1,NPL2))-YC).LT.EPSY).OR.
     -         (ABS(XPL2(1+MOD(J  ,NPL2))-XC).LT.EPSX.AND.
     -          ABS(YPL2(1+MOD(J  ,NPL2))-YC).LT.EPSY))ADD=.FALSE.
            IF((ABS(XPL1(1+MOD(I-1,NPL1))-
     -              XPL2(1+MOD(J-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I-1,NPL1))-
     -              YPL2(1+MOD(J-1,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(I-1,NPL1))-
     -              XPL2(1+MOD(J  ,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I-1,NPL1))-
     -              YPL2(1+MOD(J  ,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(I  ,NPL1))-
     -              XPL2(1+MOD(J-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I  ,NPL1))-
     -              YPL2(1+MOD(J-1,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(I-1,NPL1))-
     -              XPL2(1+MOD(J-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(I-1,NPL1))-
     -              YPL2(1+MOD(J-1,NPL2))).LT.EPSY))ADD=.FALSE.
       ENDIF
       IF(ADD)THEN
            IF(N1+1.GT.MXCORN)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -                ' points around a polygon ; list reduced.'
                 OK=.FALSE.
                 GOTO 150
            ENDIF
            N1=N1+1
            XL(N1,1)=XC
            YL(N1,1)=YC
            IT(N1,1)=3
       ENDIF
110    CONTINUE
*   Compute the lambda's for these points.
       DO 120 J=M1,N1
       CALL PLALAM(XPL1(1+MOD(I-1,NPL1)),XL(J,1),XPL1(1+MOD(I,NPL1)),
     -      YPL1(1+MOD(I-1,NPL1)),YL(J,1),YPL1(1+MOD(I,NPL1)),Q(J,1))
120    CONTINUE
*   Sort the list by using the lambda's.
       DO 140 J=M1,N1
       QMIN=Q(J,1)
       IQMIN=J
       DO 130 K=J+1,N1
       IF(Q(K,1).LT.QMIN)THEN
            IQMIN=K
            QMIN=Q(K,1)
       ENDIF
130    CONTINUE
       IF(J.NE.IQMIN)THEN
            XAUX=XL(J,1)
            YAUX=YL(J,1)
            QAUX=Q (J,1)
            IAUX=IT(J,1)
            XL(J,1)=XL(IQMIN,1)
            YL(J,1)=YL(IQMIN,1)
            Q (J,1)=Q (IQMIN,1)
            IT(J,1)=IT(IQMIN,1)
            XL(IQMIN,1)=XAUX
            YL(IQMIN,1)=YAUX
            Q (IQMIN,1)=QAUX
            IT(IQMIN,1)=IAUX
       ENDIF
140    CONTINUE
*   Next vertex.
100    CONTINUE
*** Establish the list of special points around polygon 2.
150    CONTINUE
       N2=0
       DO 200 I=1,NPL2
*   Add the vertex.
       IF(N2+1.GT.MXCORN)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -           ' points around a polygon ; list reduced.'
            OK=.FALSE.
            GOTO 250
       ENDIF
       N2=N2+1
       XL(N2,2)=XPL2(I)
       YL(N2,2)=YPL2(I)
       IT(N2,2)=1
       Q(N2,2)=0
*   If also on 1 or a vertex of 1, flag it as crossing or foreign.
       DO 260 J=1,NPL1
       IF(ABS(XPL1(J)-XPL2(I)).LT.EPSX.AND.
     -      ABS(YPL1(J)-YPL2(I)).LT.EPSY)IT(N2,2)=2
       IF(ONLIND(XPL1(1+MOD(J-1,NPL1)),YPL1(1+MOD(J-1,NPL1)),
     -           XPL1(1+MOD(J  ,NPL1)),YPL1(1+MOD(J  ,NPL1)),
     -           XPL2(I              ),YPL2(I)             ).AND.
     -      (ABS(XPL1(1+MOD(J-1,NPL1))-XPL2(I)).GT.EPSX.OR.
     -       ABS(YPL1(1+MOD(J-1,NPL1))-YPL2(I)).GT.EPSY).AND.
     -      (ABS(XPL1(1+MOD(J  ,NPL1))-XPL2(I)).GT.EPSX.OR.
     -       ABS(YPL1(1+MOD(J  ,NPL1))-YPL2(I)).GT.EPSY))IT(N2,2)=3
260    CONTINUE
*   Remember the starting point for the next list.
       M2=N2+1
*   Go over the line segments of the other polygon.
       DO 210 J=1,NPL1
*   Add vertices of 1 that are on this line.
       IF(ONLIND(XPL2(1+MOD(I-1,NPL2)),YPL2(1+MOD(I-1,NPL2)),
     -      XPL2(1+MOD(I,NPL2)),YPL2(1+MOD(I,NPL2)),
     -      XPL1(J),YPL1(J)).AND.
     -      (ABS(XPL2(1+MOD(I-1,NPL2))-XPL1(J)).GT.EPSX.OR.
     -       ABS(YPL2(1+MOD(I-1,NPL2))-YPL1(J)).GT.EPSY).AND.
     -      (ABS(XPL2(1+MOD(I  ,NPL2))-XPL1(J)).GT.EPSX.OR.
     -       ABS(YPL2(1+MOD(I  ,NPL2))-YPL1(J)).GT.EPSY))THEN
            IF(N2+1.GT.MXCORN)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -                ' points around a polygon ; list reduced.'
                 OK=.FALSE.
                 GOTO 250
            ENDIF
            N2=N2+1
            XL(N2,2)=XPL1(J)
            YL(N2,2)=YPL1(J)
            IT(N2,2)=2
       ENDIF
*   Add crossing points.
       CALL CRSPND(
     -      XPL2(1+MOD(I-1,NPL2)),YPL2(1+MOD(I-1,NPL2)),
     -      XPL2(1+MOD(I  ,NPL2)),YPL2(1+MOD(I  ,NPL2)),
     -      XPL1(1+MOD(J-1,NPL1)),YPL1(1+MOD(J-1,NPL1)),
     -      XPL1(1+MOD(J  ,NPL1)),YPL1(1+MOD(J  ,NPL1)),
     -      XC,YC,ADD)
       IF(ADD)THEN
            IF((ABS(XPL2(1+MOD(I-1,NPL2))-XC).LT.EPSX.AND.
     -           ABS(YPL2(1+MOD(I-1,NPL2))-YC).LT.EPSY).OR.
     -         (ABS(XPL2(1+MOD(I,NPL2))-XC).LT.EPSX.AND.
     -           ABS(YPL2(1+MOD(I,NPL2))-YC).LT.EPSY))ADD=.FALSE.
            IF((ABS(XPL1(1+MOD(J-1,NPL1))-XC).LT.EPSX.AND.
     -           ABS(YPL1(1+MOD(J-1,NPL1))-YC).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(J,NPL1))-XC).LT.EPSX.AND.
     -           ABS(YPL1(1+MOD(J,NPL1))-YC).LT.EPSY))ADD=.FALSE.
            IF((ABS(XPL1(1+MOD(J-1,NPL1))-
     -              XPL2(1+MOD(I-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(J-1,NPL1))-
     -              YPL2(1+MOD(I-1,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(J-1,NPL1))-
     -              XPL2(1+MOD(I  ,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(J-1,NPL1))-
     -              YPL2(1+MOD(I  ,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(J  ,NPL1))-
     -              XPL2(1+MOD(I-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(J  ,NPL1))-
     -              YPL2(1+MOD(I-1,NPL2))).LT.EPSY).OR.
     -         (ABS(XPL1(1+MOD(J-1,NPL1))-
     -              XPL2(1+MOD(I-1,NPL2))).LT.EPSX.AND.
     -          ABS(YPL1(1+MOD(J-1,NPL1))-
     -              YPL2(1+MOD(I-1,NPL2))).LT.EPSY))ADD=.FALSE.
       ENDIF
       IF(ADD)THEN
            IF(N2+1.GT.MXCORN)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : Too many special'//
     -                ' points around a polygon ; list reduced.'
                 OK=.FALSE.
                 GOTO 250
            ENDIF
            N2=N2+1
            XL(N2,2)=XC
            YL(N2,2)=YC
            IT(N2,2)=3
       ENDIF
210    CONTINUE
*   Compute the lambda's for these points.
       DO 220 J=M2,N2
       CALL PLALAM(XPL2(1+MOD(I-1,NPL2)),XL(J,2),XPL2(1+MOD(I,NPL2)),
     -      YPL2(1+MOD(I-1,NPL2)),YL(J,2),YPL2(1+MOD(I,NPL2)),Q(J,2))
220    CONTINUE
*   Sort the list by using the lambda's.
       DO 240 J=M2,N2
       QMIN=Q(J,2)
       IQMIN=J
       DO 230 K=J+1,N2
       IF(Q(K,2).LT.QMIN)THEN
            IQMIN=K
            QMIN=Q(K,2)
       ENDIF
230    CONTINUE
       IF(J.NE.IQMIN)THEN
            XAUX=XL(J,2)
            YAUX=YL(J,2)
            QAUX=Q (J,2)
            IAUX=IT(J,2)
            XL(J,2)=XL(IQMIN,2)
            YL(J,2)=YL(IQMIN,2)
            Q (J,2)=Q (IQMIN,2)
            IT(J,2)=IT(IQMIN,2)
            XL(IQMIN,2)=XAUX
            YL(IQMIN,2)=YAUX
            Q (IQMIN,2)=QAUX
            IT(IQMIN,2)=IAUX
       ENDIF
240    CONTINUE
*   Next vertex.
200    CONTINUE
*** Look up the cross-links: from plane 1 to plane 2.
       DO 300 I=1,N1
       IREF(I,1,1)=I
       NFOUND=0
       IREF(I,1,2)=0
       DO 310 J=1,N2
       IF(ABS(XL(I,1)-XL(J,2)).LT.EPSX.AND.
     -      ABS(YL(I,1)-YL(J,2)).LT.EPSY)THEN
            NFOUND=NFOUND+1
            IREF(I,1,2)=J
       ENDIF
310    CONTINUE
       IF(NFOUND.EQ.0.AND.(IT(I,1).EQ.2.OR.IT(I,1).EQ.3))THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Expected match not'//
     -           ' found (1-2)'
            IREF(I,1,2)=0
            OK=.FALSE.
       ELSEIF(NFOUND.GT.1)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : More than 1 match'//
     -           ' found (1-2).'
            IREF(I,1,2)=0
            OK=.FALSE.
       ENDIF
300    CONTINUE
**  Links from plane 2 to plane 1.
       DO 320 I=1,N2
       IREF(I,2,2)=I
       NFOUND=0
       IREF(I,2,1)=0
       DO 330 J=1,N1
       IF(ABS(XL(I,2)-XL(J,1)).LT.EPSX.AND.
     -      ABS(YL(I,2)-YL(J,1)).LT.EPSY)THEN
            NFOUND=NFOUND+1
            IREF(I,2,1)=J
       ENDIF
330    CONTINUE
       IF(NFOUND.EQ.0.AND.(IT(I,2).EQ.2.OR.IT(I,2).EQ.3))THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Expected match not'//
     -           ' found (2-1).'
            IREF(I,2,1)=0
            OK=.FALSE.
       ELSEIF(NFOUND.GT.1)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : More than 1 match'//
     -           ' found (2-1).'
            IREF(I,2,1)=0
            OK=.FALSE.
       ENDIF
320    CONTINUE
*   List the points for debugging.
       IF(LDEBUG)THEN
            DO 340 J=1,2
            WRITE(LUNOUT,'(''  ++++++ PLAOVL DEBUG   : Polygon '',I1,
     -           '':''/26X,''No Type            x            y'',
     -           ''         Q links'')') J
            CALL GSMK(2)
            IF(J.EQ.1)THEN
                 NP=N1
                 CALL GSMK(2)
            ELSEIF(J.EQ.2)THEN
                 NP=N2
                 CALL GSMK(4)
            ENDIF
            DO 350 I=1,NP
            WRITE(LUNOUT,'(25X,I3,I5,2F13.6,F10.3,2I3)') I,IT(I,J),
     -           XL(I,J),YL(I,J),Q(I,J),(IREF(I,J,K),K=1,2)
            CALL GPM2(1,XL(I,J),YL(I,J))
350         CONTINUE
340         CONTINUE
       ENDIF
       IF(.NOT.OK)RETURN
*** See whether all of 1 is inside 2.
       DO 1000 I=1,N1
       IF(IT(I,1).NE.1)GOTO 1200
       CALL INTERD(NPL2,XPL2,YPL2,XL(I,1),YL(I,1),INSIDE,EDGE)
       IF(.NOT.(INSIDE.OR.EDGE))GOTO 1200
1000   CONTINUE
**  Apparently 1 really is fully inside 2, write out curve 1.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Curve 1 fully inside 2'')')
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=3
            CALL PLABU2('STORE',IREFO(NREFO),NPL1,XPL1,YPL1,ZPL1,
     -           APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
            RETURN
       ENDIF
C       call gpl2(npl1,xpl1,ypl1)
*   Check there will be room for this.
       IF(NPL1+NPL2.GT.MXEDGE)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Output panel has too'//
     -           ' many vertices; abandoned.'
            RETURN
       ENDIF
*   Find 2 non-crossing connections: JP1-JP2 and KP1-KP2.
       FIRST=.TRUE.
       DO 1020 IP1=1,N1
       DO 1030 IP2=1,N2
       IF((.NOT.FIRST).AND.IP2.EQ.JP2)GOTO 1030
       DO 1040 K=1,N1
       IF(K.EQ.IP1.OR.1+MOD(K,N1).EQ.IP1)GOTO 1040
       CALL CRSPND(
     -      XL(IP1,1),        YL(IP1,1)        ,
     -      XL(IP2,2),        YL(IP2,2)        ,
     -      XL(K,1),          YL(K,1)          ,
     -      XL(1+MOD(K,N1),1),YL(1+MOD(K,N1),1),
     -      XC,YC,CROSS)
       IF(CROSS)GOTO 1030
1040   CONTINUE
       DO 1050 K=1,N2
       IF(K.EQ.IP2.OR.1+MOD(K,N2).EQ.IP2)GOTO 1050
       CALL CRSPND(
     -      XL(IP1,1),        YL(IP1,1)        ,
     -      XL(IP2,2),        YL(IP2,2)        ,
     -      XL(K,2),          YL(K,2)          ,
     -      XL(1+MOD(K,N2),2),YL(1+MOD(K,N2),2),
     -      XC,YC,CROSS)
       IF(CROSS)GOTO 1030
1050   CONTINUE
       IF(FIRST)THEN
            JP1=IP1
            JP2=IP2
            FIRST=.FALSE.
C            print *,' First junction: ',jp1,' (1) ',jp2,' (2)'
            GOTO 1020
       ELSE
            KP1=IP1
            KP2=IP2
            CALL CRSPND(
     -           XL(IP1,1), YL(IP1,1),
     -           XL(IP2,2), YL(IP2,2),
     -           XL(JP1,1), YL(JP1,1),
     -           XL(JP2,2), YL(JP2,2),
     -           XC,YC,CROSS)
            IF(.NOT.CROSS)GOTO 1060
       ENDIF            
1030   CONTINUE
1020   CONTINUE
       PRINT *,' !!!!!! PLAOVL WARNING : Found no cut-out.'
       RETURN
1060   CONTINUE
C       print *,' Second junction: ',kp1,' (1) ',kp2,' (2)'
**  Create part 1 of area 2.
       NPL=0
       DO 1070 IP1=JP1,KP1
       NPL=NPL+1
       XPL(NPL)=XL(IP1,1)
       YPL(NPL)=YL(IP1,1)
1070   CONTINUE
*   Try one way.
       IF(JP2.LT.KP2)THEN
            IMAX=JP2+N2
       ELSE
            IMAX=JP2
       ENDIF
       IDIR=+1
       DO 1080 I=KP2,IMAX
       IP2=1+MOD(I-1,N2)
       NPL=NPL+1
       XPL(NPL)=XL(IP2,2)
       YPL(NPL)=YL(IP2,2)
1080   CONTINUE
*   Check for undesirable crossings.
       DO 1090 IP1=1,N1
       IF(IP1.EQ.JP1.OR.IP1.EQ.KP1)GOTO 1090
       CALL INTERD(NPL,XPL,YPL,XL(IP1,1),YL(IP1,1),INSIDE,EDGE)
       IF(INSIDE)GOTO 1110
1090   CONTINUE
       GOTO 1120
*   Use the other way if this failed
1110   CONTINUE
       NPL=KP1-JP1+1
       IF(JP2.LT.KP2)THEN
            IMAX=KP2
       ELSE
            IMAX=KP2+N2
       ENDIF
       IDIR=-1
       DO 1130 I=IMAX,JP2,-1
       IP2=1+MOD(I-1,N2)
       NPL=NPL+1
       XPL(NPL)=XL(IP2,2)
       YPL(NPL)=YL(IP2,2)
1130   CONTINUE
1120   CONTINUE
*   Save this part.
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=2
            CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -           APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
       ENDIF
C       call gpl2(npl,xpl,ypl)
**  Create part 2 of area 2.
       NPL=0
       DO 1140 IP1=KP1,JP1+N1
       NPL=NPL+1
       XPL(NPL)=XL(1+MOD(IP1-1,N1),1)
       YPL(NPL)=YL(1+MOD(IP1-1,N1),1)
1140   CONTINUE
*   Add the part over area 2
       IF(IDIR.EQ.-1)THEN
            IF(JP2.GT.KP2)THEN
                 IMAX=JP2
            ELSE
                 IMAX=JP2+N2
            ENDIF
            IDIR=-1
            DO 1150 I=IMAX,KP2,-1
            IP2=1+MOD(I-1,N2)
            NPL=NPL+1
            XPL(NPL)=XL(IP2,2)
            YPL(NPL)=YL(IP2,2)
1150        CONTINUE
       ELSE
            IF(JP2.GT.KP2)THEN
                 IMAX=KP2+N2
            ELSE
                 IMAX=KP2
            ENDIF
            DO 1160 I=JP2,IMAX
            IP2=1+MOD(I-1,N2)
            NPL=NPL+1
            XPL(NPL)=XL(IP2,2)
            YPL(NPL)=YL(IP2,2)
1160        CONTINUE
       ENDIF
*   Save this part.
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=2
            CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -           APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
       ENDIF
C       call gpl2(npl,xpl,ypl)
       RETURN
*** See whether all of 2 is inside 1.
1200   CONTINUE
       DO 1210 I=1,N2
       IF(IT(I,2).NE.1)GOTO 1400
       CALL INTERD(NPL1,XPL1,YPL1,XL(I,2),YL(I,2),INSIDE,EDGE)
       IF(.NOT.(INSIDE.OR.EDGE))GOTO 1400
1210   CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Curve 2 inside 1'')')
**  Apparently 2 really is fully inside 1, write out curve 2.
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=3
            CALL PLABU2('STORE',IREFO(NREFO),NPL2,XPL2,YPL2,ZPL2,
     -           APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
       ENDIF
C       call gpl2(npl2,xpl2,ypl2)
*   Check there will be room for this.
       IF(NPL1+NPL2.GT.MXEDGE)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Output panel has too'//
     -           ' many vertices; abandoned.'
            RETURN
       ENDIF
*   Find 2 non-crossing connections: JP2-JP1 and KP2-KP1.
       FIRST=.TRUE.
       DO 1220 IP2=1,N2
       DO 1230 IP1=1,N1
       IF((.NOT.FIRST).AND.IP1.EQ.JP1)GOTO 1230
       DO 1240 K=1,N2
       IF(K.EQ.IP2.OR.1+MOD(K,N2).EQ.IP2)GOTO 1240
       CALL CRSPND(
     -      XL(IP2,2),        YL(IP2,2)        ,
     -      XL(IP1,1),        YL(IP1,1)        ,
     -      XL(K,2),          YL(K,2)          ,
     -      XL(1+MOD(K,N2),2),YL(1+MOD(K,N2),2),
     -      XC,YC,CROSS)
       IF(CROSS)GOTO 1230
1240   CONTINUE
C       print *,' no crossing with 2'
       DO 1250 K=1,N1
       IF(K.EQ.IP1.OR.1+MOD(K,N1).EQ.IP1)GOTO 1250
       CALL CRSPND(
     -      XL(IP2,2),        YL(IP2,2)        ,
     -      XL(IP1,1),        YL(IP1,1)        ,
     -      XL(K,1),          YL(K,1)          ,
     -      XL(1+MOD(K,N1),1),YL(1+MOD(K,N1),1),
     -      XC,YC,CROSS)
       IF(CROSS)GOTO 1230
1250   CONTINUE
       IF(FIRST)THEN
            JP2=IP2
            JP1=IP1
            FIRST=.FALSE.
C            print *,' First junction: ',jp2,' (2) ',jp1,' (1)'
            GOTO 1220
       ELSE
            KP2=IP2
            KP1=IP1
            CALL CRSPND(
     -           XL(IP2,2), YL(IP2,2),
     -           XL(IP1,1), YL(IP1,1),
     -           XL(JP2,2), YL(JP2,2),
     -           XL(JP1,1), YL(JP1,1),
     -           XC,YC,CROSS)
            IF(.NOT.CROSS)GOTO 1260
       ENDIF            
1230   CONTINUE
1220   CONTINUE
       PRINT *,' !!!!!! PLAOVL WARNING : Found no cut-out.'
       RETURN
1260   CONTINUE
C       print *,' Second junction: ',kp2,' (2) ',kp1,' (1)'
**  Create part 1 of area 1.
       NPL=0
       DO 1270 IP2=JP2,KP2
       NPL=NPL+1
       XPL(NPL)=XL(IP2,2)
       YPL(NPL)=YL(IP2,2)
1270   CONTINUE
*   Try one way.
       IF(JP1.LT.KP1)THEN
            IMAX=JP1+N1
       ELSE
            IMAX=JP1
       ENDIF
       IDIR=+1
       DO 1280 I=KP1,IMAX
       IP1=1+MOD(I-1,N1)
       NPL=NPL+1
       XPL(NPL)=XL(IP1,1)
       YPL(NPL)=YL(IP1,1)
1280   CONTINUE
*   Check for undesirable crossings.
       DO 1290 IP2=1,N2
       IF(IP2.EQ.JP2.OR.IP2.EQ.KP2)GOTO 1290
       CALL INTERD(NPL,XPL,YPL,XL(IP2,2),YL(IP2,2),INSIDE,EDGE)
       IF(INSIDE)GOTO 1310
1290   CONTINUE
       GOTO 1320
*   Use the other way if this failed
1310   CONTINUE
       NPL=KP2-JP2+1
       IF(JP1.LT.KP1)THEN
            IMAX=KP1
       ELSE
            IMAX=KP1+N1
       ENDIF
       IDIR=-1
       DO 1330 I=IMAX,JP1,-1
       IP1=1+MOD(I-1,N1)
       NPL=NPL+1
       XPL(NPL)=XL(IP1,1)
       YPL(NPL)=YL(IP1,1)
1330   CONTINUE
1320   CONTINUE
*   Save this part.
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=1
            CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -           APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
       ENDIF
C       call gpl2(npl,xpl,ypl)
**  Create part 2 of area 1.
       NPL=0
       DO 1340 IP2=KP2,JP2+N2
       NPL=NPL+1
       XPL(NPL)=XL(1+MOD(IP2-1,N2),2)
       YPL(NPL)=YL(1+MOD(IP2-1,N2),2)
1340   CONTINUE
*   Add the part over area 1
       IF(IDIR.EQ.-1)THEN
            IF(JP1.GT.KP1)THEN
                 IMAX=JP1
            ELSE
                 IMAX=JP1+N1
            ENDIF
            IDIR=-1
            DO 1350 I=IMAX,KP1,-1
            IP1=1+MOD(I-1,N1)
            NPL=NPL+1
            XPL(NPL)=XL(IP1,1)
            YPL(NPL)=YL(IP1,1)
1350        CONTINUE
       ELSE
            IF(JP1.GT.KP1)THEN
                 IMAX=KP1+N1
            ELSE
                 IMAX=KP1
            ENDIF
            DO 1360 I=JP1,IMAX
            IP1=1+MOD(I-1,N1)
            NPL=NPL+1
            XPL(NPL)=XL(IP1,1)
            YPL(NPL)=YL(IP1,1)
1360        CONTINUE
       ENDIF
*   Save this part.
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            ITYPO(NREFO)=1
            CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -           APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                ' too long.'
       ENDIF
C       call gpl2(npl,xpl,ypl)
       RETURN
1400   CONTINUE
*** Identify the parts of 1 that are not overlapped, first mark.
       DO 400 I=1,MXEDGE
       MARK1(I)=.FALSE.
       MARK2(I)=.FALSE.
400    CONTINUE
**  Try and find a new starting point
430    CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Starting search for'',
     -      '' starting point on 1'')')
       DO 410 I=1,N1
*   Skip parts already processed.
       IF(MARK1(I).OR.MARK1(1+MOD(I,N1)))GOTO 410
*   Skip if mid point is inside other volume.
       CALL INTERD(NPL2,XPL2,YPL2,
     -      (XL(I,1)+XL(1+MOD(I,N1),1))/2,
     -      (YL(I,1)+YL(1+MOD(I,N1),1))/2,
     -      INSIDE,EDGE)
       IF(INSIDE.OR.EDGE)GOTO 410
*   Found one.
       IP1=I
       XPL(1)=XL(IP1,1)
       YPL(1)=YL(IP1,1)
       IS1=IP1
       MARK1(IP1)=.TRUE.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Start from point '',I5,
     -       '' on curve 1.'')') IP1
       IP1=1+MOD(IP1,N1)
       XPL(2)=XL(IP1,1)
       YPL(2)=YL(IP1,1)
       MARK1(IP1)=.TRUE.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Next point is '',I5,
     -      '' on 1.'')') IP1
       NPL=2
       IL=1
       IDIR=0
       GOTO 420
410    CONTINUE
*   Finished
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''No further non-overlapped'',
     -      '' areas of 1.'')')
       GOTO 500
*   Trace this part of 1 outside 2
420    CONTINUE
       IF(NPL+1.GT.MXEDGE)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Too many vertices on 1.'
            RETURN
*   On curve 1 and not on the edge of curve 2 ?
       ELSEIF(IL.EQ.1.AND.IT(MAX(1,IP1),IL).EQ.1)THEN
            IP1=1+MOD(IP1,N1)
            IF(IP1.EQ.IS1)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=1
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points'')') NPL
                 GOTO 430
            ENDIF
            MARK1(IP1)=.TRUE.
            NPL=NPL+1
            XPL(NPL)=XL(IP1,IL)
            YPL(NPL)=YL(IP1,IL)
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Went to point '',I5,
     -           '' on curve 1.'')') IP1
*   On curve 1 and on the edge of curve 2 ?
       ELSEIF(IL.EQ.1)THEN
            IP2=IREF(IP1,1,2)
            ADDED=.FALSE.
            IF(IDIR.EQ.+1.OR.IDIR.EQ.0)THEN
                 CALL INTERD(NPL1,XPL1,YPL1,
     -                (XL(IP2,2)+XL(1+MOD(IP2,N2),2))/2,
     -                (YL(IP2,2)+YL(1+MOD(IP2,N2),2))/2,
     -                INSIDE,EDGE)
                 IF(INSIDE)THEN
                      IP2=1+MOD(IP2,N2)
                      IL=2
                      IDIR=+1
                      IP1=IREF(IP2,2,1)
                      IF(IP1.EQ.IS1)THEN
                           IF(NREFO+1.LE.MXPLAN)THEN
                                NREFO=NREFO+1
                                ITYPO(NREFO)=1
                                CALL PLABU2('STORE',IREFO(NREFO),
     -                               NPL,XPL,YPL,ZPL,
     -                               APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                           ELSE
                                PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                               ' Output list too long.'
                           ENDIF
C                           call gpl2(npl,xpl,ypl)
                           IF(LDEBUG)WRITE(LUNOUT,'(26X,''End'',
     -                          '' reached, '',I5,'' points.'')') NPL
                           GOTO 430
                      ELSEIF(IP1.NE.0)THEN
                           MARK1(IP1)=.TRUE.
                      ENDIF
                      NPL=NPL+1
                      XPL(NPL)=XL(IP2,2)
                      YPL(NPL)=YL(IP2,2)
                      ADDED=.TRUE.
C                      print *,' Added point ',ip2,' along 2 +'
                 ENDIF
            ENDIF
            IF(IDIR.EQ.-1.OR.IDIR.EQ.0)THEN
                 CALL INTERD(NPL1,XPL1,YPL1,
     -                (XL(IP2,2)+XL(1+MOD(IP2+N2-2,N2),2))/2,
     -                (YL(IP2,2)+YL(1+MOD(IP2+N2-2,N2),2))/2,
     -                INSIDE,EDGE)
                 IF(INSIDE)THEN
                      IP2=1+MOD(IP2+N2-2,N2)
                      IL=2
                      IDIR=-1
                      IP1=IREF(IP2,2,1)
                      IF(IP1.EQ.IS1)THEN
                           IF(NREFO+1.LE.MXPLAN)THEN
                                NREFO=NREFO+1
                                ITYPO(NREFO)=1
                                CALL PLABU2('STORE',IREFO(NREFO),
     -                               NPL,XPL,YPL,ZPL,
     -                               APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                           ELSE
                                PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                               ' Output list too long.'
                           ENDIF
C                           call gpl2(npl,xpl,ypl)
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                     '' reached, '',I5,'' points.'')') NPL
                           GOTO 430
                      ELSEIF(IP1.NE.0)THEN
                           MARK1(IP1)=.TRUE.
                      ENDIF
                      NPL=NPL+1
                      XPL(NPL)=XL(IP2,2)
                      YPL(NPL)=YL(IP2,2)
                      ADDED=.TRUE.
C                      print *,' Added point ',ip2,' along 2 -'
                 ENDIF
            ENDIF
            IF(.NOT.ADDED)THEN
                 IP1=1+MOD(IP1,N1)
                 IF(IP1.EQ.IS1)THEN
                      IF(NREFO+1.LE.MXPLAN)THEN
                           NREFO=NREFO+1
                           ITYPO(NREFO)=1
                           CALL PLABU2('STORE',IREFO(NREFO),
     -                          NPL,XPL,YPL,ZPL,
     -                          APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                      ELSE
                           PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                          ' Output list too long.'
                      ENDIF
C                      call gpl2(npl,xpl,ypl)
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                     '' reached, '',I5,'' points.'')') NPL
                      GOTO 430
                 ELSEIF(IP1.NE.0)THEN
                      MARK1(IP1)=.TRUE.
                 ENDIF
                 NPL=NPL+1
                 XPL(NPL)=XL(IP1,IL)
                 YPL(NPL)=YL(IP1,IL)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''Continued over 1'')')
            ENDIF
*   On curve 2 normal vertex (outside 1 hopefully).
       ELSEIF(IL.EQ.2.AND.IT(MAX(1,IP2),2).EQ.1)THEN
            IP2=1+MOD(IP2+IDIR-1+N2,N2)
            IP1=IREF(IP2,2,1)
            IF(IP1.EQ.IS1)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=1
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 430
            ELSEIF(IP1.NE.0)THEN
                 MARK1(IP1)=.TRUE.
            ENDIF
            NPL=NPL+1
            XPL(NPL)=XL(IP2,IL)
            YPL(NPL)=YL(IP2,IL)
C            print *,' Went to point ',ip2,' on 2.'
*   On curve 2 and on edge of 1
       ELSEIF(IL.EQ.2)THEN
            IP1=IREF(IP2,2,1)
            IP1=1+MOD(IP1,N1)
            IL=1
            IF(IP1.EQ.IS1)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=1
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 430
            ENDIF
            NPL=NPL+1
            XPL(NPL)=XL(IP1,IL)
            YPL(NPL)=YL(IP1,IL)
C            print *,' Resumed 1 at point ',ip1
*   Other cases should not occur
       ELSE
            PRINT *,' !!!!!! PLAOVL : Unexpected case.'
       ENDIF
       GOTO 420
*** Same for curve 2.
500    CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Starting search for'',
     -      '' starting point on 2'')')
       DO 510 I=1,N2
*   Skip parts already processed.
       IF(MARK2(I).OR.MARK2(1+MOD(I,N2)))GOTO 510
*   Skip if mid point is inside other volume.
       CALL INTERD(NPL1,XPL1,YPL1,
     -      (XL(I,2)+XL(1+MOD(I,N2),2))/2,
     -      (YL(I,2)+YL(1+MOD(I,N2),2))/2,
     -      INSIDE,EDGE)
       IF(INSIDE.OR.EDGE)GOTO 510
*   Found one.
       IP2=I
       XPL(1)=XL(IP2,2)
       YPL(1)=YL(IP2,2)
       IS2=IP2
       MARK2(IP2)=.TRUE.
C       print *,' Start from point ',ip2,' on 2.'
       IP2=1+MOD(IP2,N2)
       XPL(2)=XL(IP2,2)
       YPL(2)=YL(IP2,2)
       MARK2(IP2)=.TRUE.
C       print *,' Next point is ',ip2,' on 2.'
       NPL=2
       IL=2
       IDIR=0
       GOTO 520
510    CONTINUE
*   Finished
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''No further non-overlapped'',
     -      '' areas of 2.'')')
       GOTO 600
*   Trace this part of 2 outside 1
520    CONTINUE
       IF(NPL+1.GT.MXEDGE)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Too many vertices on 2.'
            RETURN
*   On curve 2 and not on the edge of curve 1 ?
       ELSEIF(IL.EQ.2.AND.IT(MAX(1,IP2),IL).EQ.1)THEN
            IP2=1+MOD(IP2,N2)
            IF(IP2.EQ.IS2)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=2
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 500
            ENDIF
            MARK2(IP2)=.TRUE.
            NPL=NPL+1
            XPL(NPL)=XL(IP2,IL)
            YPL(NPL)=YL(IP2,IL)
C            print *,' Went to point ',ip2,' on 2.'
*   On curve 2 and on the edge of curve 1 ?
       ELSEIF(IL.EQ.2)THEN
            IP1=IREF(IP2,2,1)
            ADDED=.FALSE.
            IF(IDIR.EQ.+1.OR.IDIR.EQ.0)THEN
                 CALL INTERD(NPL2,XPL2,YPL2,
     -                (XL(IP1,1)+XL(1+MOD(IP1,N1),1))/2,
     -                (YL(IP1,1)+YL(1+MOD(IP1,N1),1))/2,
     -                INSIDE,EDGE)
                 IF(INSIDE)THEN
                      IP1=1+MOD(IP1,N1)
                      IL=1
                      IDIR=+1
                      IP2=IREF(IP1,1,2)
                      IF(IP2.EQ.IS2)THEN
                           IF(NREFO+1.LE.MXPLAN)THEN
                                NREFO=NREFO+1
                                ITYPO(NREFO)=2
                                CALL PLABU2('STORE',IREFO(NREFO),
     -                               NPL,XPL,YPL,ZPL,
     -                               APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                           ELSE
                                PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                               ' Output list too long.'
                           ENDIF
C                           call gpl2(npl,xpl,ypl)
C                           print *,' End reached, ',npl,' points'
                           GOTO 500
                      ELSEIF(IP2.NE.0)THEN
                           MARK2(IP2)=.TRUE.
                      ENDIF
                      NPL=NPL+1
                      XPL(NPL)=XL(IP1,1)
                      YPL(NPL)=YL(IP1,1)
                      ADDED=.TRUE.
C                      print *,' Added point ',ip1,' along 1 +'
                 ENDIF
            ENDIF
            IF(IDIR.EQ.-1.OR.IDIR.EQ.0)THEN
                 CALL INTERD(NPL2,XPL2,YPL2,
     -                (XL(IP1,1)+XL(1+MOD(IP1+N1-2,N1),1))/2,
     -                (YL(IP1,1)+YL(1+MOD(IP1+N1-2,N1),1))/2,
     -                INSIDE,EDGE)
                 IF(INSIDE)THEN
                      IP1=1+MOD(IP1+N1-2,N1)
                      IL=1
                      IDIR=-1
                      IP2=IREF(IP1,1,2)
                      IF(IP2.EQ.IS2)THEN
                           IF(NREFO+1.LE.MXPLAN)THEN
                                NREFO=NREFO+1
                                ITYPO(NREFO)=2
                                CALL PLABU2('STORE',IREFO(NREFO),
     -                               NPL,XPL,YPL,ZPL,
     -                               APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                           ELSE
                                PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                               ' Output list too long.'
                           ENDIF
C                           call gpl2(npl,xpl,ypl)
C                           print *,' End reached, ',npl,' points'
                           GOTO 500
                      ELSEIF(IP2.NE.0)THEN
                           MARK2(IP2)=.TRUE.
                      ENDIF
                      NPL=NPL+1
                      XPL(NPL)=XL(IP1,1)
                      YPL(NPL)=YL(IP1,1)
                      ADDED=.TRUE.
C                      print *,' Added point ',ip1,' along 1 -'
                 ENDIF
            ENDIF
            IF(.NOT.ADDED)THEN
                 IP2=1+MOD(IP2,N2)
                 IF(IP2.EQ.IS2)THEN
                      IF(NREFO+1.LE.MXPLAN)THEN
                           NREFO=NREFO+1
                           ITYPO(NREFO)=2
                           CALL PLABU2('STORE',IREFO(NREFO),
     -                          NPL,XPL,YPL,ZPL,
     -                          APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                      ELSE
                           PRINT *,' !!!!!! PLAOVL WARNING :'//
     -                          ' Output list too long.'
                      ENDIF
C                      call gpl2(npl,xpl,ypl)
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                     '' reached, '',I5,'' points.'')') NPL
                      GOTO 500
                 ELSEIF(IP2.NE.0)THEN
                      MARK2(IP2)=.TRUE.
                 ENDIF
                 NPL=NPL+1
                 XPL(NPL)=XL(IP2,IL)
                 YPL(NPL)=YL(IP2,IL)
C                 print *,' Continued over 2'
            ENDIF
*   On curve 1 normal vertex (outside 2 hopefully).
       ELSEIF(IL.EQ.1.AND.IT(MAX(1,IP1),1).EQ.1)THEN
            IP1=1+MOD(IP1+IDIR-1+N1,N1)
            IP2=IREF(IP1,1,2)
            IF(IP2.EQ.IS2)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=2
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 500
            ELSEIF(IP2.NE.0)THEN
                 MARK2(IP2)=.TRUE.
            ENDIF
            NPL=NPL+1
            XPL(NPL)=XL(IP1,IL)
            YPL(NPL)=YL(IP1,IL)
C            print *,' Went to point ',ip1,' on 1.'
*   On curve 1 and on edge of 2
       ELSEIF(IL.EQ.1)THEN
            IP2=IREF(IP1,1,2)
            IP2=1+MOD(IP2,N2)
            IL=2
            IF(IP2.EQ.IS2)THEN
                 IF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=2
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL2,BPL2,CPL2,DPL2,ICOL2,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                     ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 500
            ENDIF
            NPL=NPL+1
            XPL(NPL)=XL(IP2,IL)
            YPL(NPL)=YL(IP2,IL)
C            print *,' Resumed 1 at point ',ip2
*   Other cases should not occur
       ELSE
            PRINT *,' !!!!!! PLAOVL : Unexpected case.'
       ENDIF
       GOTO 520
*** Reset the flags.
600    CONTINUE
       DO 640 I=1,N1
       MARK1(I)=.FALSE.
640    CONTINUE
*** Look for the overlapped parts.
630    CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Starting search for'',
     -      '' starting point on overlap.'')')
       DO 610 I=1,N1
*   Skip points already processed.
       IF(MARK1(I))GOTO 610
*   Skip if not an edge point on both 1 and 2 or internal in 2.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''ip1 = '',2I5,'' ip2 = '',
     -       2I5)') I,IT(I,1),IREF(I,1,2),IT(MAX(1,IREF(I,1,2)),2)
       IP1=I
       IP2=IREF(IP1,1,2)
       IF(IP2.EQ.0.OR.IT(IP1,1).EQ.1)THEN
            CALL INTERD(NPL2,XPL2,YPL2,XL(IP1,1),YL(IP1,1),
     -           INSIDE,EDGE)
            IF(.NOT.(INSIDE.OR.EDGE))GOTO 610
       ELSEIF(IT(IP2,2).EQ.1)THEN
            GOTO 610
       ENDIF
*   Found one.
       NPL=1
       XPL(1)=XL(IP1,1)
       YPL(1)=YL(IP1,1)
       IS1=IP1
       IS2=IP2
       IL=1
       IDIR=0
       MARK1(IP1)=.TRUE.
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Start from point '',I5,
     -      '' on curve '',I5)') IP1,IL
       GOTO 620
610    CONTINUE
*   Finished
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''No further overlapped areas.'')')
       GOTO 700
*   Trace this overlapped part.
       IP1L=-1
       IP1LL=-1
620    CONTINUE
       IP1LL=IP1L
       IP1L=IP1
**  Is there still room ?
       IF(NPL+1.GT.MXEDGE)THEN
            PRINT *,' !!!!!! PLAOVL WARNING : Too many vertices in'//
     -           ' overlapped part.'
            RETURN
**  On curve 1, see which way to continue.
       ELSEIF(IL.EQ.1)THEN
*   Maybe finished over line 1 ?
            IF(1+MOD(IP1,N1).EQ.IS1)THEN
                 IF(NPL.LE.2)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''Too few points'')')
                 ELSEIF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=3
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                    ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 630
            ENDIF 
*   See whether the next point of 1 is on the edge or inside of 2.
            INSIDE=.FALSE.
            EDGE=.FALSE.
            IF(IREF(1+MOD(IP1,N1),1,2).GT.0)THEN
                 EDGE=.TRUE.
            ELSEIF(IT(1+MOD(IP1,N1),1).EQ.1)THEN
                 CALL INTERD(NPL2,XPL2,YPL2,
     -                XL(1+MOD(IP1,N1),1),YL(1+MOD(IP1,N1),1),
     -                INSIDE,EDGE)
            ENDIF
*   If it is, check that it doesn't leave 2 at any stage.
            IF(INSIDE.OR.EDGE)CALL INTERD(NPL2,XPL2,YPL2,
     -           0.5*(XL(IP1,1)+XL(1+MOD(IP1,N1),1)),
     -           0.5*(YL(IP1,1)+YL(1+MOD(IP1,N1),1)),
     -           INSIDE,EDGE)
*   If it is, continue over 1.
            IF(INSIDE.OR.EDGE)THEN
                 IP1=1+MOD(IP1,N1)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''Continued to point '',
     -                I5,'' on '',I5)') IP1,IL
                 NPL=NPL+1
                 XPL(NPL)=XL(IP1,1)
                 YPL(NPL)=YL(IP1,1)
                 MARK1(IP1)=.TRUE.
                 GOTO 620
            ENDIF
*   Else we have to continue over 2, ensure we really are on curve 2.
            IP2=IREF(IP1,1,2)
            IF(IP2.EQ.0)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : No point 2'//
     -                ' reference found; abandoned.'
                 RETURN
            ENDIF
*   Impose a direction on 2 to avoid returning.
            IF(IDIR.EQ.0)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''Checking directions'',
     -                '' at point '',I5,'' of curve 2.''/26X,
     -                ''2+ ref on 1: '',I5,'', 2- ref on 1: '',I5)')
     -                IP2,IREF(1+MOD(IP2,N2),2,1),
     -                IREF(1+MOD(IP2-2+N2,N2),2,1)
                 IF(IREF(1+MOD(IP2,N2),2,1).EQ.IP1LL.AND.
     -              IREF(1+MOD(IP2-2+N2,N2),2,1).EQ.IP1LL)THEN
                      PRINT *,' !!!!!! PLAOVL WARNING : Both 2+'//
     -                     ' and 2- return on 1; not stored.'
                      GOTO 630
                 ELSEIF(IREF(1+MOD(IP2,N2),2,1).EQ.IP1LL)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''2+ is a return'',
     -                     '' to previous point on 1.'')')
                      IDIR=-1
                 ELSEIF(IREF(1+MOD(IP2-2+N2,N2),2,1).EQ.IP1LL)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''2- is a return'',
     -                     '' to previous point on 1.'')')
                      IDIR=+1
                 ELSE
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''Both ways are OK.'')')
                 ENDIF
            ENDIF
*   If not, try to continue over 2 in the + direction..
            IF(IDIR.EQ.+1.OR.IDIR.EQ.0)THEN
                 IP2=1+MOD(IP2,N2)
                 IF(IP2.EQ.IS2)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,
     -                     ''Return to start over 2+'')')
                      IF(NPL.LE.2)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(26X,
     -                          ''Too few points'')')
                      ELSEIF(NREFO+1.LE.MXPLAN)THEN
                           NREFO=NREFO+1
                           ITYPO(NREFO)=3
                           CALL PLABU2('STORE',IREFO(NREFO),
     -                          NPL,XPL,YPL,ZPL,
     -                          APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                      ELSE
                           PRINT *,' !!!!!! PLAOVL WARNING : Output'//
     -                         ' list too long.'
                      ENDIF
                      GOTO 630
                 ENDIF
                 CALL INTERD(NPL1,XPL1,YPL1,XL(IP2,2),YL(IP2,2),
     -                INSIDE,EDGE)
                 IF(INSIDE.OR.EDGE)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''Going to 2+'',
     -                     '' (point '',I5,'' of 2)'')') IP2
                      NPL=NPL+1
                      XPL(NPL)=XL(IP2,2)
                      YPL(NPL)=YL(IP2,2)
                      IDIR=+1
                      IF(IREF(IP2,2,1).NE.0)THEN
                           IP1=IREF(IP2,2,1)
                           MARK1(IP1)=.TRUE.
                           IL=1
                           IF(LDEBUG)WRITE(LUNOUT,'(26X,''This point'',
     -                          '' is also on curve 1: '',I5)') IP1
                      ELSE
                           IL=2
                      ENDIF
                      GOTO 620
                 ENDIF
                 IP2=1+MOD(IP2-2+N2,N2)
            ENDIF
*   Or if this still fails, try 2 in the - direction..
            IF(IDIR.EQ.-1.OR.IDIR.EQ.0)THEN
                 IP2=1+MOD(IP2-2+N2,N2)
                 IF(IP2.EQ.IS2)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,
     -                     ''Return to start over 2-'')')
                      IF(NPL.LE.2)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(26X,
     -                          ''Too few points'')')
                      ELSEIF(NREFO+1.LE.MXPLAN)THEN
                           NREFO=NREFO+1
                           ITYPO(NREFO)=3
                           CALL PLABU2('STORE',IREFO(NREFO),
     -                          NPL,XPL,YPL,ZPL,
     -                          APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                      ELSE
                           PRINT *,' !!!!!! PLAOVL WARNING : Output'//
     -                         ' list too long.'
                      ENDIF
                      GOTO 630
                 ENDIF
                 CALL INTERD(NPL1,XPL1,YPL1,XL(IP2,2),YL(IP2,2),
     -                INSIDE,EDGE)
                 IF(INSIDE.OR.EDGE)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''Going to 2-'',
     -                     '' (point '',I5,'' of 2)'')') IP2
                      NPL=NPL+1
                      XPL(NPL)=XL(IP2,2)
                      YPL(NPL)=YL(IP2,2)
                      IDIR=-1
                      IF(IREF(IP2,2,1).NE.0)THEN
                           IP1=IREF(IP2,2,1)
                           MARK1(IP1)=.TRUE.
                           IL=1
                           IF(LDEBUG)WRITE(LUNOUT,'(26X,''This point'',
     -                          '' is also on 1: '',I5)') IP1
                      ELSE
                           IL=2
                      ENDIF
                      GOTO 620
                 ENDIF
             ENDIF
*   Should not get here
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Dead end.'')')
            GOTO 630
**  If we are on curve 2
       ELSEIF(IL.EQ.2)THEN
*   Ensure the direction is set
            IF(IDIR.EQ.0)THEN
                 PRINT *,' !!!!!! PLAOVL WARNING : Direction not'//
     -                    ' set; abandoned.'
                 RETURN
            ENDIF
*   Maybe finished over line 2 ?
            IP2=1+MOD(IP2+IDIR-1+N2,N2)
            IF(IP2.EQ.IS2)THEN
                 IF(NPL.LE.2)THEN
                      IF(LDEBUG)WRITE(LUNOUT,'(26X,''Too few points'')')
                 ELSEIF(NREFO+1.LE.MXPLAN)THEN
                      NREFO=NREFO+1
                      ITYPO(NREFO)=3
                      CALL PLABU2('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                     APL1,BPL1,CPL1,DPL1,ICOL1,IFAIL1)
                 ELSE
                      PRINT *,' !!!!!! PLAOVL WARNING : Output list'//
     -                    ' too long.'
                 ENDIF
C                 call gpl2(npl,xpl,ypl)
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''End of curve'',
     -                '' reached, '',I5,'' points.'')') NPL
                 GOTO 630
            ENDIF
*   Next step over 2.
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Stepped over 2 to point '',
     -           I5,'' of 2.'')') IP2
            NPL=NPL+1
            XPL(NPL)=XL(IP2,2)
            YPL(NPL)=YL(IP2,2)
            IF(IREF(IP2,2,1).NE.0)THEN
                 IP1=IREF(IP2,2,1)
                 MARK1(IP1)=.TRUE.
                 IL=1
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''This point is also'',
     -                '' on curve 1: '',I5)') IP1
            ELSE
                 IL=2
            ENDIF
            GOTO 620
       ENDIF
700    CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAOVL DEBUG   : Ready'',
     -      '' - no errors.'')')
*** Seems to have worked.
       IFAIL=0
       RETURN
*** Error.
250    CONTINUE
       PRINT *,' !!!!!! PLAOVL WARNING : Abandoning after error. '
       IFAIL=1
       END
CDECK  ID>, PLAEQU.
       SUBROUTINE PLAEQU(IREF1,IREF2,EPSX,EPSY,EQUAL)
*-----------------------------------------------------------------------
*   PLAEQU - Determines whether 2 planes are equal.
*   (Last changed on  8/ 5/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       LOGICAL EQUAL,ONLIND
       INTEGER IREF1,IREF2,NPL1,NPL2,ICOL1,IFAIL1,ICOL2,IFAIL2,I,J
       DOUBLE PRECISION EPSX,EPSY,
     -      XPL1(MXEDGE),YPL1(MXEDGE),ZPL1(MXEDGE),APL1,BPL1,CPL1,DPL1,
     -      XPL2(MXEDGE),YPL2(MXEDGE),ZPL2(MXEDGE),APL2,BPL2,CPL2,DPL2
       EXTERNAL ONLIND
*** Initial value.
       EQUAL=.FALSE.
*** Retrieve both planes.
       CALL PLABU2('READ',IREF1,NPL1,XPL1,YPL1,ZPL1,APL1,BPL1,CPL1,DPL1,
     -      ICOL1,IFAIL1)
       CALL PLABU2('READ',IREF2,NPL2,XPL2,YPL2,ZPL2,APL2,BPL2,CPL2,DPL2,
     -      ICOL2,IFAIL2)
       IF(IFAIL1.NE.0.OR.IFAIL2.NE.0)THEN
            PRINT *,' !!!!!! PLAEQU WARNING : Unable to retrieve a'//
     -           ' projected polygon; declared not equal.'
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEQU DEBUG   :''//
     -           '' Reference numbers: '',2I4)') IREF1,IREF2
            EQUAL=.FALSE.
            RETURN
       ENDIF
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ PLAEQU DEBUG   : Curve 1'',
     -           '' has '',I5,'' points.'')') NPL1
            DO 50 I=1,NPL1
            WRITE(LUNOUT,'(2X,I3,F13.6,2X,F13.6)') I,XPL1(I),YPL1(I)
50          CONTINUE
            WRITE(LUNOUT,'(''                          Curve 2'',
     -           '' has '',I5,'' points.'')') NPL2
            DO 60 I=1,NPL2
            WRITE(LUNOUT,'(2X,I3,F13.6,2X,F13.6)') I,XPL2(I),YPL2(I)
60          CONTINUE
       ENDIF
*** If 0 length, simply return.
       IF(NPL1.LE.0.OR.NPL2.LE.0)THEN
            EQUAL=.FALSE.
            RETURN
       ENDIF
*** Compare all points of 1 with all points of 2.
       DO 10 I=1,NPL1
*   Loop over 2 until a match is found.
       DO 20 J=1,NPL2
       IF(ABS(XPL2(J)-XPL1(I)).LT.EPSX.AND.
     -    ABS(YPL2(J)-YPL1(I)).LT.EPSY)GOTO 10
       IF(ONLIND(XPL2(1+MOD(J-1,NPL2)),YPL2(1+MOD(J-1,NPL2)),
     -           XPL2(1+MOD(J  ,NPL2)),YPL2(1+MOD(J  ,NPL2)),
     -           XPL1(I              ),YPL1(I)             ))GOTO 10
20     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEQU DEBUG   :'',
     -      '' No match on 2 for point '',I5,'' of 1.'')') I
       EQUAL=.FALSE.
       RETURN
10     CONTINUE
*** Compare all points of 2 with all points of 1.
       DO 30 I=1,NPL2
*   Loop over 2 until a match is found.
       DO 40 J=1,NPL1
       IF(ABS(XPL2(J)-XPL1(I)).LT.EPSX.AND.
     -    ABS(YPL2(J)-YPL1(I)).LT.EPSY)GOTO 30
       IF(ONLIND(XPL1(1+MOD(J-1,NPL1)),YPL1(1+MOD(J-1,NPL1)),
     -           XPL1(1+MOD(J  ,NPL1)),YPL1(1+MOD(J  ,NPL1)),
     -           XPL2(I              ),YPL2(I)             ))GOTO 30
40     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEQU DEBUG   :'',
     -      '' No match on 1 for point '',I5,'' of 2.'')') I
       EQUAL=.FALSE.
       RETURN
30     CONTINUE
*** If we get this far, the curves are the same.
       EQUAL=.TRUE.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ PLAEQU DEBUG   :'',
     -      '' Curves match.'')')
       END
CDECK  ID>, PLATRC.
       SUBROUTINE PLATRC(IREF,NREFO,IREFO,IFAIL)
*-----------------------------------------------------------------------
*   PLATRC - Cuts a polygon into right-angled triangles.
*   (Last changed on 27/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION XPL1(MXEDGE),YPL1(MXEDGE),ZPL1(MXEDGE),ZMEAN,
     -      XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),XC,YC,
     -      EPSANG,EPSXYZ,AN1,BN1,CN1,DN1,A1,A2,A3,
     -      XL1, XL2, XL3, XL4
       INTEGER I,IREF,IFAIL,IFAIL1,IFAIL2,NPL1,ICOL1,IP1,JP1,I1,I2,I3,
     -      IREFO(MXPLAN),NREFO,JREFO,NNEW
       LOGICAL CROSSD,INSIDE,EDGE,CORNER
       EXTERNAL CROSSD
*** Assume failure.
       IFAIL=1
*** Establish tolerances.
       EPSANG = BEMEPA
       EPSXYZ = BEMEPD
       CALL EPSSET('SET',EPSXYZ,EPSXYZ,EPSXYZ)
*** Zero the output buffer.
       NREFO=1
       IREFO(NREFO)=IREF
       JREFO=1
*** Next polygon.
 1000  CONTINUE
C       print *,' At JREFo = ',jrefo,' / NREFo = ',nrefo
C       read '(a)'
*   If done, remove spurious elements from the list.
       IF(JREFO.GT.NREFO)THEN
            NNEW=0
            DO 1010 I=1,NREFO
            IF(IREFO(I).GT.0)THEN
                 NNEW=NNEW+1
                 IREFO(NNEW)=IREFO(I)
            ENDIF
 1010       CONTINUE
            NREFO=NNEW
C            print *,' Done, produced ',NREFO,' panels'
            IFAIL=0
            RETURN
       ENDIF
*** Retrieve the polygon.
       IF(IREFO(JREFO).LT.0)THEN
C            print *,' *** No polygon for JREFO = ',jrefo
            jrefo=jrefo+1
            goto 1000
       ENDIF
       CALL PLABU2('READ',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -      AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
C       print *,' Polygon of ',npl1,' nodes, IFAIL =',ifail1
*** Dump
       IF(LBDUMP.AND.JREFO.EQ.1)THEN
            OPEN(UNIT=12,FILE='platrc.dump',ACCESS='APPEND')
            WRITE(12,'(I5,4E15.8)') NPL1,AN1,BN1,CN1,DN1
            DO 1020 I=1,NPL1
            WRITE(12,'(3E15.8)') XPL1(I),YPL1(I),ZPL1(I)
 1020       CONTINUE
            CLOSE(UNIT=12)
       ENDIF
*   Check successful reading.
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! PLATRC WARNING : Panel ',IREFO(JREFO),
     -           ' does not exist.'
            JREFO=JREFO+1
            GOTO 1000
*   Too few nodes
       ELSEIF(NPL1.LE.2)THEN
C            print *,' *** Too few points: ',npl1
            CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
            IREFO(JREFO)=-1
            JREFO=JREFO+1
            GOTO 1000
       ENDIF
*   Track the mean z and preset ZPL to the mean z value
       ZMEAN=0
       DO 10 IP1=1,NPL1
       ZMEAN=ZMEAN+ZPL1(IP1)
10     CONTINUE
       ZMEAN=ZMEAN/NPL1
       DO 40 I=1,MXEDGE
       ZPL(I)=ZMEAN
40     CONTINUE
*** Resume for another pass with the same polygon.
100    CONTINUE
*   Fewer than 3 points: done
       IF(NPL1.LE.2)THEN
C            print *,' Only NPL = ',npl1,' points left - done'
            CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
            IREFO(JREFO)=-1
            JREFO=JREFO+1
            GOTO 1000
*   See whether this is a right-angled triangle.
       ELSEIF(NPL1.EQ.3.AND.
     -      ABS((XPL1(1)-XPL1(2))*(XPL1(3)-XPL1(2))+
     -          (YPL1(1)-YPL1(2))*(YPL1(3)-YPL1(2))).LT.EPSANG*
     -      SQRT(((XPL1(1)-XPL1(2))**2+(YPL1(1)-YPL1(2))**2)*
     -           ((XPL1(3)-XPL1(2))**2+(YPL1(3)-YPL1(2))**2)))THEN
C            print *,' Right-angled triangle node 2 - done'
            JREFO=JREFO+1
            GOTO 1000
*   See whether this is a right-angled triangle.
       ELSEIF(NPL1.EQ.3.AND.
     -      ABS((XPL1(1)-XPL1(3))*(XPL1(2)-XPL1(3))+
     -          (YPL1(1)-YPL1(3))*(YPL1(2)-YPL1(3))).LT.EPSANG*
     -      SQRT(((XPL1(1)-XPL1(3))**2+(YPL1(1)-YPL1(3))**2)*
     -           ((XPL1(2)-XPL1(3))**2+(YPL1(2)-YPL1(3))**2)))THEN
C            print *,' Right-angled triangle node 3 - rearrange'
            XPL(1)=XPL1(2)
            YPL(1)=YPL1(2)
            ZPL(1)=ZPL1(2)
            XPL(2)=XPL1(3)
            YPL(2)=YPL1(3)
            ZPL(2)=ZPL1(3)
            XPL(3)=XPL1(1)
            YPL(3)=YPL1(1)
            ZPL(3)=ZPL1(1)
            CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
            IREFO(JREFO)=-1
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
            JREFO=JREFO+1
            GOTO 1000
*   See whether this is a right-angled triangle.
       ELSEIF(NPL1.EQ.3.AND.
     -      ABS((XPL1(3)-XPL1(1))*(XPL1(2)-XPL1(1))+
     -          (YPL1(3)-YPL1(1))*(YPL1(2)-YPL1(1))).LT.EPSANG*
     -      SQRT(((XPL1(3)-XPL1(1))**2+(YPL1(3)-YPL1(1))**2)*
     -           ((XPL1(2)-XPL1(1))**2+(YPL1(2)-YPL1(1))**2)))THEN
C            print *,' Right-angled triangle node 1 - rearrange'
            XPL(1)=XPL1(3)
            YPL(1)=YPL1(3)
            ZPL(1)=ZPL1(3)
            XPL(2)=XPL1(1)
            YPL(2)=YPL1(1)
            ZPL(2)=ZPL1(1)
            XPL(3)=XPL1(2)
            YPL(3)=YPL1(2)
            ZPL(3)=ZPL1(2)
            CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
            IREFO(JREFO)=-1
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
            JREFO=JREFO+1
            GOTO 1000
*   See whether this is a rectangle.
       ELSEIF(NPL1.EQ.4.AND.
     -      ABS((XPL1(1)-XPL1(2))*(XPL1(3)-XPL1(2))+
     -          (YPL1(1)-YPL1(2))*(YPL1(3)-YPL1(2))).LT.EPSANG*
     -      SQRT(((XPL1(1)-XPL1(2))**2+(YPL1(1)-YPL1(2))**2)*
     -           ((XPL1(3)-XPL1(2))**2+(YPL1(3)-YPL1(2))**2)).AND.
     -      ABS((XPL1(2)-XPL1(3))*(XPL1(4)-XPL1(3))+
     -          (YPL1(2)-YPL1(3))*(YPL1(4)-YPL1(3))).LT.EPSANG*
     -      SQRT(((XPL1(2)-XPL1(3))**2+(YPL1(2)-YPL1(3))**2)*
     -           ((XPL1(4)-XPL1(3))**2+(YPL1(4)-YPL1(3))**2)).AND.
     -      ABS((XPL1(1)-XPL1(4))*(XPL1(3)-XPL1(4))+
     -          (YPL1(1)-YPL1(4))*(YPL1(3)-YPL1(4))).LT.EPSANG*
     -      SQRT(((XPL1(1)-XPL1(4))**2+(YPL1(1)-YPL1(4))**2)*
     -           ((XPL1(3)-XPL1(4))**2+(YPL1(3)-YPL1(4))**2)))THEN
C            print *,' Rectangle'
            JREFO=JREFO+1
            GOTO 1000
**  See whether there are parallel sides, e.g. a trapezium (UK English).
       ELSEIF(NPL1.GE.4)THEN
            DO 200 IP1=1,NPL1
            DO 210 JP1=IP1+2,NPL1
*   Skip adjacent segments.
            IF(  IP1.EQ.JP1.OR.
     -           IP1.EQ.1+MOD(JP1,NPL1).OR.
     -           1+MOD(IP1,NPL1).EQ.JP1.OR.
     -           1+MOD(IP1,NPL1).EQ.1+MOD(JP1,NPL1))GOTO 210
*   Require parallelism.
            IF(ABS((XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))*
     -             (XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))+
     -             (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))*
     -             (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))+
     -       SQRT(((XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))**2+
     -             (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))**2)*
     -            ((XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))**2+
     -             (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))**2))).GT.EPSANG*
     -       SQRT(((XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))**2+
     -             (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))**2)*
     -            ((XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))**2+
     -             (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))**2)))GOTO 210
C      print *,' Found parallel sections: ',IP1,JP1
*   Avoid division by zero
            IF(  (XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))**2+
     -           (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))**2.LE.0.OR.
     -           (XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))**2+
     -           (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))**2.LE.0)THEN
                 PRINT *,' !!!!!! PLATRC WARNING : Zero norm'//
     -                ' segment found; skipped.'
                 GOTO 210
            ENDIF
*   Establish the cutting lines
            XL1 =((XPL1(IP1)            -XPL1(JP1))*
     -            (XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))+
     -            (YPL1(IP1)            -YPL1(JP1))*
     -            (YPL1(1+MOD(JP1,NPL1))-YPL1(JP1)))/
     -           ((XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))**2+
     -            (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))**2)
            XL2 =((XPL1(1+MOD(IP1,NPL1))-XPL1(JP1))*
     -            (XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))+
     -            (YPL1(1+MOD(IP1,NPL1))-YPL1(JP1))*
     -            (YPL1(1+MOD(JP1,NPL1))-YPL1(JP1)))/
     -           ((XPL1(JP1)-XPL1(1+MOD(JP1,NPL1)))**2+
     -            (YPL1(JP1)-YPL1(1+MOD(JP1,NPL1)))**2)
            XL3 =((XPL1(JP1)            -XPL1(IP1))*
     -            (XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))+
     -            (YPL1(JP1)            -YPL1(IP1))*
     -            (YPL1(1+MOD(IP1,NPL1))-YPL1(IP1)))/
     -           ((XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))**2+
     -            (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))**2)
            XL4 =((XPL1(1+MOD(JP1,NPL1))-XPL1(IP1))*
     -            (XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))+
     -            (YPL1(1+MOD(JP1,NPL1))-YPL1(IP1))*
     -            (YPL1(1+MOD(IP1,NPL1))-YPL1(IP1)))/
     -           ((XPL1(IP1)-XPL1(1+MOD(IP1,NPL1)))**2+
     -            (YPL1(IP1)-YPL1(1+MOD(IP1,NPL1)))**2)
C      print *,' xl1 = ',xl1,' xl2 = ',xl2,' xl3 = ',xl3,' xl4 = ',xl4
*   Check that there is at all a rectangle.
            IF(((XL1+EPSANG)*(1+EPSANG-XL1).LT.0.AND.
     -          (XL4+EPSANG)*(1+EPSANG-XL4).LT.0).OR.
     -         ((XL2+EPSANG)*(1+EPSANG-XL2).LT.0.AND.
     -          (XL3+EPSANG)*(1+EPSANG-XL3).LT.0))THEN
C      print *,' No rectangle'
                 GOTO 210
            ENDIF
*   Add the rectangular part.
            IF((XL1+EPSANG)*(1+EPSANG-XL1).GE.0)THEN
                 XPL(1)=XPL1(IP1)
                 YPL(1)=YPL1(IP1)
                 XPL(2)=XPL1(JP1)+XL1*(XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))
                 YPL(2)=YPL1(JP1)+XL1*(YPL1(1+MOD(JP1,NPL1))-YPL1(JP1))
            ELSEIF((XL4+EPSANG)*(1+EPSANG-XL4).GE.0)THEN
                 XPL(1)=XPL1(IP1)+XL4*(XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))
                 YPL(1)=YPL1(IP1)+XL4*(YPL1(1+MOD(IP1,NPL1))-YPL1(IP1))
                 XPL(2)=XPL1(1+MOD(JP1,NPL1))
                 YPL(2)=YPL1(1+MOD(JP1,NPL1))
            ENDIF
            IF((XL2+EPSANG)*(1+EPSANG-XL2).GE.0)THEN
                 XPL(3)=XPL1(JP1)+XL2*(XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))
                 YPL(3)=YPL1(JP1)+XL2*(YPL1(1+MOD(JP1,NPL1))-YPL1(JP1))
                 XPL(4)=XPL1(1+MOD(IP1,NPL1))
                 YPL(4)=YPL1(1+MOD(IP1,NPL1))
            ELSEIF((XL3+EPSANG)*(1+EPSANG-XL3).GE.0)THEN
                 XPL(3)=XPL1(JP1)
                 YPL(3)=YPL1(JP1)
                 XPL(4)=XPL1(IP1)+XL3*(XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))
                 YPL(4)=YPL1(IP1)+XL3*(YPL1(1+MOD(IP1,NPL1))-YPL1(IP1))
            ENDIF
*   Verify that the midpoints of these lines are internal
            CALL INTERD(NPL1,XPL1,YPL1,
     -           (XPL(1)+XPL(2))/2,(YPL(1)+YPL(2))/2,
     -           INSIDE,EDGE)
            IF(.NOT.(INSIDE.OR.EDGE))THEN
C                 print *,' *** Midpoint 1 not internal'
                 GOTO 210
            ENDIF
            CALL INTERD(NPL1,XPL1,YPL1,
     -           (XPL(3)+XPL(4))/2,(YPL(3)+YPL(4))/2,
     -           INSIDE,EDGE)
            IF(.NOT.(INSIDE.OR.EDGE))THEN
C                 print *,' *** Midpoint 2 not internal'
                 GOTO 210
            ENDIF
*   Ensure there are no crossings, accepting contact.
            DO 240 I=1,NPL1
            IF((I.EQ.1+MOD(IP1-2+NPL1,NPL1).AND.
     -          (XL1+EPSANG)*(1+EPSANG-XL1).GE.0)              .OR.
     -          I.EQ.IP1                                       .OR.
     -         (I.EQ.1+MOD(IP1,NPL1).AND.
     -          (XL2+EPSANG)*(1+EPSANG-XL2).GE.0)              .OR.
     -         (I.EQ.1+MOD(JP1-2+NPL1,NPL1).AND.
     -          (XL3+EPSANG)*(1+EPSANG-XL3).GE.0)              .OR.
     -          I.EQ.JP1                                       .OR.
     -         (I.EQ.1+MOD(JP1,NPL1).AND.
     -          (XL4+EPSANG)*(1+EPSANG-XL4).GE.0))GOTO 240
            IF(CROSSD(XPL1(I),YPL1(I),
     -                XPL1(1+MOD(I,NPL1)),YPL1(1+MOD(I,NPL1)),
     -                XPL(1),YPL(1),XPL(2),YPL(2)).OR.
     -         CROSSD(XPL1(I),YPL1(I),
     -                XPL1(1+MOD(I,NPL1)),YPL1(1+MOD(I,NPL1)),
     -                XPL(3),YPL(3),XPL(4),YPL(4)))THEN
C                 print *,' *** Crossing'
C                 print *,'     Edge I/I+1',I,I+1
C                 print *,'     IP1 = ',IP1,' JP1 = ',JP1
C                 do j=1,4
C                    print '(2x,i10,2f10.3)',j,xpl(j),ypl(j)
C                 enddo
                 GOTO 210
            ENDIF
240         CONTINUE
*   Add the rectangular part.
            IF(  (ABS(XL1).LT.EPSANG.AND.ABS(XL3).LT.EPSANG).OR.
     -           (ABS(1-XL2).LT.EPSANG.AND.ABS(1-XL4).LT.EPSANG))THEN
C                 print *,' *** Not stored, degenerate'
C                 do i=1,4
C                    print '(2x,i10,2f10.3)',i,xpl(i),ypl(i)
C                 enddo
            ELSEIF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),4,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
C                 print *,' Adding rectangle'
C                 print *,' Ref = ',IREFO(NREFO)
C                 do i=1,4
C                    print '(2x,i10,2f10.3)',i,xpl(i),ypl(i)
C                 enddo
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
*   First non-rectangular section.
            DO 220 I=JP1+1,IP1+NPL1
            XPL(I-JP1)=XPL1(1+MOD(I-1+NPL1,NPL1))
            YPL(I-JP1)=YPL1(1+MOD(I-1+NPL1,NPL1))
 220        CONTINUE
            IF(  (XL1+EPSANG)*(1+EPSANG-XL1).GE.0.AND.
     -           (XL4+EPSANG)*(1+EPSANG-XL4).GE.0)THEN
C                 print *,' 1-4 degenerate'
                 NNEW=IP1+NPL1-JP1
            ELSEIF((XL1+EPSANG)*(1+EPSANG-XL1).GE.0)THEN
C                 print *,' Using 1'
                 NNEW=IP1+NPL1-JP1+1
                 XPL(NNEW)=
     -                XPL1(JP1)+XL1*(XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))
                 YPL(NNEW)=
     -                YPL1(JP1)+XL1*(YPL1(1+MOD(JP1,NPL1))-YPL1(JP1))
            ELSEIF((XL4+EPSANG)*(1+EPSANG-XL4).GE.0)THEN
C                 print *,' Using 4'
                 NNEW=IP1+NPL1-JP1+1
                 XPL(NNEW)=
     -                XPL1(IP1)+XL4*(XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))
                 YPL(NNEW)=
     -                YPL1(IP1)+XL4*(YPL1(1+MOD(IP1,NPL1))-YPL1(IP1))
            ELSE
C                 print *,' *** Neither 1 nor 4, should not happen'
            ENDIF
            IF(NNEW.LT.3)THEN
C                 print *,' *** Not stored, only ',nnew,' vertices'
            ELSEIF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),NNEW,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
C                 print *,' Ref = ',IREFO(NREFO)
C                 do i=1,nnew
C                    print '(2x,i10,2f10.3)',i,xpl(i),ypl(i)
C                 enddo
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
*   Second non-rectangular section.
            DO 230 I=IP1+1,JP1
            XPL(I-IP1)=XPL1(1+MOD(I-1+NPL1,NPL1))
            YPL(I-IP1)=YPL1(1+MOD(I-1+NPL1,NPL1))
 230        CONTINUE
            IF(  (XL2+EPSANG)*(1+EPSANG-XL2).GE.0.AND.
     -           (XL3+EPSANG)*(1+EPSANG-XL3).GE.0)THEN
C                 print *,' 2-3 degenerate'
                 NNEW=JP1-IP1
            ELSEIF((XL2+EPSANG)*(1+EPSANG-XL2).GE.0)THEN
C                 print *,' Using 2'
                 NNEW=JP1-IP1+1
                 XPL(NNEW)=
     -                XPL1(JP1)+XL2*(XPL1(1+MOD(JP1,NPL1))-XPL1(JP1))
                 YPL(NNEW)=
     -                YPL1(JP1)+XL2*(YPL1(1+MOD(JP1,NPL1))-YPL1(JP1))
            ELSEIF((XL3+EPSANG)*(1+EPSANG-XL3).GE.0)THEN
C                 print *,' Using 3'
                 NNEW=JP1-IP1+1
                 XPL(NNEW)=
     -                XPL1(IP1)+XL3*(XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))
                 YPL(NNEW)=
     -                YPL1(IP1)+XL3*(YPL1(1+MOD(IP1,NPL1))-YPL1(IP1))
            ELSE
C                 print *,' *** Neither 2 nor 3, should not happen'
            ENDIF
            IF(NNEW.LT.3)THEN
                 print *,' *** Not stored, only ',nnew,' vertices'
            ELSEIF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),NNEW,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
C                 print *,' Ref = ',IREFO(NREFO)
C                 do i=1,nnew
C                    print '(2x,i10,2f10.3)',i,xpl(i),ypl(i)
C                 enddo
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
*   Delete the original and restart a cycle
            CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
            IREFO(JREFO)=-1
            JREFO=JREFO+1
            GOTO 1000
 210        CONTINUE
 200        CONTINUE
       ENDIF
*** Find a right-angled corner we can cut off.
C       print *,' Trying to find a right-angle'
       CORNER=.FALSE.
       DO 70 IP1=1,NPL1
*   Take only right angles
       IF(ABS((XPL1(1+MOD(IP1-2+NPL1,NPL1))-XPL1(IP1))*
     -        (XPL1(1+MOD(IP1,NPL1))-       XPL1(IP1))+
     -        (YPL1(1+MOD(IP1-2+NPL1,NPL1))-YPL1(IP1))*
     -        (YPL1(1+MOD(IP1,NPL1))-       YPL1(IP1))).GT.EPSANG*
     -      SQRT(((XPL1(1+MOD(IP1-2+NPL1,NPL1))-XPL1(IP1))**2+
     -            (YPL1(1+MOD(IP1-2+NPL1,NPL1))-YPL1(IP1))**2)*
     -           ((XPL1(1+MOD(IP1,NPL1))-XPL1(IP1))**2+
     -            (YPL1(1+MOD(IP1,NPL1))-YPL1(IP1))**2)))GOTO 70
*   Ensure the midpoint is internal.
       IF(NPL1.GT.3)THEN
            CALL INTERD(NPL1,XPL1,YPL1,
     -           (XPL1(1+MOD(IP1-2+NPL1,NPL1))+XPL1(1+MOD(IP1,NPL1)))/2,
     -           (YPL1(1+MOD(IP1-2+NPL1,NPL1))+YPL1(1+MOD(IP1,NPL1)))/2,
     -           INSIDE,EDGE)
            IF(.NOT.INSIDE)GOTO 70
       ENDIF
*** Check all vertex crossings.
       DO 80 JP1=1,NPL1
*   Accept immediate contact.
       IF(  JP1            .EQ.1+MOD(IP1-2+NPL1,NPL1).OR.
     -      JP1            .EQ.IP1.OR.
     -      JP1            .EQ.1+MOD(IP1,NPL1).OR.
     -      1+MOD(JP1,NPL1).EQ.1+MOD(IP1-2+NPL1,NPL1).OR.
     -      1+MOD(JP1,NPL1).EQ.IP1.OR.
     -      1+MOD(JP1,NPL1).EQ.1+MOD(IP1,NPL1))GOTO 80
*   Check crossing.
       IF(CROSSD(XPL1(1+MOD(IP1-2+NPL1,NPL1)),
     -           YPL1(1+MOD(IP1-2+NPL1,NPL1)),
     -           XPL1(1+MOD(IP1,NPL1)),
     -           YPL1(1+MOD(IP1,NPL1)),
     -           XPL1(JP1),
     -           YPL1(JP1),
     -           XPL1(1+MOD(JP1,NPL1)),
     -           YPL1(1+MOD(JP1,NPL1))))GOTO 70
80     CONTINUE
*** Found a triangle, introduce shorthand node references.
C       print *,' Cutting at right-angled corner ',IP1
       CORNER=.TRUE.
       XPL(1)=XPL1(1+MOD(IP1-2+NPL1,NPL1))
       YPL(1)=YPL1(1+MOD(IP1-2+NPL1,NPL1))
       XPL(2)=XPL1(IP1)
       YPL(2)=YPL1(IP1)
       XPL(3)=XPL1(1+MOD(IP1,NPL1))
       YPL(3)=YPL1(1+MOD(IP1,NPL1))
       IF(NREFO+1.LE.MXPLAN)THEN
            NREFO=NREFO+1
            CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -           AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
       ELSE
            PRINT *,' !!!!!! PLAXXX WARNING : Output list'//
     -                ' too long.'
            RETURN
       ENDIF
*** Eliminate this node from the polygon.
       DO 90 JP1=1,NPL1
       IF(JP1.GT.IP1)THEN
            XPL1(JP1-1)=XPL1(JP1)
            YPL1(JP1-1)=YPL1(JP1)
       ELSEIF(JP1.LT.IP1)THEN
            XPL1(JP1)=XPL1(JP1)
            YPL1(JP1)=YPL1(JP1)
       ENDIF
90     CONTINUE
       NPL1=NPL1-1
C       print *,' Going for another pass, NPL = ',npl1
       GOTO 100
70     CONTINUE
*** Find any corner we can cut off.
C       print *,' Trying to find a corner'
       CORNER=.FALSE.
       DO 20 IP1=1,NPL1
*   Ensure the midpoint is internal.
       IF(NPL1.GT.3)THEN
            CALL INTERD(NPL1,XPL1,YPL1,
     -           (XPL1(1+MOD(IP1-2+NPL1,NPL1))+XPL1(1+MOD(IP1,NPL1)))/2,
     -           (YPL1(1+MOD(IP1-2+NPL1,NPL1))+YPL1(1+MOD(IP1,NPL1)))/2,
     -           INSIDE,EDGE)
            IF(.NOT.INSIDE)GOTO 20
       ENDIF
*** Check all vertex crossings.
       DO 30 JP1=1,NPL1
*   Accept immediate contact.
       IF(  JP1            .EQ.1+MOD(IP1-2+NPL1,NPL1).OR.
     -      JP1            .EQ.IP1.OR.
     -      JP1            .EQ.1+MOD(IP1,NPL1).OR.
     -      1+MOD(JP1,NPL1).EQ.1+MOD(IP1-2+NPL1,NPL1).OR.
     -      1+MOD(JP1,NPL1).EQ.IP1.OR.
     -      1+MOD(JP1,NPL1).EQ.1+MOD(IP1,NPL1))GOTO 30
*   Check crossing.
       IF(CROSSD(XPL1(1+MOD(IP1-2+NPL1,NPL1)),
     -           YPL1(1+MOD(IP1-2+NPL1,NPL1)),
     -           XPL1(1+MOD(IP1,NPL1)),
     -           YPL1(1+MOD(IP1,NPL1)),
     -           XPL1(JP1),
     -           YPL1(JP1),
     -           XPL1(1+MOD(JP1,NPL1)),
     -           YPL1(1+MOD(JP1,NPL1))))GOTO 20
30     CONTINUE
*** Found a triangle, introduce shorthand node references.
C       print *,' Cutting at corner ',IP1
       CORNER=.TRUE.
       I1=1+MOD(IP1-2+NPL1,NPL1)
       I2=IP1
       I3=1+MOD(IP1,NPL1)
*   Find the biggest opening angle.
       A1=  ((XPL1(I2)-XPL1(I1))*(XPL1(I3)-XPL1(I1))+
     -       (YPL1(I2)-YPL1(I1))*(YPL1(I3)-YPL1(I1)))/
     -      SQRT(((XPL1(I2)-XPL1(I1))**2+(YPL1(I2)-YPL1(I1))**2)*
     -           ((XPL1(I3)-XPL1(I1))**2+(YPL1(I3)-YPL1(I1))**2))
       A2=  ((XPL1(I3)-XPL1(I2))*(XPL1(I1)-XPL1(I2))+
     -       (YPL1(I3)-YPL1(I2))*(YPL1(I1)-YPL1(I2)))/
     -      SQRT(((XPL1(I3)-XPL1(I2))**2+(YPL1(I3)-YPL1(I2))**2)*
     -           ((XPL1(I1)-XPL1(I2))**2+(YPL1(I1)-YPL1(I2))**2))
       A3=  ((XPL1(I1)-XPL1(I3))*(XPL1(I2)-XPL1(I3))+
     -       (YPL1(I1)-YPL1(I3))*(YPL1(I2)-YPL1(I3)))/
     -      SQRT(((XPL1(I1)-XPL1(I3))**2+(YPL1(I1)-YPL1(I3))**2)*
     -           ((XPL1(I2)-XPL1(I3))**2+(YPL1(I2)-YPL1(I3))**2))
C       print *,'    Angles: ',
C     -      180.0*acos(a1)/pi,180*acos(a2)/pi,180*acos(a3)/pi,
C     -      ', sum = ',180.0*(acos(a1)+acos(a2)+acos(a3))/pi
*   See whether one angle is more or less right-angled
       IF(ABS(A1).LT.EPSANG.OR.ABS(A2).LT.EPSANG.OR.
     -      ABS(A3).LT.EPSANG)THEN
C            print *,' Right-angled corner cut off'
            IF(ABS(A1).LT.EPSANG)THEN
                 XPL(1)=XPL1(I3)
                 YPL(1)=YPL1(I3)
                 XPL(2)=XPL1(I1)
                 YPL(2)=YPL1(I1)
                 XPL(3)=XPL1(I2)
                 YPL(3)=YPL1(I2)
            ELSEIF(ABS(A2).LT.EPSANG)THEN
                 XPL(1)=XPL1(I1)
                 YPL(1)=YPL1(I1)
                 XPL(2)=XPL1(I2)
                 YPL(2)=YPL1(I2)
                 XPL(3)=XPL1(I3)
                 YPL(3)=YPL1(I3)
            ELSE
                 XPL(1)=XPL1(I2)
                 YPL(1)=YPL1(I2)
                 XPL(2)=XPL1(I3)
                 YPL(2)=YPL1(I3)
                 XPL(3)=XPL1(I1)
                 YPL(3)=YPL1(I1)
            ENDIF
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
       ELSEIF(A1.LE.A2.AND.A1.LE.A3)THEN
C            print *,' A1 < A2, A3 - adding 2 triangles'
            XC=XPL1(I2)+A2*(XPL1(I3)-XPL1(I2))*SQRT(
     -          ((XPL1(I1)-XPL1(I2))**2+(YPL1(I1)-YPL1(I2))**2)/
     -          ((XPL1(I3)-XPL1(I2))**2+(YPL1(I3)-YPL1(I2))**2))
            YC=YPL1(I2)+A2*(YPL1(I3)-YPL1(I2))*SQRT(
     -          ((XPL1(I1)-XPL1(I2))**2+(YPL1(I1)-YPL1(I2))**2)/
     -          ((XPL1(I3)-XPL1(I2))**2+(YPL1(I3)-YPL1(I2))**2))
            XPL(1)=XPL1(I3)
            YPL(1)=YPL1(I3)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I1)
            YPL(3)=YPL1(I1)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
            XPL(1)=XPL1(I2)
            YPL(1)=YPL1(I2)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I1)
            YPL(3)=YPL1(I1)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
       ELSEIF(A2.LE.A1.AND.A2.LE.A3)THEN
C            print *,' A2 < A1, A3 - adding 2 triangles'
            XC=XPL1(I3)+A3*(XPL1(I1)-XPL1(I3))*SQRT(
     -          ((XPL1(I2)-XPL1(I3))**2+(YPL1(I2)-YPL1(I3))**2)/
     -          ((XPL1(I1)-XPL1(I3))**2+(YPL1(I1)-YPL1(I3))**2)) 
            YC=YPL1(I3)+A3*(YPL1(I1)-YPL1(I3))*SQRT(
     -          ((XPL1(I2)-XPL1(I3))**2+(YPL1(I2)-YPL1(I3))**2)/
     -          ((XPL1(I1)-XPL1(I3))**2+(YPL1(I1)-YPL1(I3))**2)) 
            XPL(1)=XPL1(I1)
            YPL(1)=YPL1(I1)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I2)
            YPL(3)=YPL1(I2)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
            XPL(1)=XPL1(I3)
            YPL(1)=YPL1(I3)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I2)
            YPL(3)=YPL1(I2)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
       ELSE
C            print *,' A3 < A1, A2 - adding 2 triangles'
            XC=XPL1(I1)+A1*(XPL1(I2)-XPL1(I1))*SQRT(
     -          ((XPL1(I3)-XPL1(I1))**2+(YPL1(I3)-YPL1(I1))**2)/
     -          ((XPL1(I2)-XPL1(I1))**2+(YPL1(I2)-YPL1(I1))**2))
            YC=YPL1(I1)+A1*(YPL1(I2)-YPL1(I1))*SQRT(
     -          ((XPL1(I3)-XPL1(I1))**2+(YPL1(I3)-YPL1(I1))**2)/
     -          ((XPL1(I2)-XPL1(I1))**2+(YPL1(I2)-YPL1(I1))**2))
            XPL(1)=XPL1(I1)
            YPL(1)=YPL1(I1)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I3)
            YPL(3)=YPL1(I3)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
            XPL(1)=XPL1(I2)
            YPL(1)=YPL1(I2)
            XPL(2)=XC
            YPL(2)=YC
            XPL(3)=XPL1(I3)
            YPL(3)=YPL1(I3)
            IF(NREFO+1.LE.MXPLAN)THEN
                 NREFO=NREFO+1
                 CALL PLABU2('STORE',IREFO(NREFO),3,XPL,YPL,ZPL,
     -                AN1,BN1,CN1,DN1,ICOL1,IFAIL1)
            ELSE
                 PRINT *,' !!!!!! PLATRC WARNING : Output list'//
     -                     ' too long.'
                 RETURN
            ENDIF
       ENDIF
*** Eliminate this node from the polygon.
       DO 50 JP1=1,NPL1
       IF(JP1.GT.IP1)THEN
            XPL1(JP1-1)=XPL1(JP1)
            YPL1(JP1-1)=YPL1(JP1)
       ELSEIF(JP1.LT.IP1)THEN
            XPL1(JP1)=XPL1(JP1)
            YPL1(JP1)=YPL1(JP1)
       ENDIF
50     CONTINUE
       NPL1=NPL1-1
C       print *,' Going for another pass, NPL = ',npl1
       GOTO 100
20     CONTINUE
       IF(.NOT.CORNER)PRINT *,' !!!!!! PLATRC WARNING : Unable to'//
     -      ' identify a corner to cut, probably a degenerate polygon.'
*** Next stack element.
       CALL PLABU2('DELETE',IREFO(JREFO),NPL1,XPL1,YPL1,ZPL1,
     -      AN1,BN1,CN1,DN1,ICOL1,IFAIL2)
       IREFO(JREFO)=-1
       JREFO=JREFO+1
       GOTO 1000
       END
CDECK  ID>, CELSCT.
       SUBROUTINE CELSCT(OPTION)
*-----------------------------------------------------------------------
*   CELSCT - Reads solid cutting instructions.
*   (Last changed on 13/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       INTEGER NWORD,I,J,K,L,INEXT,JNEXT,NC,IEQ,NC1,NC2,INPTYP,INPCMP,
     -     MODVAR(MXVAR),MODRES(1),NRES,IENTRY,NSEL,ICOL,IVOL,NREF,NPL,
     -     ISOL,IFAIL1,NREFO,IREFO(MXPLAN)
       REAL VAR(MXVAR),RES(1),FRES(3,3,3)
       DOUBLE PRECISION FXR,FYR,FZR,FNORM,X0,Y0,Z0,
     -      XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),APL,BPL,CPL
       CHARACTER*(MXCHAR) STRING
       CHARACTER*10 VARLIS(MXVAR)
       CHARACTER*(*) OPTION
       LOGICAL OK,SOLSEL(MXSOLI),FLAG(MXWORD+1),USE(MXVAR),MARK(MXPLAN)
       EXTERNAL INPTYP,INPCMP
*   Cut list  
       INTEGER MXCUT
       PARAMETER(MXCUT=20)
       INTEGER NCUT,NCSEL(MXCUT),NCPLA(MXCUT)
       CHARACTER*80 SELSTR(MXCUT),PLASTR(MXCUT),STR1,STR2
       SAVE NCUT, SELSTR, NCSEL, PLASTR, NCPLA
*** Debugging.
       IF(LIDENT)PRINT *,' /// ROUTINE CELSCT ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ CELSCT DEBUG   : Option: '',
     -      A)') OPTION
*** Reset number of cuts.
       IF(OPTION.EQ.'RESET')THEN
            NCUT=0
            RETURN
*** Store a new cut.
       ELSEIF(OPTION.EQ.'STORE')THEN
*   See whether we still have room.
            IF(NCUT+1.GT.MXCUT)THEN
                 PRINT *,' !!!!!! CELSCT WARNING : No room to store'//
     -                ' further cuts; cut will not be applied.'
                 RETURN
            ENDIF
*   Initial settings
            NC1=0
            STR1=' '
            NC2=0
            STR2=' '
*   Find current number of arguments.
            CALL INPNUM(NWORD)
*   Flag keywords.
            DO 10 I=1,NWORD+1
            IF(I.GT.NWORD)THEN
                 FLAG(I)=.TRUE.
            ELSEIF(INPCMP(I,'PL#ANE').NE.0.OR.
     -           INPCMP(I,'SOL#IDS').NE.0)THEN
                 FLAG(I)=.TRUE.
            ELSE
                 FLAG(I)=.FALSE.
            ENDIF
10          CONTINUE
*   Search for further arguments.
            INEXT=2
            OK=.TRUE.
            DO 20 I=2,NWORD
            IF(I.LT.INEXT)GOTO 20
*   Viewing plane.
            IF(INPCMP(I,'PL#ANE').NE.0)THEN
                 STRING=' '
                 NC=0
                 DO 30 J=I+1,NWORD+1
                 IF(FLAG(J))THEN
                      CALL INPSTR(I+1,J-1,STRING,NC)
                      INEXT=J
                      GOTO 40
                 ENDIF
30               CONTINUE
                 NC=0
40               CONTINUE
*   Ensure a definition is present.
                 IF(NC.LE.0)THEN
                      PRINT *,' !!!!!! CELSCT WARNING : The cut plane'//
     -                     ' is not correctly specified.'
                      RETURN
                 ELSEIF(NC+2.GT.LEN(STR1))THEN
                      PRINT *,' !!!!!! CELSCT WARNING : The cut plane'//
     -                     ' specification is too long; not applied.'
                      RETURN
                 ENDIF
*   Check the format.
                 IF(INDEX(STRING(1:NC),'>').EQ.0.AND.
     -              INDEX(STRING(1:NC),'<').EQ.0)THEN
                      PRINT *,' !!!!!! CELSCT WARNING : Did not find'//
     -                     ' a < or > sign in the plane description.'
                      RETURN
                 ENDIF
                 IEQ=INDEX(STRING(1:NC),'>')
                 IF(IEQ.GE.1.AND.IEQ.LT.NC)THEN
                      STR1=STRING(1:IEQ-1)//'-('//STRING(IEQ+1:NC)//')'
                      NC1=NC+2
                 ELSE
                      IEQ=INDEX(STRING(1:NC),'<')
                      IF(IEQ.GE.1.AND.IEQ.LT.NC)THEN
                           STR1=STRING(IEQ+1:NC)//'-('//
     -                          STRING(1:IEQ-1)//')'
                           NC1=NC+2
                      ELSE
                           PRINT *,' !!!!!! CELSCT WARNING : The <'//
     -                          ' or > sign is missing or misplaced.'
                           RETURN
                      ENDIF
                 ENDIF
**  Solid selection.
            ELSEIF(INPCMP(I,'SOL#IDS').NE.0)THEN
                 DO 50 J=I+1,NWORD+1
                 IF(FLAG(J))THEN
                      CALL INPSTR(I+1,J-1,STRING,NC)
                      INEXT=J
                      GOTO 60
                 ENDIF
50               CONTINUE
                 NC=0
60               CONTINUE
*   Check length.
                 IF(NC.LE.0)THEN
                      PRINT *,' !!!!!! CELSCT WARNING : The solid'//
     -                     ' selection is not correctly specified.'
                      RETURN
                 ELSEIF(NC.GT.LEN(STR2))THEN
                      PRINT *,' !!!!!! CELSCT WARNING : The solid'//
     -                     ' selection is too long; not applied.'
                      RETURN
                 ENDIF
*   Store
                 STR2=STRING
                 NC2=NC
**  Anything else
            ELSE
                 PRINT *,' !!!!!! CELSCT WARNING : Unknown option'//
     -                ' ignored.'
            ENDIF
20          CONTINUE
*   Check that something has been entered
            IF(NC1.LE.0.OR.STR1.EQ.' ')THEN
                 PRINT *,' !!!!!! CELSCT WARNING : No cut plane is'//
     -                ' specified; cut is not stored.'
                 RETURN
            ENDIF
            IF(NC2.EQ.0)THEN
                 STR2='ALL'
                 NC2=3
            ENDIF
*   Store as a new cut.
            NCUT=NCUT+1
            PLASTR(NCUT)=STR1
            NCPLA(NCUT)=NC1
            SELSTR(NCUT)=STR2
            NCSEL(NCUT)=NC2
*   Debugging
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ CELSCT DEBUG   :'',
     -           '' Cut '',I5/26X,''Plane:  '',A/26X,''Solids: '',A)')
     -            NCUT,PLASTR(NCUT)(1:NCPLA(NCUT)),
     -            SELSTR(NCUT)(1:NCSEL(NCUT))
*   Done
            RETURN
**  Only other option is applying..
       ELSEIF(OPTION.NE.'APPLY')THEN
            PRINT *,' !!!!!! CELSCT WARNING : Unknown option, ',
     -           OPTION
            RETURN
       ENDIF
*** Apply the cuts in sequence.
       DO 70 I=1,NCUT
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ CELSCT DEBUG   :'',
     -      '' Processing cut '',I5)') I
*   Initial solid selection setting
       DO 80 J=1,NSOLID
       SOLSEL(J)=.FALSE.
80     CONTINUE
       NSEL=0
*   Decode the string.
       JNEXT=1
       DO 90 J=1,NCSEL(I)
       IF(J.LT.JNEXT)GOTO 90
       IF(INDEX('0123456789',SELSTR(I)(J:J)).GT.0)THEN
            K=J+1
            ISOL=0
            IFAIL1=0
100         CONTINUE
            IF(K.GT.NCSEL(I))THEN
                 CALL INPRIC(SELSTR(I)(J:NCSEL(I)),ISOL,0,IFAIL1)
                 JNEXT=NCSEL(I)+1
                 GOTO 110
            ELSEIF(INDEX('0123456789',SELSTR(I)(K:K)).NE.0)THEN
                 K=K+1
                 GOTO 100
            ENDIF
            CALL INPRIC(SELSTR(I)(J:K-1),ISOL,0,IFAIL1)
            JNEXT=K
110         CONTINUE
            IF(IFAIL1.NE.0.OR.ISOL.LE.0.OR.ISOL.GT.NSOLID)THEN
                 PRINT *,' !!!!!! CELSCT WARNING : Solid number ',
     -                ISOL,' not valid in cut ',I
                 GOTO 70
            ENDIF
            SOLSEL(ISOL)=.TRUE.
            NSEL=NSEL+1
       ELSEIF(SELSTR(I)(J:MIN(NCSEL(I),J+2)).EQ.'ALL')THEN
            DO 120 K=1,NSOLID
            SOLSEL(K)=.TRUE.
120         CONTINUE
            NSEL=NSOLID
            JNEXT=J+3
       ELSEIF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',SELSTR(I)(J:J)).GT.
     -      0)THEN
            DO 130 K=1,NSOLID
            IF(SOLTYP(K).EQ.SELSTR(I)(J:J))SOLSEL(K)=.TRUE.
            NSEL=NSEL+1
130         CONTINUE
       ELSEIF(INDEX(' ,',SELSTR(I)(J:J)).EQ.0)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Unrecognised character "',
     -           SELSTR(I)(J:J),'" in solid selection; skipped.'
            GOTO 70
       ENDIF
90     CONTINUE
*   If the selection is empty, select all.
       IF(NSEL.EQ.0)THEN
            DO 140 K=1,NSOLID
            SOLSEL(K)=.TRUE.
140         CONTINUE
       ENDIF
*   Debugging
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ CELSCT DEBUG   : Selected'',
     -           '' solids: '')')
            DO 210 J=1,NSOLID
            IF(SOLSEL(J))WRITE(LUNOUT,'(26X,I5,5X,A1)') J,SOLTYP(J)
210         CONTINUE
       ENDIF
*** Translate the formula.
       VARLIS(1)='X'
       VARLIS(2)='Y'
       VARLIS(3)='Z'
       CALL ALGPRE(PLASTR(I)(1:NCPLA(I)),NCPLA(I),VARLIS,3,NRES,USE,
     -      IENTRY,IFAIL1)
*   Check the results.
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula not translatable.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ELSEIF(NRES.NE.1)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula does not return 1 result.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ELSEIF(.NOT.(USE(1).OR.USE(2).OR.USE(3)))THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula does not depend on x, y or z.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
*** Compute function values at a (3x3) set of points.
       OK=.TRUE.
       MODVAR(1)=2
       MODVAR(2)=2
       MODVAR(3)=2
       DO 150 L=-1,1
       DO 160 J=-1,1
       DO 170 K=-1,1
       VAR(1)=0.5*(XMIN+XMAX)+L*(1+ABS(XMIN)+ABS(XMAX))
       VAR(2)=0.5*(YMIN+YMAX)+J*(1+ABS(YMIN)+ABS(YMAX))
       VAR(3)=0.5*(ZMIN+ZMAX)+K*(1+ABS(ZMIN)+ABS(ZMAX))
       CALL ALGEXE(IENTRY,VAR,MODVAR,3,RES,MODRES,1,IFAIL1)
       IF(IFAIL1.NE.0.OR.MODRES(1).NE.2)OK=.FALSE.
       FRES(2+L,2+J,2+K)=RES(1)
170    CONTINUE
160    CONTINUE
150    CONTINUE
*   Ensure that all function evaluations worked.
       IF(.NOT.OK)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula can not be evaluated.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
*** Extract parameters.
       FXR=((FRES(3,1,1)-FRES(1,1,1))+
     -      (FRES(3,1,2)-FRES(1,1,2))+
     -      (FRES(3,2,1)-FRES(1,2,1))+
     -      (FRES(3,2,2)-FRES(1,2,2)))/(8*(1+ABS(XMIN)+ABS(XMAX)))
       FYR=((FRES(1,3,1)-FRES(1,1,1))+
     -      (FRES(1,3,2)-FRES(1,1,2))+
     -      (FRES(2,3,1)-FRES(2,1,1))+
     -      (FRES(2,3,2)-FRES(2,1,2)))/(8*(1+ABS(YMIN)+ABS(YMAX)))
       FZR=((FRES(1,1,3)-FRES(1,1,1))+
     -      (FRES(1,2,3)-FRES(1,2,1))+
     -      (FRES(2,1,3)-FRES(2,1,1))+
     -      (FRES(2,2,3)-FRES(2,2,1)))/(8*(1+ABS(ZMIN)+ABS(ZMAX)))
*   Check for cross-terms.
       IF(ABS(FXR-0.5*(FRES(3,1,1)-FRES(1,1,1))/
     -      (1+ABS(XMIN)+ABS(XMAX))).GT.1E-4*(1+ABS(FXR)).OR.
     -      ABS(FXR-0.5*(FRES(3,1,2)-FRES(1,1,2))/
     -      (1+ABS(XMIN)+ABS(XMAX))).GT.1E-4*(1+ABS(FXR)).OR.
     -      ABS(FXR-0.5*(FRES(3,2,1)-FRES(1,2,1))/
     -      (1+ABS(XMIN)+ABS(XMAX))).GT.1E-4*(1+ABS(FXR)).OR.
     -      ABS(FXR-0.5*(FRES(3,2,2)-FRES(1,2,2))/
     -      (1+ABS(XMIN)+ABS(XMAX))).GT.1E-4*(1+ABS(FXR)).OR.
     -      ABS(FYR-0.5*(FRES(1,3,1)-FRES(1,1,1))/
     -      (1+ABS(YMIN)+ABS(YMAX))).GT.1E-4*(1+ABS(FYR)).OR.
     -      ABS(FYR-0.5*(FRES(1,3,2)-FRES(1,1,2))/
     -      (1+ABS(YMIN)+ABS(YMAX))).GT.1E-4*(1+ABS(FYR)).OR.
     -      ABS(FYR-0.5*(FRES(2,3,1)-FRES(2,1,1))/
     -      (1+ABS(YMIN)+ABS(YMAX))).GT.1E-4*(1+ABS(FYR)).OR.
     -      ABS(FYR-0.5*(FRES(2,3,2)-FRES(2,1,2))/
     -      (1+ABS(YMIN)+ABS(YMAX))).GT.1E-4*(1+ABS(FYR)).OR.
     -      ABS(FZR-0.5*(FRES(1,1,3)-FRES(1,1,1))/
     -      (1+ABS(ZMIN)+ABS(ZMAX))).GT.1E-4*(1+ABS(FZR)).OR.
     -      ABS(FZR-0.5*(FRES(1,2,3)-FRES(1,2,1))/
     -      (1+ABS(ZMIN)+ABS(ZMAX))).GT.1E-4*(1+ABS(FZR)).OR.
     -      ABS(FZR-0.5*(FRES(2,1,3)-FRES(2,1,1))/
     -      (1+ABS(ZMIN)+ABS(ZMAX))).GT.1E-4*(1+ABS(FZR)).OR.
     -      ABS(FZR-0.5*(FRES(2,2,3)-FRES(2,2,1))/
     -      (1+ABS(ZMIN)+ABS(ZMAX))).GT.1E-4*(1+ABS(FZR)))THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula probably contains cross terms.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
*   Check for linearity in x, y and z.
       IF(  ABS(FRES(3,1,1)-2*FRES(2,1,1)+FRES(1,1,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,1,1)),ABS(FRES(2,1,1)),ABS(FRES(3,1,1)))).OR.
     -      ABS(FRES(3,1,2)-2*FRES(2,1,2)+FRES(1,1,2)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,1,2)),ABS(FRES(2,1,2)),ABS(FRES(3,1,2)))).OR.
     -      ABS(FRES(3,2,1)-2*FRES(2,2,1)+FRES(1,2,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,2,1)),ABS(FRES(2,2,1)),ABS(FRES(3,2,1)))).OR.
     -      ABS(FRES(3,2,2)-2*FRES(2,2,2)+FRES(1,2,2)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,2,2)),ABS(FRES(2,2,2)),ABS(FRES(3,2,2)))))
     -      THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula is not linear in x.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
       IF(  ABS(FRES(1,3,1)-2*FRES(1,2,1)+FRES(1,1,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,1,1)),ABS(FRES(1,2,1)),ABS(FRES(1,3,1)))).OR.
     -      ABS(FRES(1,3,2)-2*FRES(1,2,2)+FRES(1,1,2)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,1,2)),ABS(FRES(1,2,2)),ABS(FRES(1,3,2)))).OR.
     -      ABS(FRES(2,3,1)-2*FRES(2,2,1)+FRES(2,1,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(2,1,1)),ABS(FRES(2,2,1)),ABS(FRES(2,3,1)))).OR.
     -      ABS(FRES(2,3,2)-2*FRES(2,2,2)+FRES(2,1,2)).GT.1E-4*(1+
     -      MAX(ABS(FRES(2,1,2)),ABS(FRES(2,2,2)),ABS(FRES(2,3,2)))))
     -      THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula is not linear in y.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF

       IF(  ABS(FRES(1,1,3)-2*FRES(1,1,2)+FRES(1,1,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,1,1)),ABS(FRES(1,1,2)),ABS(FRES(1,1,3)))).OR.
     -      ABS(FRES(1,2,3)-2*FRES(1,2,2)+FRES(1,2,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(1,2,1)),ABS(FRES(1,2,2)),ABS(FRES(1,2,3)))).OR.
     -      ABS(FRES(2,1,3)-2*FRES(2,1,2)+FRES(2,1,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(2,1,1)),ABS(FRES(2,1,2)),ABS(FRES(2,1,3)))).OR.
     -      ABS(FRES(2,2,3)-2*FRES(2,2,2)+FRES(2,2,1)).GT.1E-4*(1+
     -      MAX(ABS(FRES(2,2,1)),ABS(FRES(2,2,2)),ABS(FRES(2,2,3)))))
     -      THEN
            PRINT *,' !!!!!! CELSCT WARNING : Plane description ',I,
     -           ' formula is not linear in z.'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
*   Check normalisation
       FNORM=SQRT(FXR**2+FYR**2+FZR**2)
       IF(FNORM.LE.0)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Formula ',I,' does not',
     -           ' describe a plane (zero norm normal vector).'
            CALL ALGCLR(IENTRY)
            GOTO 70
       ENDIF
*** Normalise the in-plane vector.
       VAR(1)=0
       VAR(2)=0
       VAR(3)=0
       CALL ALGEXE(IENTRY,VAR,MODVAR,3,RES,MODRES,1,IFAIL1)
       IF(IFAIL1.NE.0.OR.MODRES(1).NE.2)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Unable to compute'//
     -           ' an in-plane vector for cut ',I,'.'
            CALL ALGCLR(IENTRY)
            RETURN
       ENDIF
       X0=-RES(1)*FXR/FNORM**2
       Y0=-RES(1)*FYR/FNORM**2
       Z0=-RES(1)*FZR/FNORM**2
*** Clear the formula.
       CALL ALGCLR(IENTRY)
*** Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ CELSCT DEBUG   : Cut plane''/
     -      26X,''In plane point: '',F10.3,2X,F10.3,2X,F10.3/
     -      26X,''Normal vector:  '',F10.3,2X,F10.3,2X,F10.3)')
     -      X0,Y0,Z0,FXR,FYR,FZR
*** Loop over all panels to cut.
       CALL PLABU1('QUERY',NREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       DO 200 J=1,MXPLAN
       MARK(J)=.FALSE.
200    CONTINUE
       DO 180 J=1,NREF
       CALL PLABU1('READ',J,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       IF(MARK(J).OR.IFAIL1.NE.0)THEN
            GOTO 180
       ELSEIF(IVOL.LE.0.OR.IVOL.GT.NSOLID)THEN
            PRINT *,' !!!!!! CELSCT WARNING : Invalid volume'//
     -           ' reference ',IVOL,' on panel ',I,'; skipped.'
            GOTO 180
       ELSEIF(SOLSEL(IVOL))THEN
            CALL BEMCUT(J, NREFO, IREFO, FXR,FYR,FZR, X0,Y0,Z0)
            DO 190 K=1,NREFO
            MARK(IREFO(K))=.TRUE.
190         CONTINUE
            CALL PLABU1('DELETE',J,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -           ICOL,IVOL,IFAIL1)
       ENDIF
180    CONTINUE
*** Next cut
70     CONTINUE
       END
CDECK  ID>, CELSOL.
       SUBROUTINE CELSOL
*-----------------------------------------------------------------------
*   CELSOL - Reads a list of solids.
*   VARIABLES : NXMIN,NXMAX: Numbers of resp first and last x-period.
*               NYMIN,NYMAX:    "    "   "     "    "   "   y   "
*               Boundary types as used in neBEM
*               1: conductor at specified potential
*               2: conductor with a specified charge
*               3: floating conductor (zero charge, perpendicular E)
*               4: dielectric without "manual" charge (plastic-plastic)
*               5: dielectric with surface charge (plastic-gas)
*               6: symmetry boundary, E parallel
*               7: symmetry boundary, E perpendicular (any use ?)
*   (Last changed on 12/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       CHARACTER*(MXCHAR) STRING
       CHARACTER AUXTYP
       INTEGER I,INEXT,NWORD,IFAIL1,IFAIL2,IFAIL3,INPCMP,INPTYP,
     -      NC,IMAT,N,NR,NCAUX,IBOUND,NPROF,IORI,IPRMIN,J
       DOUBLE PRECISION XPROF(MXEDGE),YPROF(MXEDGE),ZPROF(MXEDGE),DET,
     -      XPRMIN
       REAL XDIR,YDIR,ZDIR,XPOS,YPOS,ZPOS,XSIZ,YSIZ,ZSIZ,R,R1,R2,
     -      AUX1,AUX2,AUX3,THETA,PHI,AROT,VOLT,CHARGE,EPS,XNOTCH,ZNOTCH,
     -      DIS1,DIS2,DIS3,DIS4,DIS5,DIS6,DIS7,DISAUX,DISDEF
       LOGICAL LRAD,LRAD1,LRAD2,LPOS,LSIZ,STDSTR,LVOLT,LEPS,LCHA,
     -      LNOTCH, LTLID,LBLID,LRMEAN,LEPROF
       EXTERNAL INPCMP,INPTYP,STDSTR
*** Read the number of words.
       CALL INPNUM(NWORD)
*** Warn if there are options.
       IF(NWORD.NE.1)PRINT *,' !!!!!! CELSOL WARNING : No arguments'//
     -      ' for SOLIDS known; ignored.'
*** Initialise the conductor table.
       NSOLID=0
       ICCURR=0
*** Let's assume for now that we can actually call neBEM if needed.
       BEMSET=.TRUE.
*** Default discretisation: current element target size.
       DISDEF=REAL(BEMTGT)
*** Set the prompt.
       CALL INPPRM('Solids','ADD-NOPRINT')
       IF(STDSTR('INPUT'))PRINT *,' ====== CELSOL INPUT   : Please'//
     -      ' enter the solids, terminate with a blank line.'
*** Read a line.
10     CONTINUE
       CALL INPWRD(NWORD)
       CALL INPSTR(1,1,STRING,NC)
*** If empty, leave the routine.
       IF(NWORD.EQ.0)THEN
            IF(.NOT.BEMSET)PRINT *,' ------ CELSOL MESSAGE : Not'//
     -           ' enough data has been entered for neBEM.'
            CALL INPPRM(' ','BACK-PRINT')
            RETURN
*** Could be an attempt to leave the section
       ELSEIF(STRING(1:1).EQ.'&')THEN
            PRINT *,' !!!!!! CELSOL WARNING : You can not'//
     -           ' leave the section here ; line is ignored.'
            GOTO 10
*** Could be a cylinder.
       ELSEIF(INPCMP(1,'CYL#INDER')+INPCMP(1,'WIRE').NE.0)THEN
*   Default parameters.
            XDIR=0
            YDIR=0
            ZDIR=1
            AROT=-PI/4
            IMAT=0
            AUXTYP='?'
            IF(INPCMP(1,'WIRE').NE.0)THEN
                 N=-1
            ELSE
                 N=0
            ENDIF
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
            DIS2=DISDEF
            DIS3=DISDEF
            LTLID=.TRUE.
            LBLID=.TRUE.
            LRMEAN=.FALSE.
*   Required parameters.
            LRAD=.FALSE.
            LPOS=.FALSE.
            LSIZ=.FALSE.
*   Read the parameters.
            INEXT=2
            DO 20 I=2,NWORD
            IF(I.LT.INEXT)GOTO 20
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Direction.
            ELSEIF(INPCMP(I,'DIR#ECTION').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XDIR,0.0)
                      CALL INPRDR(I+2,YDIR,0.0)
                      CALL INPRDR(I+3,ZDIR,0.0)
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Radius.
            ELSEIF(INPCMP(I,'R#ADIUS').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           R=AUX1
                           LRAD=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Radius not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Half-length.
            ELSEIF(INPCMP(I,'HALF-#LENGTH').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           ZSIZ=AUX1
                           LSIZ=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Half-length not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Rotation.
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'ROT#ATE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      AROT=AUX1*PI/180
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Number of points: -1 = thin-wire, 0 = automatic, 2 = square
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'WIRE').NE.0)THEN
                 N=-1
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'N').NE.0)THEN
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDI(I+1,NR,-1)
                      IF(NR.LE.1)THEN
                           CALL INPMSG(I+1,'Should be > 1.')
                      ELSE
                           N=NR
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Lids and other options.
            ELSEIF(INPCMP(I,'TOP-LID').NE.0)THEN
                 LTLID=.TRUE.
            ELSEIF(INPCMP(I,'NOTOP-LID')+
     -           INPCMP(I,'NO-TOP-LID').NE.0)THEN
                 LTLID=.FALSE.
            ELSEIF(INPCMP(I,'BOT#TOM-LID').NE.0)THEN
                 LBLID=.TRUE.
            ELSEIF(INPCMP(I,'NOBOT#TOM-LID')+
     -           INPCMP(I,'NO-BOT#TOM-LID').NE.0)THEN
                 LBLID=.FALSE.
            ELSEIF(INPCMP(I,'LID#S').NE.0)THEN
                 LTLID=.TRUE.
                 LBLID=.TRUE.
            ELSEIF(INPCMP(I,'NOLID#S')+INPCMP(I,'NO-LID#S').NE.0)THEN
                 LTLID=.FALSE.
                 LBLID=.FALSE.
            ELSEIF(INPCMP(I,'MEAN-R#ADIUS').NE.0)THEN
                 LRMEAN=.TRUE.
            ELSEIF(INPCMP(I,'OUT#ER-R#ADIUS').NE.0)THEN
                 LRMEAN=.FALSE.
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                      LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'CH#ARGE')+INPCMP(I,'Q').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                      DIS2=-1.0
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                                DIS2=DISAUX
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIS#CRETISATION-LID-TOP')+
     -           INPCMP(I,'DIS#CRETISATION-TOP-#LID')+
     -           INPCMP(I,'TOP-#DISCRETISATION')+
     -           INPCMP(I,'TOP-#LID-#DISCRETISATION')+
     -           INPCMP(I,'LID-TOP-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIS#CRETISATION-LID-BOT#TOM')+
     -           INPCMP(I,'DIS#CRETISATION-BOT#TOM-#LID')+
     -           INPCMP(I,'BOT#TOM-#DISCRETISATION')+
     -           INPCMP(I,'BOT#TOM-#LID-#DISCRETISATION')+
     -           INPCMP(I,'LID-BOT#TOM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS2=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS2=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(1,'CYL#INDER').NE.0.AND.
     -           INPCMP(I,'DIS#CRETISATION-BODY')+
     -           INPCMP(I,'BODY-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
20          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LRAD.AND.LSIZ.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+24.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; cylinder not stored.'
            ELSEIF(LPOS.AND.LRAD.AND.LSIZ)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=1
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=R
                 CBUF(ICCURR+2)=ZSIZ
                 CBUF(ICCURR+3)=XPOS
                 CBUF(ICCURR+4)=YPOS
                 CBUF(ICCURR+5)=ZPOS
                 CBUF(ICCURR+6)=XDIR
                 CBUF(ICCURR+7)=YDIR
                 CBUF(ICCURR+8)=ZDIR
                 CBUF(ICCURR+9)=DBLE(N)
*   Compute rotation angles.
                 IF(XDIR**2+YDIR**2.LE.0)THEN
                      PHI=0
                      IF(ZDIR.GT.0)THEN
                           THETA=0
                      ELSE
                           THETA=PI
                      ENDIF
                 ELSE
                      PHI=ATAN2(YDIR,XDIR)
                      THETA=ATAN2(SQRT(XDIR**2+YDIR**2),ZDIR)
                 ENDIF
                 CBUF(ICCURR+10)=COS(THETA)
                 CBUF(ICCURR+11)=SIN(THETA)
                 CBUF(ICCURR+12)=COS(PHI)
                 CBUF(ICCURR+13)=SIN(PHI)
*   Rotation angle of the object.
                 CBUF(ICCURR+14)=AROT
*   Boundary conditions
                 CBUF(ICCURR+15)=VOLT
                 CBUF(ICCURR+16)=EPS
                 CBUF(ICCURR+17)=DBLE(IBOUND)
                 CBUF(ICCURR+18)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+19)=DIS1
                 CBUF(ICCURR+20)=DIS2
                 CBUF(ICCURR+21)=DIS3
*   Lids.
                 IF(LTLID)THEN
                      CBUF(ICCURR+22)=1
                 ELSE
                      CBUF(ICCURR+22)=0
                 ENDIF
                 IF(LBLID)THEN
                      CBUF(ICCURR+23)=1
                 ELSE
                      CBUF(ICCURR+23)=0
                 ENDIF
*   Mean radius option.
                 IF(LRMEAN)THEN
                      CBUF(ICCURR+24)=1
                 ELSE
                      CBUF(ICCURR+24)=0
                 ENDIF
*   Store size.
                 ICCURR=ICCURR+24
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Cylinder not'//
     -                ' entered because the position, the radius'//
     -                ' or the length has not been given.'
            ENDIF
*** Cylindrical hole.
       ELSEIF(INPCMP(1,'HOLE').NE.0)THEN
*   Default parameters.
            XDIR=0
            YDIR=0
            ZDIR=1
            IMAT=0
            N=0
            AUXTYP='?'
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
            DIS2=DISDEF
            DIS3=DISDEF
            DIS4=DISDEF
            DIS5=DISDEF
            DIS6=DISDEF
            DIS7=DISDEF
            LRMEAN=.FALSE.
*   Required parameters.
            LRAD1=.FALSE.
            LRAD2=.FALSE.
            LPOS=.FALSE.
            LSIZ=.FALSE.
*   Read the parameters.
            INEXT=2
            DO 60 I=2,NWORD
            IF(I.LT.INEXT)GOTO 60
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Direction.
            ELSEIF(INPCMP(I,'DIR#ECTION').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XDIR,0.0)
                      CALL INPRDR(I+2,YDIR,0.0)
                      CALL INPRDR(I+3,ZDIR,0.0)
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Number of points.
            ELSEIF(INPCMP(I,'N').NE.0)THEN
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDI(I+1,NR,-1)
                      IF(NR.LE.1)THEN
                           CALL INPMSG(I+1,'Should be > 1.')
                      ELSE
                           N=NR
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Radius or radii.
            ELSEIF(INPCMP(I,'R#ADIUS')+
     -           INPCMP(I,'R#ADII').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           R1=AUX1
                           R2=AUX1
                           LRAD1=.TRUE.
                           LRAD2=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Radius not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'UP#PER-R#ADIUS').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           R2=AUX1
                           LRAD2=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Radius not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'LOW#ER-R#ADIUS').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           R1=AUX1
                           LRAD1=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Radius not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Half-lengths.
            ELSEIF(INPCMP(I,'HALF-#LENGTHS')+
     -           INPCMP(I,'HALF-#SIZES').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,0.0)
                      CALL INPRDR(I+2,AUX2,0.0)
                      CALL INPRDR(I+3,AUX3,0.0)
                      IF(AUX1.GT.0.AND.AUX2.GT.0.AND.AUX3.GT.0)THEN
                           XSIZ=AUX1
                           YSIZ=AUX2
                           ZSIZ=AUX3
                           LSIZ=.TRUE.
                      ELSE
                           IF(AUX1.LE.0)CALL INPMSG(I+1,'Is not > 0.')
                           IF(AUX2.LE.0)CALL INPMSG(I+2,'Is not > 0.')
                           IF(AUX3.LE.0)CALL INPMSG(I+3,'Is not > 0.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Options.
            ELSEIF(INPCMP(I,'MEAN-R#ADIUS')+
     -           INPCMP(I,'MEAN-R#ADII').NE.0)THEN
                 LRMEAN=.TRUE.
            ELSEIF(INPCMP(I,'OUT#ER-R#ADIUS')+
     -           INPCMP(I,'OUT#ER-R#ADII').NE.0)THEN
                 LRMEAN=.FALSE.
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                      LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'CH#ARGE')+INPCMP(I,'Q').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                      DIS2=-1.0
                      DIS3=-1.0
                      DIS4=-1.0
                      DIS5=-1.0
                      DIS6=-1.0
                      DIS7=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                                DIS2=DISAUX
                                DIS3=DISAUX
                                DIS4=DISAUX
                                DIS5=DISAUX
                                DIS6=DISAUX
                                DIS7=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-FRONT')+
     -           INPCMP(I,'FRONT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MAX#IMUM')+
     -           INPCMP(I,'X-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BACK')+
     -           INPCMP(I,'BACK-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MIN#IMUM')+
     -           INPCMP(I,'X-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS2=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS2=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-RIGHT')+
     -           INPCMP(I,'RIGHT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MAX#IMUM')+
     -           INPCMP(I,'Y-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-LEFT')+
     -           INPCMP(I,'LEFT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MIN#IMUM')+
     -           INPCMP(I,'Y-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS4=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS4=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-TOP')+
     -           INPCMP(I,'TOP-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Z-MAX#IMUM')+
     -           INPCMP(I,'Z-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS5=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS5=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BOTTOM')+
     -           INPCMP(I,'BOTTOM-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Z-MIN#IMUM')+
     -           INPCMP(I,'Z-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS6=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS6=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-CYL#INDER')+
     -           INPCMP(I,'CYL#INDER-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-HOLE')+
     -           INPCMP(I,'HOLE-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS7=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS7=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
60          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LRAD1.AND.LRAD2.AND.LSIZ.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+28.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; hole not stored.'
            ELSEIF(LPOS.AND.LRAD1.AND.LRAD2.AND.LSIZ)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=2
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=R1
                 CBUF(ICCURR+2)=R2
                 CBUF(ICCURR+3)=XSIZ
                 CBUF(ICCURR+4)=YSIZ
                 CBUF(ICCURR+5)=ZSIZ
                 CBUF(ICCURR+6)=XPOS
                 CBUF(ICCURR+7)=YPOS
                 CBUF(ICCURR+8)=ZPOS
                 CBUF(ICCURR+9)=XDIR
                 CBUF(ICCURR+10)=YDIR
                 CBUF(ICCURR+11)=ZDIR
                 CBUF(ICCURR+12)=DBLE(N)
*   Compute rotation angles.
                 IF(XDIR**2+YDIR**2.LE.0)THEN
                      PHI=0
                      IF(ZDIR.GT.0)THEN
                           THETA=0
                      ELSE
                           THETA=PI
                      ENDIF
                 ELSE
                      PHI=ATAN2(YDIR,XDIR)
                      THETA=ATAN2(SQRT(XDIR**2+YDIR**2),ZDIR)
                 ENDIF
                 CBUF(ICCURR+13)=COS(THETA)
                 CBUF(ICCURR+14)=SIN(THETA)
                 CBUF(ICCURR+15)=COS(PHI)
                 CBUF(ICCURR+16)=SIN(PHI)
*   Boundary conditions
                 CBUF(ICCURR+17)=VOLT
                 CBUF(ICCURR+18)=EPS
                 CBUF(ICCURR+19)=DBLE(IBOUND)
                 CBUF(ICCURR+20)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+21)=DIS1
                 CBUF(ICCURR+22)=DIS2
                 CBUF(ICCURR+23)=DIS3
                 CBUF(ICCURR+24)=DIS4
                 CBUF(ICCURR+25)=DIS5
                 CBUF(ICCURR+26)=DIS6
                 CBUF(ICCURR+27)=DIS7
*   Mean radius option.
                 IF(LRMEAN)THEN
                      CBUF(ICCURR+28)=1
                 ELSE
                      CBUF(ICCURR+28)=0
                 ENDIF
*   Store size.
                 ICCURR=ICCURR+28
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Hole not'//
     -                ' entered because the position, the radii'//
     -                ' or the box size has not been given.'
            ENDIF
*** Could be a box.
       ELSEIF(INPCMP(1,'BOX').NE.0)THEN
*   Default parameters.
            XDIR=0
            YDIR=0
            ZDIR=1
            IMAT=0
            AUXTYP='?'
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
            DIS2=DISDEF
            DIS3=DISDEF
            DIS4=DISDEF
            DIS5=DISDEF
            DIS6=DISDEF
*   Required parameters.
            LSIZ=.FALSE.
            LPOS=.FALSE.
*   Read the parameters.
            INEXT=2
            DO 40 I=2,NWORD
            IF(I.LT.INEXT)GOTO 40
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Direction.
            ELSEIF(INPCMP(I,'DIR#ECTION').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XDIR,0.0)
                      CALL INPRDR(I+2,YDIR,0.0)
                      CALL INPRDR(I+3,ZDIR,0.0)
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Half-lengths.
            ELSEIF(INPCMP(I,'HALF-#LENGTHS')+
     -           INPCMP(I,'HALF-#SIZES').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,0.0)
                      CALL INPRDR(I+2,AUX2,0.0)
                      CALL INPRDR(I+3,AUX3,0.0)
                      IF((AUX1.EQ.0.AND.AUX2.EQ.0).OR.
     -                     (AUX1.EQ.0.AND.AUX3.EQ.0).OR.
     -                     (AUX2.EQ.0.AND.AUX3.EQ.0))THEN
                           CALL INPMSG(I+1,'Only one may be = 0.')
                           CALL INPMSG(I+2,'Only one may be = 0.')
                           CALL INPMSG(I+3,'Only one may be = 0.')
                      ELSEIF(AUX1.GE.0.AND.AUX2.GE.0.AND.AUX3.GE.0)THEN
                           XSIZ=AUX1
                           YSIZ=AUX2
                           ZSIZ=AUX3
                           LSIZ=.TRUE.
                      ELSE
                           IF(AUX1.LE.0)CALL INPMSG(I+1,'Is not >= 0.')
                           IF(AUX2.LE.0)CALL INPMSG(I+2,'Is not >= 0.')
                           IF(AUX3.LE.0)CALL INPMSG(I+3,'Is not >= 0.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                      LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'CH#ARGE')+INPCMP(I,'Q').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                      DIS2=-1.0
                      DIS3=-1.0
                      DIS4=-1.0
                      DIS5=-1.0
                      DIS6=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                                DIS2=DISAUX
                                DIS3=DISAUX
                                DIS4=DISAUX
                                DIS5=DISAUX
                                DIS6=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-FRONT')+
     -           INPCMP(I,'FRONT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MAX#IMUM')+
     -           INPCMP(I,'X-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BACK')+
     -           INPCMP(I,'BACK-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MIN#IMUM')+
     -           INPCMP(I,'X-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS2=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS2=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-RIGHT')+
     -           INPCMP(I,'RIGHT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MAX#IMUM')+
     -           INPCMP(I,'Y-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-LEFT')+
     -           INPCMP(I,'LEFT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MIN#IMUM')+
     -           INPCMP(I,'Y-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS4=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS4=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-TOP')+
     -           INPCMP(I,'TOP-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Z-MAX#IMUM')+
     -           INPCMP(I,'Z-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS5=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS5=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BOTTOM')+
     -           INPCMP(I,'BOTTOM-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Z-MIN#IMUM')+
     -           INPCMP(I,'Z-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS6=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS6=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
40          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LSIZ.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+23.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; box not stored.'
            ELSEIF(LPOS.AND.LSIZ)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=3
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=XSIZ
                 CBUF(ICCURR+2)=YSIZ
                 CBUF(ICCURR+3)=ZSIZ
                 CBUF(ICCURR+4)=XPOS
                 CBUF(ICCURR+5)=YPOS
                 CBUF(ICCURR+6)=ZPOS
                 CBUF(ICCURR+7)=XDIR
                 CBUF(ICCURR+8)=YDIR
                 CBUF(ICCURR+9)=ZDIR
*   Compute rotation angles.
                 IF(XDIR**2+YDIR**2.LE.0)THEN
                      PHI=0
                      IF(ZDIR.GT.0)THEN
                           THETA=0
                      ELSE
                           THETA=PI
                      ENDIF
                 ELSE
                      PHI=ATAN2(YDIR,XDIR)
                      THETA=ATAN2(SQRT(XDIR**2+YDIR**2),ZDIR)
                 ENDIF
                 CBUF(ICCURR+10)=COS(THETA)
                 CBUF(ICCURR+11)=SIN(THETA)
                 CBUF(ICCURR+12)=COS(PHI)
                 CBUF(ICCURR+13)=SIN(PHI)
*   Boundary conditions
                 CBUF(ICCURR+14)=VOLT
                 CBUF(ICCURR+15)=EPS
                 CBUF(ICCURR+16)=DBLE(IBOUND)
                 CBUF(ICCURR+17)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+18)=DIS1
                 CBUF(ICCURR+19)=DIS2
                 CBUF(ICCURR+20)=DIS3
                 CBUF(ICCURR+21)=DIS4
                 CBUF(ICCURR+22)=DIS5
                 CBUF(ICCURR+23)=DIS6
*   Store size
                 ICCURR=ICCURR+23
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Box not'//
     -                ' entered because the position or the size'//
     -                ' has not been given.'
            ENDIF
*** Could also be sphere.
       ELSEIF(INPCMP(1,'SPHERE').NE.0)THEN
*   Required parameters.
            LRAD=.FALSE.
            LPOS=.FALSE.
            N=0
            IMAT=0
            AUXTYP='?'
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
*   Read the parameters.
            INEXT=2
            DO 50 I=2,NWORD
            IF(I.LT.INEXT)GOTO 50
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Radius.
            ELSEIF(INPCMP(I,'R#ADIUS').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           R=AUX1
                           LRAD=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Radius not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Number of points.
            ELSEIF(INPCMP(I,'N').NE.0)THEN
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDI(I+1,NR,-1)
                      IF(NR.LE.2)THEN
                           CALL INPMSG(I+1,'Should be > 2.')
                      ELSE
                           N=NR
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                     LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'CH#ARGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
50          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LRAD.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+10.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; sphere not stored.'
            ELSEIF(LPOS.AND.LRAD)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=4
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=R
                 CBUF(ICCURR+2)=XPOS
                 CBUF(ICCURR+3)=YPOS
                 CBUF(ICCURR+4)=ZPOS
                 CBUF(ICCURR+5)=DBLE(N)
*   Boundary conditions
                 CBUF(ICCURR+6)=VOLT
                 CBUF(ICCURR+7)=EPS
                 CBUF(ICCURR+8)=DBLE(IBOUND)
                 CBUF(ICCURR+9)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+10)=DIS1
*   Store size
                 ICCURR=ICCURR+10
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Sphere not'//
     -                ' entered because the position or the radius'//
     -                ' has not been given.'
            ENDIF
*** Could be a Toblerone.
       ELSEIF(INPCMP(1,'TOBLER#ONE')+INPCMP(1,'RIDGE')+
     -      INPCMP(1,'ROOF').NE.0)THEN
*   Default parameters.
            XDIR=0
            YDIR=0
            ZDIR=1
            IMAT=0
            AUXTYP='?'
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
            DIS2=DISDEF
            DIS3=DISDEF
            DIS4=DISDEF
            DIS5=DISDEF
*   Required parameters.
            LNOTCH=.FALSE.
            LPOS=.FALSE.
            LSIZ=.FALSE.
*   Read the parameters.
            INEXT=2
            DO 30 I=2,NWORD
            IF(I.LT.INEXT)GOTO 30
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Direction.
            ELSEIF(INPCMP(I,'DIR#ECTION').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XDIR,0.0)
                      CALL INPRDR(I+2,YDIR,0.0)
                      CALL INPRDR(I+3,ZDIR,0.0)
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Notch.
            ELSEIF(INPCMP(I,'NOTCH').NE.0.OR.
     -           INPCMP(I,'RIDGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0)THEN
                      CALL INPRDR(I+1,XNOTCH,0.0)
                      CALL INPRDR(I+2,ZNOTCH,0.0)
                      IF(ZNOTCH.GT.0)THEN
                           LNOTCH=.TRUE.
                      ELSE
                           CALL INPMSG(I,'Ridge height not > 0.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+3
*   Half-lengths.
            ELSEIF(INPCMP(I,'HALF-#LENGTHS')+
     -           INPCMP(I,'HALF-#SIZES').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,0.0)
                      CALL INPRDR(I+2,AUX2,0.0)
                      IF(AUX1.GT.0.AND.AUX2.GT.0)THEN
                           XSIZ=AUX1
                           YSIZ=AUX2
                           LSIZ=.TRUE.
                      ELSE
                           IF(AUX1.LE.0)CALL INPMSG(I+1,'Is not > 0.')
                           IF(AUX2.LE.0)CALL INPMSG(I+2,'Is not > 0.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+3
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                      LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'CH#ARGE')+INPCMP(I,'Q').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                      DIS2=-1.0
                      DIS3=-1.0
                      DIS4=-1.0
                      DIS5=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                                DIS2=DISAUX
                                DIS3=DISAUX
                                DIS4=DISAUX
                                DIS5=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-FRONT')+
     -           INPCMP(I,'FRONT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MAX#IMUM')+
     -           INPCMP(I,'X-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BACK')+
     -           INPCMP(I,'BACK-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-X-MIN#IMUM')+
     -           INPCMP(I,'X-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS2=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS2=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-RIGHT')+
     -           INPCMP(I,'RIGHT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MAX#IMUM')+
     -           INPCMP(I,'Y-MAX#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-LEFT')+
     -           INPCMP(I,'LEFT-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Y-MIN#IMUM')+
     -           INPCMP(I,'Y-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS4=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS4=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-FLOOR')+
     -           INPCMP(I,'FLOOR-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-Z-MIN#IMUM')+
     -           INPCMP(I,'Z-MIN#IMUM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS5=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS5=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
30          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LSIZ.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+23.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; ridge not stored.'
            ELSEIF(LPOS.AND.LSIZ.AND.LNOTCH)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=5
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=XSIZ
                 CBUF(ICCURR+2)=YSIZ
                 CBUF(ICCURR+3)=ZNOTCH
                 CBUF(ICCURR+4)=XPOS
                 CBUF(ICCURR+5)=YPOS
                 CBUF(ICCURR+6)=ZPOS
                 CBUF(ICCURR+7)=XDIR
                 CBUF(ICCURR+8)=YDIR
                 CBUF(ICCURR+9)=ZDIR
*   Compute rotation angles.
                 IF(XDIR**2+YDIR**2.LE.0)THEN
                      PHI=0
                      IF(ZDIR.GT.0)THEN
                           THETA=0
                      ELSE
                           THETA=PI
                      ENDIF
                 ELSE
                      PHI=ATAN2(YDIR,XDIR)
                      THETA=ATAN2(SQRT(XDIR**2+YDIR**2),ZDIR)
                 ENDIF
                 CBUF(ICCURR+10)=COS(THETA)
                 CBUF(ICCURR+11)=SIN(THETA)
                 CBUF(ICCURR+12)=COS(PHI)
                 CBUF(ICCURR+13)=SIN(PHI)
*   x-location of the notch.
                 CBUF(ICCURR+14)=XNOTCH
*   Boundary conditions
                 CBUF(ICCURR+15)=VOLT
                 CBUF(ICCURR+16)=EPS
                 CBUF(ICCURR+17)=DBLE(IBOUND)
                 CBUF(ICCURR+18)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+19)=DIS1
                 CBUF(ICCURR+20)=DIS2
                 CBUF(ICCURR+21)=DIS3
                 CBUF(ICCURR+22)=DIS4
                 CBUF(ICCURR+23)=DIS5
*   Store size.
                 ICCURR=ICCURR+23
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Ridge not'//
     -                ' entered because the position, the radius'//
     -                ' or the length has not been given.'
            ENDIF
*** Could be a extrusion.
       ELSEIF(INPCMP(1,'EXT#RUSION').NE.0)THEN
*   Default parameters.
            XDIR=0
            YDIR=0
            ZDIR=1
            IMAT=0
            AUXTYP='?'
            NPROF=0
            VOLT=0
            CHARGE=0
            EPS=0
            IBOUND=0
            LVOLT=.FALSE.
            LCHA=.FALSE.
            LEPS=.FALSE.
            DIS1=DISDEF
            DIS2=DISDEF
            DIS3=DISDEF
            LTLID=.TRUE.
            LBLID=.TRUE.
            LRMEAN=.FALSE.
            IORI=0
*   Required parameters.
            LPOS=.FALSE.
            LSIZ=.FALSE.
            LEPROF=.FALSE.
*   Read the parameters.
            INEXT=2
            DO 70 I=2,NWORD
            IF(I.LT.INEXT)GOTO 70
*   Centre.
            IF(INPCMP(I,'CEN#TRE')+INPCMP(I,'CEN#TER').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XPOS,0.0)
                      CALL INPRDR(I+2,YPOS,0.0)
                      CALL INPRDR(I+3,ZPOS,0.0)
                      LPOS=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Direction.
            ELSEIF(INPCMP(I,'DIR#ECTION').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPCHK(I+2,2,IFAIL2)
                 CALL INPCHK(I+3,2,IFAIL3)
                 IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.IFAIL3.EQ.0)THEN
                      CALL INPRDR(I+1,XDIR,0.0)
                      CALL INPRDR(I+2,YDIR,0.0)
                      CALL INPRDR(I+3,ZDIR,0.0)
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+4
*   Half-length.
            ELSEIF(INPCMP(I,'HALF-#LENGTH').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           ZSIZ=AUX1
                           LSIZ=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Half-length not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
*   Profile.
            ELSEIF(INPCMP(I,'PRO#FILE').NE.0)THEN
                 NPROF=0
                 XPRMIN=0
                 IPRMIN=0
                 DO 80 J=I+1,NWORD,2
                 IF(  (INPTYP(J)  .EQ.1.OR.INPTYP(J  ).EQ.2).AND.
     -                (INPTYP(J+1).EQ.1.OR.INPTYP(J+1).EQ.2))THEN
                      IF(NPROF+1.GT.MXEDGE)THEN
                           PRINT *,' !!!!!! CELSOL WARNING : Profile'//
     -                          ' has more points than can be stored.'
                           LEPROF=.FALSE.
                           GOTO 90
                      ENDIF
                      CALL INPCHK(J,  2,IFAIL1)
                      CALL INPCHK(J+1,2,IFAIL2)
                      NPROF=NPROF+1
                      CALL INPRDR(J,  AUX1,0.0)
                      CALL INPRDR(J+1,AUX2,0.0)
                      XPROF(NPROF)=AUX1
                      YPROF(NPROF)=AUX2
                      ZPROF(NPROF)=0
                      INEXT=J+2
                      IF((NPROF.EQ.1).OR.
     -                     (NPROF.GT.1.AND.XPRMIN.LT.XPROF(NPROF)))THEN
                           IPRMIN=NPROF
                           XPRMIN=XPROF(NPROF)
                      ENDIF
                 ELSEIF(INPTYP(J).EQ.1.OR.INPTYP(J).EQ.2)THEN
                      CALL INPMSG(I,'Number outside profile.')
                 ENDIF
 80              CONTINUE
                 IF(NPROF.GE.3.AND.IPRMIN.GT.0)THEN
                      CALL PLACHK(NPROF,XPROF,YPROF,ZPROF,IFAIL1)
                      IF(IFAIL1.NE.0)THEN
                           PRINT *,' !!!!!! CELSOL WARNING : Profile'//
     -                          ' is not a proper curve; rejected.'
                           LEPROF=.FALSE.
                      ELSE
                           LEPROF=.TRUE.
                      ENDIF
                 ELSE
                      PRINT *,' !!!!!! CELSOL WARNING : Profile'//
     -                     ' has too few points; rejected.'
                      LEPROF=.FALSE.
                 ENDIF
 90              CONTINUE
                 IF(LEPROF)THEN
                      DET=(XPROF(1+MOD(IPRMIN,NPROF))-XPROF(IPRMIN))*
     -                    (YPROF(1+MOD(IPRMIN+1,NPROF))-YPROF(IPRMIN))-
     -                    (XPROF(1+MOD(IPRMIN+1,NPROF))-XPROF(IPRMIN))*
     -                    (YPROF(1+MOD(IPRMIN,NPROF))-YPROF(IPRMIN))
                      IF(DET.LT.0)THEN
                         IORI=-1
                      ELSEIF(DET.GT.0)THEN
                         IORI=+1
                      ELSE
                         PRINT *,' !!!!!! CELSOL WARNING : Unable to'//
     -                        ' determine profile orientation;'//
     -                        ' assuming it is clockwise.'
                         IORI=-1
                      ENDIF
                 ENDIF
*   Lids and other options.
            ELSEIF(INPCMP(I,'TOP-LID').NE.0)THEN
                 LTLID=.TRUE.
            ELSEIF(INPCMP(I,'NOTOP-LID')+
     -           INPCMP(I,'NO-TOP-LID').NE.0)THEN
                 LTLID=.FALSE.
            ELSEIF(INPCMP(I,'BOT#TOM-LID').NE.0)THEN
                 LBLID=.TRUE.
            ELSEIF(INPCMP(I,'NOBOT#TOM-LID')+
     -           INPCMP(I,'NO-BOT#TOM-LID').NE.0)THEN
                 LBLID=.FALSE.
            ELSEIF(INPCMP(I,'LID#S').NE.0)THEN
                 LTLID=.TRUE.
                 LBLID=.TRUE.
            ELSEIF(INPCMP(I,'NOLID#S')+INPCMP(I,'NO-LID#S').NE.0)THEN
                 LTLID=.FALSE.
                 LBLID=.FALSE.
            ELSEIF(INPCMP(I,'MEAN-R#ADIUS').NE.0)THEN
                 LRMEAN=.TRUE.
            ELSEIF(INPCMP(I,'OUT#ER-R#ADIUS').NE.0)THEN
                 LRMEAN=.FALSE.
*   Material.
            ELSEIF(INPCMP(I,'CON#DUCTOR')+
     -           INPCMP(I,'CON#DUCTOR-1').NE.0)THEN
                 IMAT=1
            ELSEIF(INPCMP(I,'CON#DUCTOR-2').NE.0)THEN
                 IMAT=2
            ELSEIF(INPCMP(I,'CON#DUCTOR-3').NE.0)THEN
                 IMAT=3
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM')+
     -           INPCMP(I,'DIEL#ECTRICUM-1').NE.0)THEN
                 IMAT=11
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-2').NE.0)THEN
                 IMAT=12
            ELSEIF(INPCMP(I,'DIEL#ECTRICUM-3').NE.0)THEN
                 IMAT=13
*   Potential, dielectric constant, other boundary conditions.
            ELSEIF(INPCMP(I,'V#OLTAGE').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,VOLT,0.0)
                      LVOLT=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'CH#ARGE')+INPCMP(I,'Q').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,CHARGE,0.0)
                      LCHA=.TRUE.
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'EPS#ILON').NE.0)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(I+1,AUX1,-1.0)
                      IF(AUX1.GT.0)THEN
                           EPS=AUX1
                           LEPS=.TRUE.
                      ELSE
                           CALL INPMSG(I+1,'Epsilon is not positive.')
                      ENDIF
                 ELSE
                      CALL INPMSG(I,'Arguments not valid.')
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'PARA#LLEL-#FIELD').NE.0)THEN
                 IBOUND=6
            ELSEIF(INPCMP(I,'PERP#ENDICULAR-#FIELD').NE.0)THEN
                 IBOUND=7
            ELSEIF(INPCMP(I,'FLOAT#ING-#CONDUCTOR').NE.0)THEN
                 IBOUND=3
*   Label.
            ELSEIF(INPCMP(I,'LAB#EL')+INPCMP(I,'TYPE').NE.0)THEN
                 CALL INPSTR(I+1,I+1,AUXTYP,NCAUX)
                 IF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',AUXTYP).EQ.
     -                0)THEN
                      CALL INPMSG(1,'The label must be a letter.')
                      AUXTYP='?'
                 ENDIF
                 INEXT=I+2
*   Discretisation
            ELSEIF(INPCMP(I,'DIS#CRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                      DIS2=-1.0
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                                DIS2=DISAUX
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-LID-TOP')+
     -           INPCMP(I,'DIS#CRETISATION-TOP-#LID')+
     -           INPCMP(I,'TOP-#DISCRETISATION')+
     -           INPCMP(I,'TOP-#LID-#DISCRETISATION')+
     -           INPCMP(I,'LID-TOP-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS1=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS1=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-LID-BOT#TOM')+
     -           INPCMP(I,'DIS#CRETISATION-BOT#TOM-#LID')+
     -           INPCMP(I,'BOT#TOM-#DISCRETISATION')+
     -           INPCMP(I,'BOT#TOM-#LID-#DISCRETISATION')+
     -           INPCMP(I,'LID-BOT#TOM-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS2=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS2=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
            ELSEIF(INPCMP(I,'DIS#CRETISATION-BODY')+
     -           INPCMP(I,'BODY-#DISCRETISATION')+
     -           INPCMP(I,'DIS#CRETISATION-PRO#FILE')+
     -           INPCMP(I,'PRO#FILE-#DISCRETISATION').NE.0)THEN
                 IF(I+1.GT.NWORD)THEN
                      CALL INPMSG(I,'Argument missing.')
                 ELSEIF(INPCMP(I+1,'AUTO#MATIC').NE.0)THEN
                      DIS3=-1.0
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      IF(IFAIL1.EQ.0)THEN
                           CALL INPRDR(I+1,DISAUX,DISDEF)
                           IF(DISAUX.GT.0)THEN
                                DIS3=DISAUX
                           ELSE
                                CALL INPMSG(I+1,
     -                               'Discretisation not > 0')
                           ENDIF
                      ELSE
                           CALL INPMSG(I,'Arguments not valid.')
                      ENDIF
                 ENDIF
                 INEXT=I+2
*   Other things are not known.
            ELSE
                 CALL INPMSG(I,'Not a known keyword.')
            ENDIF
70          CONTINUE
*   Print error messages.
            CALL INPERR
*   Check compatibility of the options.
            IF(.NOT.(LVOLT.OR.LCHA.OR.LEPS.OR.IBOUND.GT.0))THEN
                 BEMSET=.FALSE.
            ELSEIF(LVOLT.AND.
     -           (LCHA.OR.LEPS.OR.IBOUND.EQ.6.OR.IBOUND.EQ.3.OR.
     -           (IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Voltage boundary'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LCHA.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Charge surface'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(LEPS.AND.(IBOUND.EQ.6.OR.IBOUND.EQ.7.OR.
     -           IBOUND.EQ.3.OR.(IMAT.GE.1.AND.IMAT.LE.10)))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric medium'//
     -                ' with incompatible attributes; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.6.AND.IMAT.GT.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Parallel field'//
     -                ' symmetry on a volume; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF(IBOUND.EQ.7.AND.(IMAT.GE.11.AND.IMAT.LE.20))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Perpendicular'//
     -                ' field on a dielectric; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.1.AND.IMAT.LE.10).AND..NOT.
     -           (LVOLT.OR.LCHA.OR.IBOUND.EQ.3))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Conductor without'//
     -                ' suitable boundary conditions; BEM disabled.'
                 BEMSET=.FALSE.
            ELSEIF((IMAT.GE.11.AND.IMAT.LE.20).AND..NOT.LEPS)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Dielectric without'//
     -                ' epsilon; BEM disabled.'
                 BEMSET=.FALSE.
*   Otherwise complete the boundary conditions.
            ELSEIF(IBOUND.EQ.0.AND.LVOLT)THEN
                 IBOUND=1
            ELSEIF(IBOUND.EQ.0.AND.LCHA.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=5
            ELSEIF(IBOUND.EQ.0.AND.LCHA)THEN
                 IBOUND=2
            ELSEIF(IBOUND.EQ.0.AND.
     -           (LEPS.OR.(IMAT.GE.11.AND.IMAT.LE.20)))THEN
                 IBOUND=4
            ELSEIF(IBOUND.EQ.0)THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Unexpected'//
     -                ' solid classification.'
            ENDIF
*   Complete materials if appropriate.
            IF(IMAT.EQ.0.AND.(LVOLT.OR.
     -           IBOUND.EQ.3.OR.IBOUND.EQ.7))IMAT=1
            IF(IMAT.EQ.0.AND.(LEPS.OR.LCHA.OR.IBOUND.EQ.5))IMAT=11
*   Enter in the conductor table.
            IF(LPOS.AND.LEPROF.AND.LSIZ.AND.
     -           (NSOLID+1.GT.MXSOLI.OR.ICCURR+24.GT.MXSBUF))THEN
                 PRINT *,' !!!!!! CELSOL WARNING : Solids table'//
     -                ' is full; extrusion not stored.'
            ELSEIF(LPOS.AND.LEPROF.AND.LSIZ)THEN
                 NSOLID=NSOLID+1
                 ISTART(NSOLID)=ICCURR
                 ISOLTP(NSOLID)=6
                 ISOLMT(NSOLID)=IMAT
                 SOLTYP(NSOLID)=AUXTYP
                 CBUF(ICCURR+1)=DBLE(IORI)
                 CBUF(ICCURR+2)=ZSIZ
                 CBUF(ICCURR+3)=XPOS
                 CBUF(ICCURR+4)=YPOS
                 CBUF(ICCURR+5)=ZPOS
                 CBUF(ICCURR+6)=XDIR
                 CBUF(ICCURR+7)=YDIR
                 CBUF(ICCURR+8)=ZDIR
                 CBUF(ICCURR+9)=DBLE(NPROF)
*   Compute rotation angles.
                 IF(XDIR**2+YDIR**2.LE.0)THEN
                      PHI=0
                      IF(ZDIR.GT.0)THEN
                           THETA=0
                      ELSE
                           THETA=PI
                      ENDIF
                 ELSE
                      PHI=ATAN2(YDIR,XDIR)
                      THETA=ATAN2(SQRT(XDIR**2+YDIR**2),ZDIR)
                 ENDIF
                 CBUF(ICCURR+10)=COS(THETA)
                 CBUF(ICCURR+11)=SIN(THETA)
                 CBUF(ICCURR+12)=COS(PHI)
                 CBUF(ICCURR+13)=SIN(PHI)
*   Boundary conditions
                 CBUF(ICCURR+15)=VOLT
                 CBUF(ICCURR+16)=EPS
                 CBUF(ICCURR+17)=DBLE(IBOUND)
                 CBUF(ICCURR+18)=CHARGE
*   Discretisation.
                 CBUF(ICCURR+19)=DIS1
                 CBUF(ICCURR+20)=DIS2
                 CBUF(ICCURR+21)=DIS3
*   Lids.
                 IF(LTLID)THEN
                      CBUF(ICCURR+22)=1
                 ELSE
                      CBUF(ICCURR+22)=0
                 ENDIF
                 IF(LBLID)THEN
                      CBUF(ICCURR+23)=1
                 ELSE
                      CBUF(ICCURR+23)=0
                 ENDIF
*   Profile.
                 DO 100 I=1,NPROF
                 CBUF(ICCURR+23+2*I-1)=XPROF(I)
                 CBUF(ICCURR+23+2*I)  =YPROF(I)
 100             CONTINUE
*   Store size.
                 ICCURR=ICCURR+23+2*NPROF
*   Or warn that some element is missing.
            ELSE
                 PRINT *,' !!!!!! CELSOL WARNING : Extrusion not'//
     -                ' entered because the position, the profile'//
     -                ' or the length has not been given.'
            ENDIF
*** Other things are not known.
       ELSE
            CALL INPSTR(1,1,STRING,NC)
            PRINT *,' !!!!!! CELSOL WARNING : Shape '//STRING(1:NC)//
     -           ' is not known; ignored.'
       ENDIF
*** Read the next line.
       GOTO 10
       END
CDECK  ID>, CELSPR.
       SUBROUTINE CELSPR
*-----------------------------------------------------------------------
*   CELSPR - Prints an overview of the solids.
*   (Last changed on 13/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER I,NCYL,NHOLE,NBOX,NSPHER,NTOBL,NEXT,
     -      NC1,NC2,NC3,NC4,NC5,NC6,
     -      NC7,NC8,NC9,NC10,NC11,NC12,NC13,NC14,NC15,NC16,NC17,NC18,
     -      NC19,NC20,NC21,NC22,NC23,NC24,NCNUM
       CHARACTER*30 MAT,AUX1,AUX2,AUX3,AUX4,AUX5,AUX6,AUX7,AUX8,AUX9,
     -      AUX10,AUX11,AUX12,AUX13,AUX14,AUX15,AUX16,AUX17,AUX18,AUX19,
     -      AUX20,AUX21,AUX22,AUX23,AUX24,AUXNUM
       DOUBLE PRECISION QVOL
*** See whether there are any solids.
       IF(NSOLID.LT.1)THEN
            WRITE(LUNOUT,'(''  There are currently no solids.'')')
            RETURN
       ELSE
            WRITE(LUNOUT,'(/''  SOLIDS'')')
       ENDIF
*** Count the various types of solids.
       NCYL=0
       NHOLE=0
       NBOX=0
       NSPHER=0
       NTOBL=0
       NEXT=0
       DO 10 I=1,NSOLID
       IF(ISOLTP(I).EQ.1)THEN
            NCYL=NCYL+1
       ELSEIF(ISOLTP(I).EQ.2)THEN
            NHOLE=NHOLE+1
       ELSEIF(ISOLTP(I).EQ.3)THEN
            NBOX=NBOX+1
       ELSEIF(ISOLTP(I).EQ.4)THEN
            NSPHER=NSPHER+1
       ELSEIF(ISOLTP(I).EQ.5)THEN
            NTOBL=NTOBL+1
       ELSEIF(ISOLTP(I).EQ.6)THEN
            NEXT=NEXT+1
       ELSE
            PRINT *,' !!!!!! CELSPR WARNING : Found a solid of'//
     -           ' unknown type ',ISOLTP(I),'; ignored.'
       ENDIF
10     CONTINUE
*** Print the cylinders.
       IF(NCYL.GE.1)THEN
            WRITE(LUNOUT,'(/''  Cylinders:'')')
            DO 20 I=1,NSOLID
            IF(ISOLTP(I).NE.1)GOTO 20
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+1)),2,AUX1,NC1,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+2)),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+3)),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+4)),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+5)),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+6)),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+7)),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+8)),2,AUX8,NC8,'LEFT')
            IF(NINT(CBUF(ISTART(I)+9)).EQ.0)THEN
                 AUX9='Default'
                 NC9=7
            ELSEIF(NINT(CBUF(ISTART(I)+9)).EQ.-1)THEN
                 AUX9='Thin wire approximation'
                 NC9=23
            ELSE
                 CALL OUTFMT(REAL(NINT(CBUF(ISTART(I)+9))),2,
     -                AUX9,NC9,'LEFT')
            ENDIF
            CALL OUTFMT(REAL(CBUF(ISTART(I)+15)),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+16)),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+18)),2,AUX12,NC12,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+19)),2,AUX13,NC13,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+20)),2,AUX14,NC14,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+21)),2,AUX15,NC15,'LEFT')
            IF(CBUF(ISTART(I)+19).LT.0)THEN
                AUX13='automatic'
                NC13=9
            ENDIF
            IF(CBUF(ISTART(I)+20).LT.0)THEN
                AUX14='automatic'
                NC14=9
            ENDIF
            IF(CBUF(ISTART(I)+21).LT.0)THEN
                AUX15='automatic'
                NC15=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX16='Not labeled'
                 NC16=11
            ELSE
                 AUX16=SOLTYP(I)
                 NC16=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -               ''Radius:         '',A,'' cm''/
     -           10X,''Half-length:    '',A,'' cm''/
     -           10X,''Centre:         ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Axis:           ('',A,'', '',A,'', '',A,'')''/
     -           10X,''Material:       '',A/
     -           10X,''Corners:        '',A/
     -           10X,''Discretisation: '',A,'' cm (top), '',
     -               A,'' cm (bottom), '',A,'' cm (body)''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX1(1:NC1),AUX2(1:NC2),AUX3(1:NC3),
     -           AUX4(1:NC4),AUX5(1:NC5),AUX6(1:NC6),AUX7(1:NC7),
     -           AUX8(1:NC8),MAT,AUX9(1:NC9),
     -           AUX13(1:NC13),AUX14(1:NC14),AUX15(1:NC15),AUX16(1:NC16)
            IF(NINT(CBUF(ISTART(I)+17)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX10(1:NC10)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX11(1:NC11)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX11(1:NC11),AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+17)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
20          CONTINUE
       ENDIF
*** Print the holes.
       IF(NHOLE.GE.1)THEN
            WRITE(LUNOUT,'(/''  Holes:'')')
            DO 30 I=1,NSOLID
            IF(ISOLTP(I).NE.2)GOTO 30
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 1)),2,AUX1, NC1, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 2)),2,AUX2, NC2, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 3)),2,AUX3, NC3, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 4)),2,AUX4, NC4, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 5)),2,AUX5, NC5, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 6)),2,AUX6, NC6, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 7)),2,AUX7, NC7, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 8)),2,AUX8, NC8, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+ 9)),2,AUX9, NC9, 'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+10)),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+11)),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(NINT(CBUF(ISTART(I)+12))),2,AUX12,NC12,
     -           'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+17)),2,AUX13,NC13,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+18)),2,AUX14,NC14,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+20)),2,AUX15,NC15,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+21)),2,AUX16,NC16,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+22)),2,AUX17,NC17,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+23)),2,AUX18,NC18,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+24)),2,AUX19,NC19,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+25)),2,AUX20,NC20,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+26)),2,AUX21,NC21,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+27)),2,AUX22,NC22,'LEFT')
            IF(CBUF(ISTART(I)+21).LT.0)THEN
                AUX16='automatic'
                NC16=9
            ENDIF
            IF(CBUF(ISTART(I)+22).LT.0)THEN
                AUX17='automatic'
                NC17=9
            ENDIF
            IF(CBUF(ISTART(I)+23).LT.0)THEN
                AUX18='automatic'
                NC18=9
            ENDIF
            IF(CBUF(ISTART(I)+24).LT.0)THEN
                AUX19='automatic'
                NC19=9
            ENDIF
            IF(CBUF(ISTART(I)+25).LT.0)THEN
                AUX20='automatic'
                NC20=9
            ENDIF
            IF(CBUF(ISTART(I)+26).LT.0)THEN
                AUX21='automatic'
                NC21=9
            ENDIF
            IF(CBUF(ISTART(I)+27).LT.0)THEN
                AUX22='automatic'
                NC22=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX23='Not labeled'
                 NC23=11
            ELSE
                 AUX23=SOLTYP(I)
                 NC23=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -           ''Radii:          '',A,'' cm and '',A,'' cm''/
     -           10X,''Half-lengths:   ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Centre:         ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Axis:           ('',A,'', '',A,'', '',A,'')''/
     -           10X,''Material:       '',A/
     -           10X,''Corners:        '',A/
     -           10X,''Discretisation: '',
     -                A,''/'',A,'' cm (front/back), '',
     -                A,''/'',A,'' cm (right/left),''/26X,
     -                A,''/'',A,'' cm (top/bottom), '',
     -                A,'' cm (hole)''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX1(1:NC1),AUX2(1:NC2),AUX3(1:NC3),
     -           AUX4(1:NC4),AUX5(1:NC5),AUX6(1:NC6),AUX7(1:NC7),
     -           AUX8(1:NC8),AUX9(1:NC9),AUX10(1:NC10),AUX11(1:NC11),
     -           MAT,AUX12(1:NC12),
     -           AUX16(1:NC16),AUX17(1:NC17),AUX18(1:NC18),
     -           AUX19(1:NC19),AUX20(1:NC20),AUX21(1:NC21),
     -           AUX22(1:NC22),AUX23(1:NC23)
            IF(NINT(CBUF(ISTART(I)+19)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX13(1:NC13)
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX15(1:NC15)
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX14(1:NC14)
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX14(1:NC14),AUX15(1:NC15)
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+19)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+19)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
30          CONTINUE
       ENDIF
*** Print the boxes.
       IF(NBOX.GE.1)THEN
            WRITE(LUNOUT,'(/''  Boxes:'')')
            DO 40 I=1,NSOLID
            IF(ISOLTP(I).NE.3)GOTO 40
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+1)),2,AUX1,NC1,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+2)),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+3)),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+4)),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+5)),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+6)),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+7)),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+8)),2,AUX8,NC8,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+9)),2,AUX9,NC9,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+14)),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+15)),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+17)),2,AUX12,NC12,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+18)),2,AUX13,NC13,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+19)),2,AUX14,NC14,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+20)),2,AUX15,NC15,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+21)),2,AUX16,NC16,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+22)),2,AUX17,NC17,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+23)),2,AUX18,NC18,'LEFT')
            IF(CBUF(ISTART(I)+18).LT.0)THEN
                AUX13='automatic'
                NC13=9
            ENDIF
            IF(CBUF(ISTART(I)+19).LT.0)THEN
                AUX14='automatic'
                NC14=9
            ENDIF
            IF(CBUF(ISTART(I)+20).LT.0)THEN
                AUX15='automatic'
                NC15=9
            ENDIF
            IF(CBUF(ISTART(I)+21).LT.0)THEN
                AUX16='automatic'
                NC16=9
            ENDIF
            IF(CBUF(ISTART(I)+22).LT.0)THEN
                AUX17='automatic'
                NC17=9
            ENDIF
            IF(CBUF(ISTART(I)+23).LT.0)THEN
                AUX18='automatic'
                NC18=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX19='Not labeled'
                 NC19=11
            ELSE
                 AUX19=SOLTYP(I)
                 NC19=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -               ''Half-lengths:   ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Centre:         ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Axis:           ('',A,'', '',A,'', '',A,'')''/
     -           10X,''Material:       '',A/
     -           10X,''Discretisation: '',
     -                A,''/'',A,'' cm (front/back), '',
     -                A,''/'',A,'' cm (right/left), '',
     -                A,''/'',A,'' cm (top/bottom)''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX1(1:NC1),AUX2(1:NC2),AUX3(1:NC3),
     -           AUX4(1:NC4),AUX5(1:NC5),AUX6(1:NC6),AUX7(1:NC7),
     -           AUX8(1:NC8),AUX9(1:NC9),MAT,
     -           AUX13(1:NC13),AUX14(1:NC14),AUX15(1:NC15),
     -           AUX16(1:NC16),AUX17(1:NC17),AUX18(1:NC18),
     -           AUX19(1:NC19)
            IF(NINT(CBUF(ISTART(I)+16)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX10(1:NC10)
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX11(1:NC11)
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX11(1:NC11),AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+16)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+16)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
40          CONTINUE
       ENDIF
*** Print the spheres.
       IF(NSPHER.GE.1)THEN
            WRITE(LUNOUT,'(/''  Spheres:'')')
            DO 50 I=1,NSOLID
            IF(ISOLTP(I).NE.4)GOTO 50
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+1)),2,AUX1,NC1,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+2)),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+3)),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+4)),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(NINT(CBUF(ISTART(I)+5))),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+6)),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+7)),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+9)),2,AUX8,NC8,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+10)),2,AUX9,NC9,'LEFT')
            IF(CBUF(ISTART(I)+10).LT.0)THEN
                AUX9='automatic'
                NC9=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX16='Not labeled'
                 NC16=11
            ELSE
                 AUX16=SOLTYP(I)
                 NC16=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -               ''Radius:         '',A,'' cm''/
     -           10X,''Centre:         ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Material:       '',A/
     -           10X,''Corners:        '',A/
     -           10X,''Discretisation: '',A,'' cm''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX1(1:NC1),AUX2(1:NC2),AUX3(1:NC3),
     -           AUX4(1:NC4),MAT,AUX5(1:NC5),AUX9(1:NC9),AUX16(1:NC16)
            IF(NINT(CBUF(ISTART(I)+8)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX6(1:NC6)
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX8(1:NC8)
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX7(1:NC7)
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX7(1:NC7),AUX8(1:NC8)
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+8)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+8)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
50          CONTINUE
       ENDIF
*** Print the Ridge's.
       IF(NTOBL.GE.1)THEN
            WRITE(LUNOUT,'(/''  Ridges:'')')
            DO 60 I=1,NSOLID
            IF(ISOLTP(I).NE.5)GOTO 60
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+1)),2,AUX1,NC1,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+2)),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+3)),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+4)),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+5)),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+6)),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+7)),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+8)),2,AUX8,NC8,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+9)),2,AUX9,NC9,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+14)),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+15)),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+16)),2,AUX12,NC12,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+18)),2,AUX13,NC13,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+19)),2,AUX14,NC14,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+20)),2,AUX15,NC15,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+21)),2,AUX16,NC16,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+22)),2,AUX17,NC17,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+23)),2,AUX18,NC18,'LEFT')
            IF(CBUF(ISTART(I)+19).LT.0)THEN
                AUX14='automatic'
                NC14=9
            ENDIF
            IF(CBUF(ISTART(I)+20).LT.0)THEN
                AUX15='automatic'
                NC15=9
            ENDIF
            IF(CBUF(ISTART(I)+21).LT.0)THEN
                AUX16='automatic'
                NC16=9
            ENDIF
            IF(CBUF(ISTART(I)+22).LT.0)THEN
                AUX17='automatic'
                NC17=9
            ENDIF
            IF(CBUF(ISTART(I)+23).LT.0)THEN
                AUX18='automatic'
                NC18=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX19='Not labeled'
                 NC19=11
            ELSE
                 AUX19=SOLTYP(I)
                 NC19=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -               ''Base half-size: ('',A,'', '',A,'') cm''/
     -           10X,''Ridge (x,z):    ('',A,'', '',A,'') cm''/
     -           10X,''Axis:           ('',A,'', '',A,'', '',A,'')''/
     -           10X,''Material:       '',A/
     -           10X,''Discretisation: '',
     -                A,''/'',A,'' cm (front/back), '',
     -                A,''/'',A,'' cm (right/left), '',
     -                A,'' cm (floor)''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX1(1:NC1),AUX2(1:NC2),
     -           AUX10(1:NC10),AUX3(1:NC3),
     -           AUX7(1:NC7),AUX8(1:NC8),AUX9(1:NC9),
     -           MAT,
     -           AUX14(1:NC14),AUX15(1:NC15),AUX16(1:NC16),
     -           AUX17(1:NC17),AUX18(1:NC18),
     -           AUX19(1:NC19)
            IF(NINT(CBUF(ISTART(I)+17)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX11(1:NC11)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX13(1:NC13)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX12(1:NC12),AUX13(1:NC13)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+17)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
60          CONTINUE
       ENDIF
*** Print the extrusions.
       IF(NEXT.GE.1)THEN
            WRITE(LUNOUT,'(/''  Extrusions:'')')
            DO 70 I=1,NSOLID
            IF(ISOLTP(I).NE.6)GOTO 70
            IF(ISOLMT(I).EQ.1)THEN
                 MAT='Conductor 1'
            ELSEIF(ISOLMT(I).EQ.2)THEN
                 MAT='Conductor 2'
            ELSEIF(ISOLMT(I).EQ.3)THEN
                 MAT='Conductor 3'
            ELSEIF(ISOLMT(I).EQ.11)THEN
                 MAT='Dielectricum 1'
            ELSEIF(ISOLMT(I).EQ.12)THEN
                 MAT='Dielectricum 2'
            ELSEIF(ISOLMT(I).EQ.13)THEN
                 MAT='Dielectricum 3'
            ELSE
                 MAT='# Unknown'
            ENDIF
            CALL OUTFMT(REAL(I),2,AUXNUM,NCNUM,'LEFT')
            IF(CBUF(ISTART(I)+1).LT.0)THEN
                 AUX1='Clockwise'
                 NC1=9
            ELSE
                 AUX1='Counter-clockwise'
                 NC1=17
            ENDIF
            CALL OUTFMT(REAL(CBUF(ISTART(I)+2)),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+3)),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+4)),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+5)),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+6)),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+7)),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+8)),2,AUX8,NC8,'LEFT')
            CALL OUTFMT(REAL(NINT(CBUF(ISTART(I)+9))),2,AUX9,NC9,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+15)),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+16)),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+18)),2,AUX12,NC12,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+19)),2,AUX13,NC13,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+20)),2,AUX14,NC14,'LEFT')
            CALL OUTFMT(REAL(CBUF(ISTART(I)+21)),2,AUX15,NC15,'LEFT')
            IF(CBUF(ISTART(I)+19).LT.0)THEN
                AUX13='automatic'
                NC13=9
            ENDIF
            IF(CBUF(ISTART(I)+20).LT.0)THEN
                AUX14='automatic'
                NC14=9
            ENDIF
            IF(CBUF(ISTART(I)+21).LT.0)THEN
                AUX15='automatic'
                NC15=9
            ENDIF
            IF(SOLTYP(I).EQ.'?')THEN
                 AUX16='Not labeled'
                 NC16=11
            ELSE
                 AUX16=SOLTYP(I)
                 NC16=1
            ENDIF
            WRITE(LUNOUT,'(2X,A1,A4,'' - '',
     -               ''Half-length:    '',A,'' cm''/
     -           10X,''Centre:         ('',A,'', '',A,'', '',A,'') cm''/
     -           10X,''Axis:           ('',A,'', '',A,'', '',A,'')''/
     -           10X,''Material:       '',A/
     -           10X,''Profile nodes:  '',A/
     -           10X,''Orientation:    '',A/
     -           10X,''Discretisation: '',A,'' cm (top), '',
     -               A,'' cm (bottom), '',A,'' cm (body)''/
     -           10X,''Label:          '',A)')
     -           SOLTYP(I),AUXNUM(1:4),
     -           AUX2(1:NC2),AUX3(1:NC3),
     -           AUX4(1:NC4),AUX5(1:NC5),AUX6(1:NC6),AUX7(1:NC7),
     -           AUX8(1:NC8),MAT,AUX9(1:NC9),AUX1(1:NC1),
     -           AUX13(1:NC13),AUX14(1:NC14),AUX15(1:NC15),AUX16(1:NC16)
            IF(NINT(CBUF(ISTART(I)+17)).EQ.0)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''None specified.'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.1)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor held at '',A,'' V'')')
     -                AUX10(1:NC10)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.2)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Conductor with a surface charge'',
     -                '' of '',A,'' Qe'')') AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.3)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged floating conductor'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.4)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Uncharged dielectric medium'',
     -                '' with dielectric constant '',A)') AUX11(1:NC11)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.5)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Dielectric medium with'',
     -                '' epsilon '',A,'' and charge '',A,'' Qe'')')
     -                AUX11(1:NC11),AUX12(1:NC12)
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.6)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field parallel'',
     -                '' with the surface'')')
            ELSEIF(NINT(CBUF(ISTART(I)+17)).EQ.7)THEN
                 WRITE(LUNOUT,'(10X,''Boundary:       '',
     -                ''Symmetry: E-field perpendicular'',
     -                '' to the surface'')')
            ELSE
                 WRITE(LUNOUT,'(10X,''Boundary:       Unknown.'')')
            ENDIF
            IF(NINT(CBUF(ISTART(I)+17)).NE.0)THEN
                 CALL BEMVOQ(I,QVOL)
                 CALL OUTFMT(REAL(QVOL*1.0D12),2,AUX24,NC24,'LEFT')
                 WRITE(LUNOUT,'(10X,''Surface charge: '',A,'' pC.'')')
     -                AUX24(1:NC24)
            ENDIF
70          CONTINUE
       ENDIF
       END
CDECK  ID>, CELBEM.
       SUBROUTINE CELBEM
*-----------------------------------------------------------------------
*   CELBEM - neBEM parameters.
*   VARIABLES :
*   (Last changed on 15/ 4/12.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       CHARACTER*20 AUX1,AUX2,AUX3,AUX4,AUX5,AUX6,AUX7,AUX8,AUX9,AUX10,
     -      AUX11,AUX12,AUX13
       INTEGER INPCMP,INPTYP,INEXT,I,NWORD,IFAIL1,IAUX,
     -      NC1,NC2,NC3,NC4,NC5,NC6,NC7,NC8,NC9,NC10,NC11,NC12,NC13
       REAL AUX
       EXTERNAL INPCMP,INPTYP
*** Get the number of words on the line.
       CALL INPNUM(NWORD)
*** If there is only one argument.
       IF(NWORD.EQ.1)THEN
            CALL OUTFMT(REAL(BEMQTH),2,AUX1,NC1,'LEFT')
            CALL OUTFMT(REAL(BEMSSC),2,AUX2,NC2,'LEFT')
            CALL OUTFMT(REAL(BEMTGT),2,AUX3,NC3,'LEFT')
            CALL OUTFMT(REAL(NBEMMN),2,AUX4,NC4,'LEFT')
            CALL OUTFMT(REAL(NBEMMX),2,AUX5,NC5,'LEFT')
            CALL OUTFMT(REAL(NBEMPX),2,AUX6,NC6,'LEFT')
            CALL OUTFMT(REAL(NBEMPY),2,AUX11,NC11,'LEFT')
            CALL OUTFMT(REAL(NBEMPZ),2,AUX12,NC12,'LEFT')
            CALL OUTFMT(REAL(BEMNEW),2,AUX7,NC7,'LEFT')
            CALL OUTFMT(REAL(BEMINV),2,AUX8,NC8,'LEFT')
            CALL OUTFMT(REAL(BEMEPD),2,AUX9,NC9,'LEFT')
            CALL OUTFMT(REAL(BEMEPA),2,AUX10,NC10,'LEFT')
            CALL OUTFMT(REAL(BEMSLV),2,AUX13,NC13,'LEFT')
            WRITE(LUNOUT,'(
     -         ''  CURRENT NEBEM PARAMETERS:''//
     -         ''  Panel quality threshold:              '',A/
     -         ''  Panel size threshold (relative):      '',A/
     -         ''  Target element size:                  '',A,'' cm''/
     -         ''  Distance tolerance:                   '',A,'' cm''/
     -         ''  Angular tolerance:                    '',A,'' rad''/
     -         ''  Minimum number of elements per panel: '',A/
     -         ''  Maximum number of elements per panel: '',A/
     -         ''  Periodic repetitions in x, y, z:      '',A,1X,A,1X,A/
     -         ''  New model (1) or reload model (0):    '',A/
     -         ''  Keep (1) inverted matrix or not (0):  '',A/
     -         ''  Matrix inversion LU (0) or SVD (1):   '',A)')
     -         AUX1(1:NC1),AUX2(1:NC2),AUX3(1:NC3),AUX9(1:NC9),
     -         AUX10(1:NC10),AUX4(1:NC4),
     -         AUX5(1:NC5),AUX6(1:NC6),AUX11(1:NC11),AUX12(1:NC12),
     -         AUX7(1:NC7),AUX8(1:NC8),AUX13(1:NC13)
*** Otherwise decode the argument list.
       ELSE
            INEXT=2
            DO 10 I=2,NWORD
            IF(I.LT.INEXT)GOTO 10
*   Quality threshold.
            IF(INPCMP(I,'Q#UALITY-THR#ESHOLD').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.
     -                (INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2))THEN
                      CALL INPMSG(I,'Should have a number as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      CALL INPRDR(I+1,AUX,REAL(BEMQTH))
                      IF(AUX.GT.1)THEN
                           BEMQTH=AUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Size threshold.
            ELSEIF(INPCMP(I,'SIZE-THR#ESHOLD').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.
     -                (INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2))THEN
                      CALL INPMSG(I,'Should have a number as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      CALL INPRDR(I+1,AUX,REAL(BEMSSC))
                      IF(AUX.GT.0)THEN
                           BEMSSC=AUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 0')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Target size.
            ELSEIF(INPCMP(I,'TARG#ET-ELEM#ENT-#SIZE')+
     -           INPCMP(I,'TARG#ET-#SIZE').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.
     -                (INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2))THEN
                      CALL INPMSG(I,'Should have a number as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      CALL INPRDR(I+1,AUX,REAL(BEMTGT))
                      IF(AUX.GT.0)THEN
                           BEMTGT=AUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 0')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Minimum and maximum number of elements.
            ELSEIF(INPCMP(I,'MIN#IMUM-#NUMBER-#OF-#ELEMENTS')+
     -           INPCMP(I,'MIN#IMUM-#ELEMENTS').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,NBEMMN)
                      IF(IAUX.GE.1)THEN
                           NBEMMN=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
            ELSEIF(INPCMP(I,'MAX#IMUM-#NUMBER-#OF-#ELEMENTS')+
     -           INPCMP(I,'MAX#IMUM-#ELEMENTS').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,NBEMMX)
                      IF(IAUX.GE.1)THEN
                           NBEMMX=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Periodic copies.
            ELSEIF(INPCMP(I,'PER#IODIC-COPIES').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,1+(NBEMPX+NBEMPY+NBEMPZ)/3)
                      IF(IAUX.GE.1)THEN
                           NBEMPX=IAUX
                           NBEMPY=IAUX
                           NBEMPZ=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
            ELSEIF(INPCMP(I,'X-PER#IODIC-COPIES').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,NBEMPX)
                      IF(IAUX.GE.1)THEN
                           NBEMPX=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
            ELSEIF(INPCMP(I,'Y-PER#IODIC-COPIES').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,NBEMPY)
                      IF(IAUX.GE.1)THEN
                           NBEMPY=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
            ELSEIF(INPCMP(I,'Z-PER#IODIC-COPIES').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.INPTYP(I+1).NE.1)THEN
                      CALL INPMSG(I,'Should have a integer as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,1,IFAIL1)
                      CALL INPRDI(I+1,IAUX,NBEMPZ)
                      IF(IAUX.GE.1)THEN
                           NBEMPZ=IAUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 1')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Start a new model.
            ELSEIF(INPCMP(I,'NEW-#MODEL').NE.0)THEN
                 BEMNEW=1
            ELSEIF(INPCMP(I,'REUSE-#MODEL').NE.0)THEN
                 BEMNEW=0
*   Store inverted matrix ?
            ELSEIF(INPCMP(I,'KEEP-INV#ERTED-#MATRIX').NE.0)THEN
                 BEMINV=1
            ELSEIF(INPCMP(I,'NOKEEP-INV#ERTED-#MATRIX').NE.0)THEN
                 BEMINV=0
*   Angular tolerance.
            ELSEIF(INPCMP(I,'ANG#ULAR-TOL#ERANCE')+
     -           INPCMP(I,'ANG#LE-TOL#ERANCE')+
     -           INPCMP(I,'TOL#ERANCE-ANG#LE')+
     -           INPCMP(I,'TOL#ERANCE-ANG#ULAR').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.
     -                (INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2))THEN
                      CALL INPMSG(I,'Should have a number as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      CALL INPRDR(I+1,AUX,REAL(BEMEPA))
                      IF(AUX.GT.0)THEN
                           BEMEPA=AUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 0')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Distance tolerance.
            ELSEIF(INPCMP(I,'DIS#TANCE-TOL#ERANCE')+
     -           INPCMP(I,'TOL#ERANCE-DIS#TANCE').NE.0)THEN
                 IF(I+1.GT.NWORD.OR.
     -                (INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2))THEN
                      CALL INPMSG(I,'Should have a number as arg.')
                      INEXT=I+1
                 ELSE
                      CALL INPCHK(I+1,2,IFAIL1)
                      CALL INPRDR(I+1,AUX,REAL(BEMEPD))
                      IF(AUX.GT.0)THEN
                           BEMEPD=AUX
                      ELSE
                           CALL INPMSG(I+1,
     -                          'Value not at least equal to 0')
                      ENDIF
                      INEXT=I+2
                 ENDIF
*   Dump primitives.
            ELSEIF(INPCMP(I,'DUMP-#PRIMITIVES').NE.0)THEN
                 LBDUMP=.TRUE.
            ELSEIF(INPCMP(I,'NODUMP-#PRIMITIVES').NE.0)THEN
                 LBDUMP=.FALSE.
*   Solving method.
            ELSEIF(INPCMP(I,'LU-#INVERSION').NE.0)THEN
                 BEMSLV=0
            ELSEIF(INPCMP(I,'SVD-#INVERSION')+
     -             INPCMP(I,'S#INGULAR-V#ALUE-D#ECOMPOSITION-'//
     -                      '#INVERSION').NE.0)THEN
                 BEMSLV=1
*   Anything else.
            ELSE
                 CALL INPMSG(I,'Not a valid keyword; ignored. ')
            ENDIF
10          CONTINUE
       ENDIF
       CALL INPERR
*** Sort range if needed.
       IF(NBEMMN.GT.NBEMMX)THEN
            IAUX=NBEMMN
            NBEMMN=NBEMMX
            NBEMMX=IAUX
       ENDIF
       END
CDECK  ID>, CELSEL.
       SUBROUTINE CELSEL(SOURCE)
*-----------------------------------------------------------------------
*   CELSEL - This routine allows the user to change his set of readout
*            electrodes. Wires can be identified by means of their label
*            and by their number. Planes and tubes by their label only.
*   (Last changed on 13/ 1/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       LOGICAL OPEN,OK,EXIST,FOUND,SOLSEL,
     -      USED(MXWIRE+5+MXWMAP+10*MXPSTR+MXSOLI)
       INTEGER NC,I,J,K,L,II,IREAD,NWORD,IFAIL,INEXT,
     -      NPRIM,NPRIMJ,PRIML(MXPLAN),PRIMLJ(MXPLAN)
       CHARACTER*(MXINCH) TEXT,WRONG
       CHARACTER*(*) SOURCE
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE CELSEL ///'
*** Obtain the argument string.
       IF(SOURCE.EQ.' ')THEN
            CALL INPSTR(2,MXWORD,TEXT,NC)
            CALL INPNUM(NWORD)
       ELSE
            TEXT=SOURCE
            NC=LEN(SOURCE)
            NWORD=2
            IF(NC.GT.MXINCH)THEN
                 PRINT *,' !!!!!! CELSEL WARNING : Electrode'//
     -                ' selection too long; truncated.'
                 NC=MXINCH
            ENDIF
       ENDIF
*** If the string is blank, only print the current settings.
       IF(NWORD.LE.1)THEN
            CALL CELPRC(LUNOUT,0)
            RETURN
       ENDIF
*** Clear any BEM weighting fields that may exist.
       DO 500 I=1,NSW
       IF(BEMSET)THEN
            print *,' Deleting weighting field ',IWFBEM(I)
            CALL BEMDLW(IWFBEM(I))
       ENDIF
       IWFBEM(I)=-1
500    CONTINUE
*** Initialse INDSW, the logicals and the error logging array.
       OK=.TRUE.
       WRONG='                              '//
     -       '                              '
       DO 10 I=1,MXWIRE
       USED(I)=.FALSE.
       INDSW(I)=0
10     CONTINUE
       DO 160 I=1,5
       USED(MXWIRE+I)=.FALSE.
       INDPLA(I)=0
       DO 340 J=1,MXPSTR
       INDST1(I,J)=0
       INDST2(I,J)=0
       USED(MXWIRE+5+MXWMAP+(I-1)*MXPSTR+J)=.FALSE.
       USED(MXWIRE+5+MXWMAP+(I+4)*MXPSTR+J)=.FALSE.
340    CONTINUE
160    CONTINUE
       DO 260 I=1,NWMAP
       USED(MXWIRE+5+I)=.FALSE.
       INDEWS(I)=0
260    CONTINUE
       NSW=0
       DO 170 I=1,MXSOLI
       USED(MXWIRE+5+MXWMAP+10*MXPSTR+I)=.FALSE.
       INDSOL(I)=0
170    CONTINUE
       SOLSEL=.FALSE.
*** Loop over all characters in the string.
       OPEN=.FALSE.
       EXIST=.FALSE.
       INEXT=1
       DO 20 I=1,NC
       IF(I.LT.INEXT)GOTO 20
**  Skip blanks, commas and equal signs (the usual separators),
       IF(INDEX(' ,=',TEXT(I:I)).NE.0)GOTO 20
**  "(" open brackets,
       IF(TEXT(I:I).EQ.'(')THEN
            IF(OPEN)THEN
                 OK=.FALSE.
                 WRONG(I:I)='|'
            ELSE
                 OPEN=.TRUE.
                 NSW=NSW+1
                 EXIST=.FALSE.
            ENDIF
*   ")" close brackets,
       ELSEIF(TEXT(I:I).EQ.')')THEN
            IF(OPEN)THEN
                 OPEN=.FALSE.
                 IF(.NOT.EXIST)NSW=NSW-1
            ELSE
                 OK=.FALSE.
                 WRONG(I:I)='|'
            ENDIF
**  Wire, plane, tube and field map code in numeric form,
       ELSEIF(INDEX('+-0123456789',TEXT(I:I)).NE.0)THEN
            J=I
30          CONTINUE
            J=J+1
            IF(J.LE.NC.AND.INDEX('0123456789',TEXT(J:J)).NE.0)GOTO 30
            CALL INPRIC(TEXT(I:J-1),IREAD,0,IFAIL)
            IF(IFAIL.NE.0.OR.IREAD.LT.-5-MXWMAP.OR.IREAD.GT.NWIRE.OR.
     -           IREAD.EQ.0)THEN
                 WRONG(I:I)='#'
                 OK=.FALSE.
                 INEXT=J
                 GOTO 20
            ENDIF
            IF(IREAD.LT.0)IREAD=MXWIRE-IREAD
            IF(USED(IREAD))THEN
                 OK=.FALSE.
                 WRONG(I:I)='2'
            ELSE
                 IF(.NOT.OPEN.AND.NSW.GE.MXSW)THEN
                      PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                     ' selected more electrodes than the'//
     -                     ' program can store ; increase MXSW.'
                      OK=.FALSE.
                      DO 40 K=I,NC
                      IF(TEXT(K:K).NE.' ')WRONG(K:K)='.'
40                    CONTINUE
                      NSW=MXSW
                      GOTO 100
                 ENDIF
                 IF(IREAD.GE.MXWIRE+6.AND.IREAD.LE.MXWIRE+5+MXWMAP)THEN
                      IF(NWMAP.LT.IREAD-MXWIRE-5)THEN
                           WRONG(I:I)='M'
                           OK=.FALSE.
                      ELSE
                           IF(.NOT.OPEN)NSW=NSW+1
                           INDEWS(IREAD-MXWIRE-5)=NSW
                           USED(IREAD)=.TRUE.
                           EXIST=.TRUE.
                      ENDIF
                 ELSEIF(IREAD.EQ.MXWIRE+5)THEN
                      IF(.NOT.TUBE)THEN
                           WRONG(I:I)='T'
                           OK=.FALSE.
                      ELSE
                           IF(.NOT.OPEN)NSW=NSW+1
                           INDPLA(IREAD-MXWIRE)=NSW
                           USED(IREAD)=.TRUE.
                           EXIST=.TRUE.
                      ENDIF
                 ELSEIF(IREAD.GE.MXWIRE+1.AND.IREAD.LE.MXWIRE+4)THEN
                      IF(.NOT.YNPLAN(IREAD-MXWIRE))THEN
                           WRONG(I:I)='P'
                           OK=.FALSE.
                      ELSE
                           IF(.NOT.OPEN)NSW=NSW+1
                           INDPLA(IREAD-MXWIRE)=NSW
                           USED(IREAD)=.TRUE.
                           EXIST=.TRUE.
                      ENDIF
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      INDSW(IREAD)=NSW
                      USED(IREAD)=.TRUE.
                      EXIST=.TRUE.
                 ENDIF
            ENDIF
            INEXT=J
**  Wire and plane code as a letter,
       ELSEIF(INDEX('ABCDEFGHIJKLMNOPQRSTUVWXYZ',TEXT(I:I)).NE.0)THEN
            FOUND=.FALSE.
*   Check the wires.
            DO 60 J=1,NWIRE
            IF(WIRTYP(J).EQ.TEXT(I:I))THEN
                 EXIST=.TRUE.
                 FOUND=.TRUE.
                 IF(USED(J))THEN
                      OK=.FALSE.
                      WRONG(I:I)='2'
                      GOTO 60
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      IF(NSW.GT.MXSW)THEN
                           PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                          ' selected more electrodes than the'//
     -                          ' program can store ; increase MXSW.'
                           OK=.FALSE.
                           DO 50 K=I,NC
                           IF(TEXT(K:K).NE.' ')WRONG(K:K)='.'
50                         CONTINUE
                           NSW=MXSW
                           GOTO 100
                      ENDIF
                      INDSW(J)=NSW
                      USED(J)=.TRUE.
                 ENDIF
            ENDIF
60          CONTINUE
*   Check the planes and the tube.
            DO 180 J=1,5
            IF(J.LE.4)THEN
                 IF(.NOT.YNPLAN(J))GOTO 180
            ELSE
                 IF(.NOT.TUBE)GOTO 180
            ENDIF
            IF(PLATYP(J).EQ.TEXT(I:I))THEN
                 EXIST=.TRUE.
                 FOUND=.TRUE.
                 IF(USED(MXWIRE+J))THEN
                      OK=.FALSE.
                      WRONG(I:I)='2'
                      GOTO 180
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      IF(NSW.GT.MXSW)THEN
                           PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                          ' selected more electrodes than the'//
     -                          ' program can store ; increase MXSW.'
                           OK=.FALSE.
                           DO 190 K=I,NC
                           IF(TEXT(K:K).NE.' ')WRONG(K:K)='.'
190                        CONTINUE
                           NSW=MXSW
                           GOTO 100
                      ENDIF
                      INDPLA(J)=NSW
                      USED(MXWIRE+J)=.TRUE.
                 ENDIF
            ENDIF
180         CONTINUE
*   Check the strips on the planes and the tube.
            DO 240 J=1,5
            IF(J.LE.4)THEN
                 IF(.NOT.YNPLAN(J))GOTO 240
            ELSE
                 IF(.NOT.TUBE)GOTO 240
            ENDIF
            DO 280 K=1,NPSTR1(J)
            IF(PSLAB1(J,K).EQ.TEXT(I:I))THEN
                 EXIST=.TRUE.
                 FOUND=.TRUE.
                 IF(USED(MXWIRE+5+MXWMAP+(J-1)*MXPSTR+K))THEN
                      OK=.FALSE.
                      WRONG(I:I)='2'
                      GOTO 280
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      IF(NSW.GT.MXSW)THEN
                           PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                          ' selected more electrodes than the'//
     -                          ' program can store ; increase MXSW.'
                           OK=.FALSE.
                           DO 250 L=I,NC
                           IF(TEXT(L:L).NE.' ')WRONG(L:L)='.'
250                        CONTINUE
                           NSW=MXSW
                           GOTO 100
                      ENDIF
                      INDST1(J,K)=NSW
                      USED(MXWIRE+5+MXWMAP+(J-1)*MXPSTR+K)=.TRUE.
                 ENDIF
            ENDIF
280         CONTINUE
            DO 350 K=1,NPSTR2(J)
            IF(PSLAB2(J,K).EQ.TEXT(I:I))THEN
                 EXIST=.TRUE.
                 FOUND=.TRUE.
                 IF(USED(MXWIRE+5+MXWMAP+(J+4)*MXPSTR+K))THEN
                      OK=.FALSE.
                      WRONG(I:I)='2'
                      GOTO 350
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      IF(NSW.GT.MXSW)THEN
                           PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                          ' selected more electrodes than the'//
     -                          ' program can store ; increase MXSW.'
                           OK=.FALSE.
                           DO 360 L=I,NC
                           IF(TEXT(L:L).NE.' ')WRONG(L:L)='.'
360                        CONTINUE
                           NSW=MXSW
                           GOTO 100
                      ENDIF
                      INDST2(J,K)=NSW
                      USED(MXWIRE+5+MXWMAP+(J+4)*MXPSTR+K)=.TRUE.
                 ENDIF
            ENDIF
350         CONTINUE
240         CONTINUE
*   Check the field map.
            DO 270 J=1,NWMAP
            IF(EWSTYP(J).EQ.TEXT(I:I))THEN
                 EXIST=.TRUE.
                 FOUND=.TRUE.
                 IF(USED(MXWIRE+5+J))THEN
                      OK=.FALSE.
                      WRONG(I:I)='2'
                 ELSE
                      IF(.NOT.OPEN)NSW=NSW+1
                      IF(NSW.GT.MXSW)THEN
                           PRINT *,' !!!!!! CELSEL WARNING : You have'//
     -                          ' selected more electrodes than the'//
     -                          ' program can store ; increase MXSW.'
                           OK=.FALSE.
                           DO 210 K=I,NC
                           IF(TEXT(K:K).NE.' ')WRONG(K:K)='.'
210                        CONTINUE
                           NSW=MXSW
                           GOTO 100
                      ENDIF
                      INDEWS(J)=NSW
                      USED(MXWIRE+5+J)=.TRUE.
                 ENDIF
            ENDIF
270         CONTINUE
*   Check the neBEM field generating solids.
            IF(BEMSET)THEN
                 DO 430 J=1,NSOLID
                 IF(SOLTYP(J).EQ.TEXT(I:I))THEN
                      EXIST=.TRUE.
                      FOUND=.TRUE.
                      IF(USED(MXWIRE+5+MXWMAP+10*MXPSTR+J))THEN
                           OK=.FALSE.
                           WRONG(I:I)='2'
                      ELSE
                           IF(.NOT.OPEN)NSW=NSW+1
                           IF(NSW.GT.MXSW)THEN
                                PRINT *,' !!!!!! CELSEL WARNING :'//
     -                               ' More electrodes than can be'//
     -                               ' stored; increase MXSW.'
                                OK=.FALSE.
                                DO 130 K=I,NC
                                IF(TEXT(K:K).NE.' ')WRONG(K:K)='.'
130                             CONTINUE
                                NSW=MXSW
                                GOTO 100
                           ENDIF
                           INDSOL(J)=NSW
                           USED(MXWIRE+5+MXWMAP+10*MXPSTR+J)=.TRUE.
                      ENDIF
                 ENDIF
430              CONTINUE
*   Check the solids, do not assign new groups to these however.
            ELSE
                 DO 150 J=1,NSOLID
                 IF(SOLTYP(J).EQ.TEXT(I:I))THEN
                      FOUND=.TRUE.
                      SOLSEL=.TRUE.
                      INDSOL(J)=-1
                 ENDIF
150              CONTINUE
            ENDIF
*   See that something has been found.
            IF(.NOT.FOUND)THEN
                 OK=.FALSE.
                 WRONG(I:I)='?'
            ENDIF
**  invalid character.
       ELSE
            WRONG(I:I)='*'
            OK=.FALSE.
       ENDIF
*   Next selection character.
20     CONTINUE
*** Match solids and weighting field, if selected.
       DO 290 J=1,NWMAP
       IF(INDEWS(J).NE.0)THEN
            DO 70 I=1,NSOLID
            IF(SOLTYP(I).EQ.EWSTYP(J))THEN
                 IF(INDSOL(I).GT.0.AND.INDSOL(I).NE.INDEWS(J))THEN
                      PRINT *,' !!!!!! CELSEL WARNING : Solid ',I,
     -                     ' matches more than one field map.'
                      OK=.FALSE.
                 ELSE
                      INDSOL(I)=INDEWS(J)
                      SOLSEL=.TRUE.
                 ENDIF
            ENDIF
70          CONTINUE
       ENDIF
290    CONTINUE
*** Check that there are electrodes.
       IF(NSW.EQ.0.AND.SOLSEL)THEN
            PRINT *,' ------ CELSEL MESSAGE : You have only'//
     -           ' selected solids that are not read out.'
       ELSEIF(NSW.EQ.0.AND.JFAIL.EQ.1)THEN
            PRINT *,' !!!!!! CELSEL WARNING : No electrodes found'//
     -           ' that match your selection ; searching for "S".'
*   Consider wires.
            DO 80 I=1,NWIRE
            IF(WIRTYP(I).EQ.'S')THEN
                 NSW=NSW+1
                 INDSW(I)=NSW
            ENDIF
80          CONTINUE
*   Planes and tube.
            DO 200 I=1,5
            IF(PLATYP(I).EQ.'S')THEN
                 NSW=NSW+1
                 INDPLA(I)=NSW
            ENDIF
200         CONTINUE
*   Field map.
            DO 300 I=1,NWMAP
            IF(EWSTYP(I).EQ.'S')THEN
                 NSW=NSW+1
                 INDEWS(I)=NSW
            ENDIF
300         CONTINUE
            IF(NSW.GT.MXSW)NSW=MXSW
            IF(NSW.EQ.0)THEN
                 PRINT *,' !!!!!! CELSEL WARNING : The cell does not'//
     -                ' contain "S" electrodes ; nothing selected.'
                 NSW=0
            ENDIF
       ELSEIF(NSW.EQ.0.AND.JFAIL.EQ.2)THEN
            PRINT *,' !!!!!! CELSEL WARNING : No electrodes found'//
     -           ' that match your selection ; nothing selected.'
       ELSEIF(NSW.EQ.0.AND.JFAIL.EQ.3)THEN
            PRINT *,' !!!!!! CELSEL WARNING : No electrodes found'//
     -           ' that match your selection ; terminating.'
            CALL QUIT
       ENDIF
*** Print an error message if an error occured.
100    CONTINUE
       IF(WRONG(1:NC).NE.' ')WRITE(*,'(''  !!!!!! CELSEL WARNING : An'',
     -      '' error occured in the selection of electrodes''/
     -      9X,''Selection      : '',A/
     -      9X,''Error messages : '',A/
     -      9X,''Error codes    : '',
     -          ''"?" label not found,     "#" number out of range,''/
     -      26X,''"*" invalid character,   "|" unmatched bracket,''/
     -      26X,''"2" referenced twice,    "." (partially) ignored,''/
     -      26X,''"M" no such map,         "P" no such plane,''/
     -      26X,''"T" there is no tube.'')')
     -      TEXT(1:NC),WRONG(1:NC)
*** Print some extra output if the debug option is on/input is blank.
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : Number of'',
     -           '' electrode groups: '',I5)') NSW
*   List wires.
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : The wires have'',
     -           '' been selected as follows:'')')
            DO 120 II=1,NWIRE,4
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (I,WIRTYP(I),INDSW(I),I=II,MIN(II+3,NWIRE))
            DO 110 I=II,MIN(II+3,NWIRE)
            IF(INDSW(I).EQ.0)WRONG(34+(I-II)*13:36+(I-II)*13)='---'
110         CONTINUE
            IF(II+3.GE.NWIRE)WRONG(37+(NWIRE-II)*13:37+(NWIRE-II)*13)=
     -           '.'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
120         CONTINUE
*   List planes and tubes.
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : The planes'',
     -           '' have been selected as follows:'')')
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (I,PLATYP(I),INDPLA(I),I=1,4)
            DO 140 I=1,4
            IF(INDPLA(I).EQ.0)WRONG(21+I*13:23+I*13)='---'
140         CONTINUE
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : The tube'',
     -           '' has been selected as follows:'')')
            WRITE(WRONG,'(25X,I3,'' '',A1,'' - '',I3,''.'')')
     -           1,PLATYP(5),INDPLA(5)
            IF(INDPLA(5).EQ.0)WRONG(34:36)='---'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
*   List strips.
            DO 370 I=1,5
            IF(NPSTR1(I).NE.0)WRITE(LUNOUT,'(''  ++++++ CELSEL'',
     -           '' DEBUG   : The x-y strips of plane '',I3,
     -           '' have been selected as follows:'')') I
            DO 380 II=1,NPSTR1(I),4
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (J,PSLAB1(I,J),INDST1(I,J),J=II,MIN(II+3,NPSTR1(I)))
            DO 390 J=II,MIN(II+3,NPSTR1(I))
            IF(INDST1(I,J).EQ.0)WRONG(34+(J-II)*13:36+(J-II)*13)='---'
390         CONTINUE
            IF(II+3.GE.NPSTR1(I))WRONG(37+(NPSTR1(I)-II)*13:
     -           37+(NPSTR1(I)-II)*13)='.'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
380         CONTINUE
            IF(NPSTR2(I).NE.0)WRITE(LUNOUT,'(''  ++++++ CELSEL'',
     -           '' DEBUG   : The z strips of plane '',I3,
     -           '' have been selected as follows:'')') I
            DO 400 II=1,NPSTR2(I),4
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (J,PSLAB2(I,J),INDST2(I,J),J=II,MIN(II+3,NPSTR2(I)))
            DO 410 J=II,MIN(II+3,NPSTR2(I))
            IF(INDST2(I,J).EQ.0)WRONG(34+(J-II)*13:36+(J-II)*13)='---'
410         CONTINUE
            IF(II+3.GE.NPSTR2(I))WRONG(37+(NPSTR2(I)-II)*13:
     -           37+(NPSTR2(I)-II)*13)='.'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
400         CONTINUE
370         CONTINUE
*   List the field maps.
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : The field'',
     -           '' maps have been selected as follows:'')')
            DO 310 II=1,NWMAP,4
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (I,EWSTYP(I),INDEWS(I),I=II,MIN(II+3,NWMAP))
            DO 320 I=II,MIN(II+3,NWMAP)
            IF(INDEWS(I).EQ.0)WRONG(34+(I-II)*13:36+(I-II)*13)='---'
320         CONTINUE
            IF(II+3.GE.NWMAP)WRONG(37+(NWMAP-II)*13:
     -           37+(NWMAP-II)*13)='.'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
310         CONTINUE
*   List solids.
            WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : The solids'',
     -           '' have been selected as follows:'')')
            DO 220 II=1,NSOLID,4
            WRITE(WRONG,'(25X,4(I3,'' '',A1,'' - '',I3,'', ''))')
     -           (I,SOLTYP(I),INDSOL(I),I=II,MIN(II+3,NSOLID))
            DO 230 I=II,MIN(II+3,NSOLID)
            IF(INDSOL(I).EQ.0)WRONG(34+(I-II)*13:36+(I-II)*13)='---'
230         CONTINUE
            IF(II+3.GE.NSOLID)WRONG(37+(NSOLID-II)*13:
     -           37+(NSOLID-II)*13)='.'
            WRITE(LUNOUT,'(1X,A)') WRONG(1:76)
220         CONTINUE
       ENDIF
*** Request weighting fields.
       IF(BEMSET)THEN
*   Loop over read-out groups.
            DO 510 I=1,NSW
*   Pick up the associated solids.
            NPRIM=0
            DO 520 J=1,NSOLID
            IF(INDSOL(J).EQ.I)THEN
*   Pick up the primitives for the solid.
                 CALL BEMVPR(J,NPRIMJ,PRIMLJ)
                 DO 530 K=1,NPRIMJ
                 NPRIM=NPRIM+1
                 PRIML(NPRIM)=PRIMLJ(K)
530              CONTINUE
            ENDIF
520         CONTINUE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ CELSEL DEBUG   : '',I5,
     -           '' associated primitives:'',
     -           (/26X,20I4))') NPRIM,(PRIML(J),J=1,NPRIM)
*   Request the weighting field for this list of primitives.
            CALL BEMRQW(NPRIM,PRIML,IWFBEM(I))
*   Check the return code.
            IF(IWFBEM(I).LT.0)THEN
                 PRINT *,' !!!!!! CELSEL WARNING : Failure computing'//
     -                ' neBEM weighting field charges; no selected'//
     -                ' electrodes.'
                 NSW=0
            ENDIF
510         CONTINUE
       ENDIF
       END
CDECK  ID>, MAPFM8.
       SUBROUTINE MAPFM8(FMAP,NCMAP,IDATA,IWMAP,IORDER,UNITD,IFAIL)
*-----------------------------------------------------------------------
*   MAPFM8 - Reads a COMSOL 3D map of 1st order tetrahedra
*   (Last changed on 29/ 3/12.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER I,J,K,L,NCMAP,IFAIL,IORDER,IL,IEPS,IAUX,
     -      IH1,IH2,IH3,IH4,IH5,IH6,IH7,IH8,IH9,IH10,IDUM,
     -      IDATA,NTETRA,NPOINT,IWMAP,IMAP(MXMAP,10),IOS
       REAL XP,YP,ZP,VREAD,UNITD,EREAD
       LOGICAL SWITCH
       CHARACTER*(*) FMAP
       CHARACTER*75 LINE
       SAVE NTETRA,NPOINT,IMAP
       DATA NTETRA/0/, NPOINT/0/
**** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE MAPFM8 ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8 DEBUG   : Data = '',
     -      I3,'', IWMAP = '',I3,'', IORDER = '',I3/26X,''File = "'',
     -      A,''"'')') IDATA,IWMAP,IORDER,FMAP(1:NCMAP)
*** Assume that this will fail.
       IFAIL=1
*** Set the number of fields.
       IF(IORDER.LT.1.OR.IORDER.GT.2)
     -      PRINT *,' !!!!!! MAPFM8 WARNING : Invalid order parameter'//
     -      ' received: ',IORDER,'; reading as 1st order.'
*** We will only do Fortran reads, from the start.
       CALL INPSWI('RESTORE')
       REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
       IL=0
*** The first part contains the coordinates, which we skip at first
       CALL PROFLD(2,'Skipping',-1.0)
       CALL PROSTA(2,0.0)
*   Check the first header.
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IL=IL+1
       IF(LINE(1:13).NE.'% Coordinates')THEN
            PRINT *,' !!!!!! MAPFM8 WARNING : The first line of ',
     -           FMAP(1:NCMAP),' does not contain the expected'//
     -           ' COMSOL 3D header; file not read.'
            IFAIL=1
            RETURN
       ENDIF
*   Skip until the elements, counting the number of points.
       SWITCH=.FALSE.
 150   CONTINUE
       NPOINT=0
40     CONTINUE
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IL=IL+1
       IF(LINE(1:10).NE.'% Elements')THEN
            NPOINT=NPOINT+1
            GOTO 40
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8 DEBUG   :'',
     -      '' Expecting '',I5,'' points.'')') NPOINT
*** Read the tetrahedron structure.
       CALL PROFLD(2,'Tetrahedrons',-1.0)
       CALL PROSTA(2,0.0)
*   Read lines with point references, until the next header
       NTETRA=0
70     CONTINUE
       READ(12,'(A40)',END=2000,ERR=2010,IOSTAT=IOS) LINE(1:40)
       IL=IL+1
       IF(LINE(1:40).EQ.' ')GOTO 70
       IF(LINE(1:1).NE.'%')THEN
*   Increment the tetrahedron counter.
            IF(NTETRA+1.GT.MXMAP)THEN
                 PRINT *,' !!!!!! MAPFM8 WARNING : Number of'//
     -                ' tetrahedrons in ',FMAP(1:NCMAP),
     -                ' exceeds compilation limit; file not read.'
                 IFAIL=1
                 RETURN
            ENDIF
            NTETRA=NTETRA+1
*   Decode a block of 8 line
            IF(IORDER.NE.2)THEN
                 READ(LINE,'(BN,4I10)',END=2000,ERR=2010,IOSTAT=IOS)
     -                IH1 ,IH2 ,IH3 ,IH4
                 IH5=0
                 IH6=0
                 IH7=0
                 IH8=0
                 IH9=0
                 IH10=0
            ELSEIF(IORDER.EQ.2.AND.SWITCH)THEN
                 READ(LINE,'(BN,4I10)',END=2000,ERR=2010,IOSTAT=IOS)
     -                IH5 ,IH8 ,IH9 ,IH6
                 DO 50 I=1,7
                 READ(12,'(A40)',END=2000,ERR=2010,IOSTAT=IOS)
     -                LINE(1:40)
                 IL=IL+1
                 IF(LINE(1:40).EQ.' ')GOTO 50
                 IF(I.EQ.1)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IH7 ,IDUM
                 ELSEIF(I.EQ.2)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IH10,IDUM
                 ELSEIF(I.EQ.3)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IDUM
                 ELSEIF(I.EQ.4)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IH1 ,IDUM
                 ELSEIF(I.EQ.5)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IH2
                 ELSEIF(I.EQ.6)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IH3 ,IDUM,IDUM
                 ELSEIF(I.EQ.7)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IH4 ,IDUM,IDUM,IDUM
                 ENDIF
50               CONTINUE
            ELSEIF(IORDER.EQ.2)THEN
                 READ(LINE,'(BN,4I10)',END=2000,ERR=2010,IOSTAT=IOS)
     -                IH5 ,IH8 ,IH6 ,IH9
                 DO 160 I=1,7
                 READ(12,'(A40)',END=2000,ERR=2010,IOSTAT=IOS)
     -                LINE(1:40)
                 IL=IL+1
                 IF(LINE(1:40).EQ.' ')GOTO 160
                 IF(I.EQ.1)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IH7
                 ELSEIF(I.EQ.2)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IH10
                 ELSEIF(I.EQ.3)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IDUM
                 ELSEIF(I.EQ.4)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IDUM,IH1 
                 ELSEIF(I.EQ.5)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IH2 ,IDUM
                 ELSEIF(I.EQ.6)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IH3 ,IDUM,IDUM
                 ELSEIF(I.EQ.7)THEN
                      READ(LINE,'(BN,4I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IH4 ,IDUM,IDUM,IDUM
                 ENDIF
160              CONTINUE
            ENDIF
*   Ensure there is no degeneracy
            IF(  (IORDER.NE.2.AND.(
     -           IH1.EQ.IH2.OR.IH1.EQ.IH3.OR.IH1.EQ.IH4.OR.
     -                         IH2.EQ.IH3.OR.IH2.EQ.IH4.OR.
     -                                       IH3.EQ.IH4)).OR.
     -           (IORDER.EQ.2.AND.(
     -           IH1.EQ.IH2.OR.IH1.EQ.IH3.OR.IH1.EQ.IH4 .OR.
     -           IH1.EQ.IH5.OR.IH1.EQ.IH6.OR.IH1.EQ.IH7 .OR.
     -           IH1.EQ.IH8.OR.IH1.EQ.IH9.OR.IH1.EQ.IH10.OR.
     -                         IH2.EQ.IH3.OR.IH2.EQ.IH4 .OR.
     -           IH2.EQ.IH5.OR.IH2.EQ.IH6.OR.IH2.EQ.IH7 .OR.
     -           IH2.EQ.IH8.OR.IH2.EQ.IH9.OR.IH2.EQ.IH10.OR.
     -                                       IH3.EQ.IH4 .OR.
     -           IH3.EQ.IH5.OR.IH3.EQ.IH6.OR.IH3.EQ.IH7 .OR.
     -           IH3.EQ.IH8.OR.IH3.EQ.IH9.OR.IH3.EQ.IH10.OR.
     -           IH4.EQ.IH5.OR.IH4.EQ.IH6.OR.IH4.EQ.IH7 .OR.
     -           IH4.EQ.IH8.OR.IH4.EQ.IH9.OR.IH4.EQ.IH10.OR.
     -                         IH5.EQ.IH6.OR.IH5.EQ.IH7 .OR.
     -           IH5.EQ.IH8.OR.IH5.EQ.IH9.OR.IH5.EQ.IH10.OR.
     -                                       IH6.EQ.IH7 .OR.
     -           IH6.EQ.IH8.OR.IH6.EQ.IH9.OR.IH6.EQ.IH10.OR.
     -           IH7.EQ.IH8.OR.IH7.EQ.IH9.OR.IH7.EQ.IH10.OR.
     -                         IH8.EQ.IH9.OR.IH8.EQ.IH10.OR.
     -                                       IH9.EQ.IH10)))THEN
                      IF(.NOT.SWITCH.AND.NTETRA.EQ.1)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8'',
     -                        '' DEBUG   : Switching.columns 3-4.'')')
                           SWITCH=.TRUE.
                           REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
                           READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS)
     -                          LINE
                           IL=1
                           GOTO 150
                      ELSE
                           PRINT *,' !!!!!! MAPFM8 WARNING : Element ',
     -                          NTETRA,' in file ',FMAP(1:NCMAP),
     -                          ' is degenerate; file not read.'
                      IFAIL=1
                      RETURN
                 ENDIF
            ENDIF
*   Ensure they all make sense.
            IF(  (IORDER.NE.2.AND.(
     -           IH1.LE.0.OR.IH2.LE.0.OR.IH3.LE.0.OR.IH4.LE.0)).OR.
     -           (IORDER.EQ.2.AND.(
     -           IH1.LE.0.OR.IH2.LE.0.OR.IH3.LE.0.OR.IH4.LE.0.OR.
     -           IH5.LE.0.OR.IH6.LE.0.OR.IH7.LE.0.OR.IH8.LE.0.OR.
     -           IH9.LE.0.OR.IH10.LE.0)))THEN
                 PRINT *,' !!!!!! MAPFM8 WARNING : Invalid point'//
     -                ' reference in ',FMAP(1:NCMAP),'; map not read.'
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8 DEBUG   :'',
     -                '' tetrahedron '',I5/
     -                26X,''Vertices: '',10(2X,I5))')
     -                NTETRA,IH1,IH2,IH3,IH4,IH5,IH6,IH7,IH8,IH9,IH10
                 IFAIL=1
                 RETURN
            ENDIF
*   Store the reference pointers (negative sign for checks).
            IMAP(NTETRA,1) =-IH1
            IMAP(NTETRA,2) =-IH2
            IMAP(NTETRA,3) =-IH3
            IMAP(NTETRA,4) =-IH4
            IMAP(NTETRA,5) =-IH5
            IMAP(NTETRA,6) =-IH6
            IMAP(NTETRA,7) =-IH7
            IMAP(NTETRA,8) =-IH8
            IMAP(NTETRA,9) =-IH9
            IMAP(NTETRA,10)=-IH10
*   Next line
            GOTO 70
       ENDIF
*   Debugging
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8 DEBUG   :'',
     -      '' Found '',I5,'' tetrahedra.'')') NTETRA
*** Read the points filling in the mesh file.
       CALL PROFLD(2,'Rewind',-1.0)
       CALL PROSTA(2,0.0)
       REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
       IL=0
*** Skip vertex reading if this has already been done.
       IF(MAPFLG(1))GOTO 1234
*   Skip the header
       READ(12,'()',END=2000,ERR=2010,IOSTAT=IOS)
       IL=IL+1
*   Loop over the points.
       CALL PROFLD(2,'Vertices',REAL(NPOINT))
       DO 80 I=1,NPOINT
       IF(I.EQ.MAX(1,NPOINT/100)*(I/MAX(1,NPOINT/100)))
     -      CALL PROSTA(2,REAL(I))
*   Read the line.
       READ(12,'(3F25.10)',END=2000,ERR=2010,IOSTAT=IOS) XP,YP,ZP
       IL=IL+1
*   Convert from the COMSOL unit to cm.
       XP=XP*UNITD
       YP=YP*UNITD
       ZP=ZP*UNITD
*   Update the chamber dimensions.
       IF(I.EQ.1)THEN
            XMMIN=XP
            XMMAX=XP
            YMMIN=YP
            YMMAX=YP
            ZMMIN=ZP
            ZMMAX=ZP
       ELSE
            XMMIN=MIN(XMMIN,XP)
            XMMAX=MAX(XMMAX,XP)
            YMMIN=MIN(YMMIN,YP)
            YMMAX=MAX(YMMAX,YP)
            ZMMIN=MIN(ZMMIN,ZP)
            ZMMAX=MAX(ZMMAX,ZP)
       ENDIF
*   Update angular ranges.
       IF(YP.NE.0.OR.ZP.NE.0)THEN
            IF(SETAX)THEN
                 XAMIN=MIN(XAMIN,ATAN2(ZP,YP))
                 XAMAX=MAX(XAMAX,ATAN2(ZP,YP))
            ELSE
                 XAMIN=ATAN2(ZP,YP)
                 XAMAX=ATAN2(ZP,YP)
                 SETAX=.TRUE.
            ENDIF
       ENDIF
       IF(ZP.NE.0.OR.XP.NE.0)THEN
            IF(SETAY)THEN
                 YAMIN=MIN(YAMIN,ATAN2(XP,ZP))
                 YAMAX=MAX(YAMAX,ATAN2(XP,ZP))
            ELSE
                 YAMIN=ATAN2(XP,ZP)
                 YAMAX=ATAN2(XP,ZP)
                 SETAY=.TRUE.
            ENDIF
       ENDIF
       IF(XP.NE.0.OR.YP.NE.0)THEN
            IF(SETAZ)THEN
                 ZAMIN=MIN(ZAMIN,ATAN2(YP,XP))
                 ZAMAX=MAX(ZAMAX,ATAN2(YP,XP))
            ELSE
                 ZAMIN=ATAN2(YP,XP)
                 ZAMAX=ATAN2(YP,XP)
                 SETAZ=.TRUE.
            ENDIF
       ENDIF
*   Find referring tetrahedrons, trace resolved references with sign.
       DO 90 J=1,4
       DO 100 K=1,NTETRA
       IF(I.EQ.ABS(IMAP(K,J)))THEN
            XMAP(K,J)=XP
            YMAP(K,J)=YP
            ZMAP(K,J)=ZP
            IMAP(K,J)=ABS(IMAP(K,J))
       ENDIF
100    CONTINUE
90     CONTINUE
*   Next point.
80     CONTINUE
*   End of reading, check reference resolution.
       CALL PROFLD(2,'Verifying',-1.0)
       CALL PROSTA(2,0.0)
       DO 110 J=1,4
       DO 120 I=1,NTETRA
       IF(IMAP(I,J).LE.0)THEN
            PRINT *,' !!!!!! MAPFM8 WARNING : Unresolved point'//
     -           ' references in mesh ; map rejected.'
            IFAIL=1
            RETURN
       ENDIF
120    CONTINUE
110    CONTINUE
*   Now set the number of elements.
       NMAP=NTETRA
*   Set the flag that the mesh is now defined.
       MAPFLG(1)=.TRUE.
*   Set the element type.
       MAPTYP=12
*** And read the potentials, first skip till we have the header.
1234   CONTINUE
       CALL PROFLD(2,'Skipping',-1.0)
       CALL PROSTA(2,0.0)
140    CONTINUE
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IL=IL+1
       IF(LINE(1:10).NE.'% Data (V)'.AND.
     -    LINE(1:19).NE.'% Data ((V)[1/(V)])'.AND.
     -    LINE(1:14).NE.'% Data (V (V))')GOTO 140
*   Read the list of points with associated field values.
       IF(IDATA.EQ.10)THEN
            CALL PROFLD(2,'Weighting field',REAL(NPOINT))
       ELSE
            CALL PROFLD(2,'Potentials',REAL(NPOINT))
       ENDIF
       DO 10 I=1,NPOINT
       IF(I.EQ.MAX(1,NPOINT/100)*(I/MAX(1,NPOINT/100)))
     -      CALL PROSTA(2,REAL(I))
*   Read the data line.
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IF(INDEX(LINE,'.').EQ.0)THEN
            READ(LINE,'(BN,I25)') IAUX
            VREAD=REAL(IAUX)
       ELSE
            READ(LINE,'(E25.10)') VREAD
       ENDIF
       IL=IL+1
*   Assign the potential to the mesh.
       DO 20 L=1,10
       DO 30 K=1,NTETRA
       IF(ABS(IMAP(K,L)).EQ.I)THEN
            IF(IDATA.EQ.10)THEN
                 VWMAP(K,L,IWMAP)=VREAD
            ELSE
                 VMAP(K,L)=VREAD
                 IF(I.EQ.1)THEN
                      VMMIN=VREAD
                      VMMAX=VREAD
                 ELSE
                      VMMIN=MIN(VMMIN,VREAD)
                      VMMAX=MAX(VMMAX,VREAD)
                 ENDIF
            ENDIF
       ENDIF
30     CONTINUE
20     CONTINUE
*   Next point.
10     CONTINUE
**  Flag that the potential is now defined.
       IF(IDATA.EQ.10)THEN
            MAPFLG(13+4*IWMAP-3)=.TRUE.
       ELSE
            MAPFLG(5)=.TRUE.
       ENDIF
*** Read the materials, if there are any.
       CALL PROFLD(2,'Rewind',-1.0)
       CALL PROSTA(2,0.0)
       REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
       IL=0
*   Preset the material flags.
       NEPS=0
       print *,' ntetra = ',ntetra
       DO 130 I=1,NTETRA
       MATMAP(I)=-1
130    CONTINUE
       CALL PROFLD(2,'Skipping',-1.0)
       CALL PROSTA(2,0.0)
170    CONTINUE
       READ(12,'(A75)',END=2001,ERR=2010,IOSTAT=IOS) LINE
       IL=IL+1
       IF(LINE(1:22).NE.'% Data (es.epsrAv (1))')GOTO 170
       CALL PROFLD(2,'Materials',REAL(NTETRA))
       DO 180 I=1,NTETRA
       IF(I.EQ.MAX(1,NTETRA/100)*(I/MAX(1,NTETRA/100)))
     -      CALL PROSTA(2,REAL(I))
*   Read the data line.
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IF(INDEX(LINE,'.').EQ.0)THEN
            READ(LINE,'(BN,I25)') IAUX
            EREAD=REAL(IAUX)
       ELSE
            READ(LINE,'(E25.10)') EREAD
       ENDIF
C       print *,' eread = ',eread
       IL=IL+1
*   Match with existing epsilons.
       IEPS=-1
       DO 190 J=1,NEPS
       IF(ABS(EREAD-EPSMAT(J)).LE.
     -      1E-4*(ABS(EPSMAT(J))+ABS(EREAD)))IEPS=J
190    CONTINUE
*   Warn if we run out of spcae.
       IF(IEPS.LT.0.AND.NEPS.GE.MXEPS)THEN
            PRINT *,' !!!!!! MAPFM8 WARNING : More media than storage'//
     -           ' allows in ',FMAP(1:NCMAP),'; medium not assigned.'
            IFAIL=1
            RETURN
*   Add new epsilon to the table.
       ELSEIF(IEPS.LT.0)THEN
            NEPS=NEPS+1
            IEPS=NEPS
            EPSMAT(IEPS)=EREAD
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM8 DEBUG   :'',
     -           '' Adding dielectricum '',I3,'' with eps='',E10.3,
     -           ''.'')') IEPS,EPSMAT(IEPS)
       ENDIF
*   Assign the value.
       MATMAP(I)=IEPS
180    CONTINUE
*   Set the flag.
       MAPFLG(9)=.TRUE.
       GOTO 2002
*   No epsilon data present.
2001   CONTINUE
*   Set the flag that there are no epsilons.
       MAPFLG(9)=.FALSE.
**  Seems to have worked, set error flag to OK and return.
2002   CONTINUE
       IFAIL=0
       RETURN
*** Error handling.
2000   CONTINUE
       PRINT *,' !!!!!! MAPFM8 WARNING : Premature end of file on ',
     -      FMAP(1:NCMAP),' at line ',IL,'; file not read.'
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
2010   CONTINUE
       PRINT *,' !!!!!! MAPFM8 WARNING : Error while reading ',
     -      FMAP(1:NCMAP),' at line ',IL,'; file not read.'
       print *,' Line ',il
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
2040   CONTINUE
       PRINT *,' !!!!!! MAPFM8 WARNING : Error while rewinding ',
     -      FMAP(1:NCMAP),'; file not read.'
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
       END
CDECK  ID>, MAPFM9.
       SUBROUTINE MAPFM9(FMAP,NCMAP,IDATA,IWMAP,IORDER,UNITD,IFAIL)
*-----------------------------------------------------------------------
*   MAPFM9 - Reads a COMSOL 2D map of 1st or 2nd order triangles
*   (Last changed on 11/ 3/14.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER I,J,K,L,NCMAP,IFAIL,IORDER,
     -      IH1,IH2,IH3,IH4,IH5,IH6,IDUM,
     -      IDATA,NTRIAN,NPOINT,IWMAP,IMAP(MXMAP,10),IOS
       REAL XP,YP,VREAD,UNITD
       CHARACTER*(*) FMAP
       CHARACTER*75 LINE
       SAVE NTRIAN,NPOINT,IMAP
       DATA NTRIAN/0/, NPOINT/0/
**** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE MAPFM9 ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM9 DEBUG   : Data = '',
     -      I3,'', IWMAP = '',I3,'', IORDER = '',I3/26X,''File = "'',
     -      A,''"'')') IDATA,IWMAP,IORDER,FMAP(1:NCMAP)
*** Assume that this will fail.
       IFAIL=1
*** Set the number of fields.
       IF(IORDER.LT.1.OR.IORDER.GT.2)
     -      PRINT *,' !!!!!! MAPFM9 WARNING : Invalid order parameter'//
     -      ' received: ',IORDER,'; reading as 1st order.'
*** We will only do Fortran reads, from the start.
       CALL INPSWI('RESTORE')
       REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
*** The first part contains the coordinates, which we skip at first
       CALL PROFLD(2,'Skipping',-1.0)
       CALL PROSTA(2,0.0)
*   Check the first header.
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IF(LINE(1:13).NE.'% Coordinates')THEN
            PRINT *,' !!!!!! MAPFM9 WARNING : The first line of ',
     -           FMAP(1:NCMAP),' does not contain the expected'//
     -           ' COMSOL 2D header; file not read.'
            IFAIL=1
            RETURN
       ENDIF
*   Skip until the elements, counting the number of points.
       NPOINT=0
40     CONTINUE
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IF(LINE(1:10).NE.'% Elements')THEN
            NPOINT=NPOINT+1
            GOTO 40
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM9 DEBUG   :'',
     -      '' Expecting '',I5,'' points.'')') NPOINT
*** Read the triangle structure.
       CALL PROFLD(2,'Triangles',-1.0)
       CALL PROSTA(2,0.0)
*   Read lines with point references, until the next header
       NTRIAN=0
70     CONTINUE
       READ(12,'(A30)',END=2000,ERR=2010,IOSTAT=IOS) LINE(1:30)
       IF(LINE(1:30).EQ.' ')GOTO 70
       IF(LINE(1:1).NE.'%')THEN
*   Increment the triangle counter.
            IF(NTRIAN+1.GT.MXMAP)THEN
                 PRINT *,' !!!!!! MAPFM9 WARNING : Number of'//
     -                ' triangles in ',FMAP(1:NCMAP),
     -                ' exceeds compilation limit; file not read.'
                 IFAIL=1
                 RETURN
            ENDIF
            NTRIAN=NTRIAN+1
*   Decode a block of 8 line
            IF(IORDER.NE.2)THEN
                 READ(LINE,'(BN,3I10)',END=2000,ERR=2010,IOSTAT=IOS)
     -                IH1 ,IH2 ,IH3
                 IH4=0
                 IH5=0
                 IH6=0
            ELSEIF(IORDER.EQ.2)THEN
                 READ(LINE,'(BN,3I10)',END=2000,ERR=2010,IOSTAT=IOS)
     -                IH1 ,IH4 ,IH5
                 DO 50 I=1,3
                 READ(12,'(A30)',END=2000,ERR=2010,IOSTAT=IOS)
     -                LINE(1:30)
                 IF(LINE(1:30).EQ.' ')GOTO 50
                 IF(I.EQ.1)THEN
                      READ(LINE,'(BN,3I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IH6,IDUM
                 ELSEIF(I.EQ.2)THEN
                      READ(LINE,'(BN,3I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IH2,IDUM
                 ELSEIF(I.EQ.3)THEN
                      READ(LINE,'(BN,3I10)',END=2000,ERR=2010,
     -                     IOSTAT=IOS) IDUM,IDUM,IH3
                 ENDIF
50               CONTINUE
            ENDIF
*   Ensure there is no degeneracy
            IF(  (IORDER.NE.2.AND.(
     -           IH1.EQ.IH2.OR.IH1.EQ.IH3.OR.
     -                         IH2.EQ.IH3)).OR.
     -           (IORDER.EQ.2.AND.(
     -           IH1.EQ.IH2.OR.IH1.EQ.IH3.OR.IH1.EQ.IH4 .OR.
     -           IH1.EQ.IH5.OR.IH1.EQ.IH6.OR.
     -                         IH2.EQ.IH3.OR.IH2.EQ.IH4 .OR.
     -           IH2.EQ.IH5.OR.IH2.EQ.IH6.OR.
     -                                       IH3.EQ.IH4 .OR.
     -           IH3.EQ.IH5.OR.IH3.EQ.IH6.OR.
     -           IH4.EQ.IH5.OR.IH4.EQ.IH6.OR.
     -                         IH5.EQ.IH6)))THEN
                 PRINT *,' !!!!!! MAPFM9 WARNING : Element ',NTRIAN,
     -                ' in file ',FMAP(1:NCMAP),' is degenerate;'//
     -                ' file not read.'
                 IFAIL=1
                 RETURN
            ENDIF
*   Ensure they all make sense.
            IF(  (IORDER.NE.2.AND.(
     -           IH1.LE.0.OR.IH2.LE.0.OR.IH3.LE.0)).OR.
     -           (IORDER.EQ.2.AND.(
     -           IH1.LE.0.OR.IH2.LE.0.OR.IH3.LE.0.OR.IH4.LE.0.OR.
     -           IH5.LE.0.OR.IH6.LE.0)))THEN
                 PRINT *,' !!!!!! MAPFM9 WARNING : Invalid point'//
     -                ' reference in ',FMAP(1:NCMAP),'; map not read.'
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM9 DEBUG   :'',
     -                '' triangle '',I5/
     -                26X,''Vertices: '',6(2X,I5))')
     -                NTRIAN,IH1,IH2,IH3,IH4,IH5,IH6
                 IFAIL=1
                 RETURN
            ENDIF
*   Store the reference pointers (negative sign for checks).
            IMAP(NTRIAN,1) =-IH1
            IMAP(NTRIAN,2) =-IH2
            IMAP(NTRIAN,3) =-IH3
            IMAP(NTRIAN,4) =-IH4
            IMAP(NTRIAN,5) =-IH5
            IMAP(NTRIAN,6) =-IH6
*   Next line
            GOTO 70
       ENDIF
*   Debugging
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPFM9 DEBUG   :'',
     -      '' Found '',I5,'' triangles.'')') NTRIAN
*** Read the points filling in the mesh file.
       CALL PROFLD(2,'Rewind',-1.0)
       CALL PROSTA(2,0.0)
       REWIND(UNIT=12,ERR=2040,IOSTAT=IOS)
*** Skip vertex reading if this has already been done.
       IF(MAPFLG(1))GOTO 1234
*   Skip the header
       READ(12,'()',END=2000,ERR=2010,IOSTAT=IOS)
*   Loop over the points.
       CALL PROFLD(2,'Vertices',REAL(NPOINT))
       DO 80 I=1,NPOINT
       IF(I.EQ.MAX(1,NPOINT/100)*(I/MAX(1,NPOINT/100)))
     -      CALL PROSTA(2,REAL(I))
*   Read the line.
       READ(12,'(2F25.10)',END=2000,ERR=2010,IOSTAT=IOS) XP,YP
*   Convert from the COMSOL unit to cm.
       XP=XP*UNITD
       YP=YP*UNITD
*   Update the chamber dimensions.
       IF(I.EQ.1)THEN
            XMMIN=XP
            XMMAX=XP
            YMMIN=YP
            YMMAX=YP
       ELSE
            XMMIN=MIN(XMMIN,XP)
            XMMAX=MAX(XMMAX,XP)
            YMMIN=MIN(YMMIN,YP)
            YMMAX=MAX(YMMAX,YP)
       ENDIF
*   Update angular ranges.
       IF(XP.NE.0.OR.YP.NE.0)THEN
            IF(SETAZ)THEN
                 ZAMIN=MIN(ZAMIN,ATAN2(YP,XP))
                 ZAMAX=MAX(ZAMAX,ATAN2(YP,XP))
            ELSE
                 ZAMIN=ATAN2(YP,XP)
                 ZAMAX=ATAN2(YP,XP)
                 SETAZ=.TRUE.
            ENDIF
       ENDIF
*   Find referring triangles, trace resolved references with sign.
       DO 90 J=1,3
       DO 100 K=1,NTRIAN
       IF(I.EQ.ABS(IMAP(K,J)))THEN
            XMAP(K,J)=XP
            YMAP(K,J)=YP
            IMAP(K,J)=ABS(IMAP(K,J))
       ENDIF
100    CONTINUE
90     CONTINUE
*   Next point.
80     CONTINUE
*   End of reading, check reference resolution.
       CALL PROFLD(2,'Verifying',-1.0)
       CALL PROSTA(2,0.0)
       DO 110 J=1,3
       DO 120 I=1,NTRIAN
       IF(IMAP(I,J).LE.0)THEN
            PRINT *,' !!!!!! MAPFM9 WARNING : Unresolved point'//
     -           ' references in mesh ; map rejected.'
            IFAIL=1
            RETURN
       ENDIF
120    CONTINUE
110    CONTINUE
*   Preset the material flags.
       DO 130 I=1,NTRIAN
       MATMAP(I)=-1
130    CONTINUE
*   Now set the number of elements.
       NMAP=NTRIAN
*   Set the flag that the mesh is now defined.
       MAPFLG(1)=.TRUE.
*   Set the element type.
       MAPTYP=2
*** And read the potentials, first skip till we have the header.
1234   CONTINUE
       CALL PROFLD(2,'Skipping',-1.0)
       CALL PROSTA(2,0.0)
140    CONTINUE
       READ(12,'(A75)',END=2000,ERR=2010,IOSTAT=IOS) LINE
       IF(LINE(1:10).NE.'% Data (V)'.AND.
     -    LINE(1:19).NE.'% Data ((V)[1/(V)])'.AND.
     -    LINE(1:19).NE.'% Data (V (V))')GOTO 140
*   Read the list of points with associated field values.
       IF(IDATA.EQ.10)THEN
            CALL PROFLD(2,'Weighting field',REAL(NPOINT))
       ELSE
            CALL PROFLD(2,'Potentials',REAL(NPOINT))
       ENDIF
       DO 10 I=1,NPOINT
       IF(I.EQ.MAX(1,NPOINT/100)*(I/MAX(1,NPOINT/100)))
     -      CALL PROSTA(2,REAL(I))
*   Read the data line.
       READ(12,'(F25.10)',END=2000,ERR=2010,IOSTAT=IOS) VREAD
*   Assign the potential to the mesh.
       DO 20 L=1,6
       DO 30 K=1,NTRIAN
       IF(ABS(IMAP(K,L)).EQ.I)THEN
            IF(IDATA.EQ.10)THEN
                 VWMAP(K,L,IWMAP)=VREAD
            ELSE
                 VMAP(K,L)=VREAD
                 IF(I.EQ.1)THEN
                      VMMIN=VREAD
                      VMMAX=VREAD
                 ELSE
                      VMMIN=MIN(VMMIN,VREAD)
                      VMMAX=MAX(VMMAX,VREAD)
                 ENDIF
            ENDIF
       ENDIF
30     CONTINUE
20     CONTINUE
*   Next point.
10     CONTINUE
**  Flag that the potential is now defined.
       IF(IDATA.EQ.10)THEN
            MAPFLG(13+4*IWMAP-3)=.TRUE.
       ELSE
            MAPFLG(5)=.TRUE.
       ENDIF
*** Seems to have worked, set error flag to OK and return.
       IFAIL=0
       RETURN
*** Error handling.
2000   CONTINUE
       PRINT *,' !!!!!! MAPFM9 WARNING : Premature end of file on ',
     -      FMAP(1:NCMAP),'; file not read.'
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
2010   CONTINUE
       PRINT *,' !!!!!! MAPFM9 WARNING : Error while reading ',
     -      FMAP(1:NCMAP),'; file not read.'
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
2040   CONTINUE
       PRINT *,' !!!!!! MAPFM9 WARNING : Error while rewinding ',
     -      FMAP(1:NCMAP),'; file not read.'
       IF(LDEBUG)CALL INPIOS(IOS)
       RETURN
       END
CDECK  ID>, MAPC4.
       SUBROUTINE MAPC4(X,Y,Z,T1,T2,T3,T4,JAC,DET,IMAP,IFAIL)
*-----------------------------------------------------------------------
*   MAPC4  - Finds the isoparametric cooordinates of point (X,Y) in a
*            linear quadrilateral.
*   (Last changed on 16/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL X,Y,Z,T1,T2,T3,T4
       DOUBLE PRECISION JAC(4,4),DET,PROD,XR,YR,XP,YP,
     -      DN,DBOX,DPOINT,T,XT1,YT1,XT2,YT2
       INTEGER IMAP,IFAIL
C       integer i
*** Debugging.
       IF(LIDENT)PRINT *,' /// ROUTINE MAPC4  ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC4  DEBUG   : Input'',
     -      '' point (x, y):     ('',E12.5,'' , '',E12.5,'')'')') X,Y
*** Set values which are not going to be determined.
       T1=0
       T2=0
       T3=0
       T4=0
*** Compute determinant.
       DET = -(-((XMAP(IMAP,1)-XMAP(IMAP,4))*
     -      (YMAP(IMAP,2)-YMAP(IMAP,3)))+
     -      (XMAP(IMAP,2)-XMAP(IMAP,3))*(YMAP(IMAP,1)-YMAP(IMAP,4)))*
     -      (2*X*(-YMAP(IMAP,1)+YMAP(IMAP,2)+YMAP(IMAP,3)-YMAP(IMAP,4))-
     -      (XMAP(IMAP,1)+XMAP(IMAP,4))*(YMAP(IMAP,2)+YMAP(IMAP,3)-2*Y)+
     -      XMAP(IMAP,2)*(YMAP(IMAP,1)+YMAP(IMAP,4)-2*Y)+XMAP(IMAP,3)*
     -      (YMAP(IMAP,1)+YMAP(IMAP,4)-2*Y))+
     -      (-(XMAP(IMAP,1)*YMAP(IMAP,2))+
     -      XMAP(IMAP,4)*YMAP(IMAP,3)-XMAP(IMAP,3)*YMAP(IMAP,4)+
     -      X*(-YMAP(IMAP,1)+
     -      YMAP(IMAP,2)-YMAP(IMAP,3)+YMAP(IMAP,4))+
     -      XMAP(IMAP,2)*(YMAP(IMAP,1)-Y)+(XMAP(IMAP,1)+XMAP(IMAP,3)-
     -      XMAP(IMAP,4))*Y)**2
*   Check that the determinant is non-negative.
       IF(DET.LT.0)THEN
C            PRINT *,' !!!!!! MAPC4  WARNING : No solution found for'//
C     -           ' isoparametric coordinates in element ',IMAP,
C     -           ' because the determinant is < 0.'
C      print *,' Location: ',x,y
C      do i=1,4
C      print '(2(f12.5,2x))',xmap(imap,i),ymap(imap,i)
C      enddo
            T1=0
            T2=0
            IFAIL=1
            RETURN
       ENDIF
*   Vector products for evaluation of T1.
       PROD=((XMAP(IMAP,3)-XMAP(IMAP,4))*(YMAP(IMAP,1)-YMAP(IMAP,2))-
     -       (XMAP(IMAP,1)-XMAP(IMAP,2))*(YMAP(IMAP,3)-YMAP(IMAP,4)))
       IF(PROD**2.GT.1E-12*
     -      ((XMAP(IMAP,1)-XMAP(IMAP,2))**2+
     -       (YMAP(IMAP,1)-YMAP(IMAP,2))**2)*
     -      ((XMAP(IMAP,3)-XMAP(IMAP,4))**2+
     -       (YMAP(IMAP,3)-YMAP(IMAP,4))**2))THEN
            T1=(-(XMAP(IMAP,4)*YMAP(IMAP,1))+X*YMAP(IMAP,1)+
     -           XMAP(IMAP,3)*YMAP(IMAP,2)-X*YMAP(IMAP,2)-
     -           XMAP(IMAP,2)*YMAP(IMAP,3)+
     -           X*YMAP(IMAP,3)+XMAP(IMAP,1)*YMAP(IMAP,4)-
     -           X*YMAP(IMAP,4)-XMAP(IMAP,1)*Y+XMAP(IMAP,2)*Y-
     -           XMAP(IMAP,3)*Y+XMAP(IMAP,4)*Y+SQRT(DET))/PROD
C            T1=(-(XMAP(IMAP,4)*YMAP(IMAP,1))+X*YMAP(IMAP,1)+
C     -           XMAP(IMAP,3)*YMAP(IMAP,2)-X*YMAP(IMAP,2)-
C     -           XMAP(IMAP,2)*YMAP(IMAP,3)+
C     -           X*YMAP(IMAP,3)+XMAP(IMAP,1)*YMAP(IMAP,4)-
C     -           X*YMAP(IMAP,4)-XMAP(IMAP,1)*Y+XMAP(IMAP,2)*Y-
C     -           XMAP(IMAP,3)*Y+XMAP(IMAP,4)*Y-SQRT(DET))/PROD
C       print *,' Non-parallel, 2nd estimate: T1 = ',T1
       ELSE
            XP=YMAP(IMAP,1)-YMAP(IMAP,2)
            YP=XMAP(IMAP,2)-XMAP(IMAP,1)
            DN=SQRT(XP**2+YP**2)
            IF(DN.LE.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Element ',IMAP,
     -                ' appears to be degenerate in the 1-2 axis.'
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            XP=XP/DN
            YP=YP/DN
            DPOINT=XP*(X-XMAP(IMAP,1))+YP*(Y-YMAP(IMAP,1))
            DBOX=  XP*(XMAP(IMAP,4)-XMAP(IMAP,1))+
     -             YP*(YMAP(IMAP,4)-YMAP(IMAP,1))
            IF(DBOX.EQ.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Element ',IMAP,
     -                ' appears to be degenerate in the 1-3 axis.'
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            T=-1+2*DPOINT/DBOX
            XT1=XMAP(IMAP,1)+0.5*(T+1)*(XMAP(IMAP,4)-XMAP(IMAP,1))
            YT1=YMAP(IMAP,1)+0.5*(T+1)*(YMAP(IMAP,4)-YMAP(IMAP,1))
            XT2=XMAP(IMAP,2)+0.5*(T+1)*(XMAP(IMAP,3)-XMAP(IMAP,2))
            YT2=YMAP(IMAP,2)+0.5*(T+1)*(YMAP(IMAP,3)-YMAP(IMAP,2))
            DN=(XT1-XT2)**2+(YT1-YT2)**2
            IF(DN.LE.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Coordinate'//
     -                ' requested at convergence point of element ',
     -                IMAP
       print *,' parallel for t1: t2 = ',t
       print *,' xt1, yt1 = ',xt1,yt1
       print *,' x  , y   = ',x,y
       print *,' xt2, yt2 = ',xt2,yt2
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            T1=-1+2*((X-XT1)*(XT2-XT1)+(Y-YT1)*(YT2-YT1))/DN
       ENDIF
*   Vector products for evaluation of T2.
       PROD=((XMAP(IMAP,1)-XMAP(IMAP,4))*(YMAP(IMAP,2)-YMAP(IMAP,3))-
     -       (XMAP(IMAP,2)-XMAP(IMAP,3))*(YMAP(IMAP,1)-YMAP(IMAP,4)))
       IF(PROD**2.GT.1E-12*
     -      ((XMAP(IMAP,1)-XMAP(IMAP,4))**2+
     -       (YMAP(IMAP,1)-YMAP(IMAP,4))**2)*
     -      ((XMAP(IMAP,2)-XMAP(IMAP,3))**2+
     -       (YMAP(IMAP,2)-YMAP(IMAP,3))**2))THEN
            T2 = (-(XMAP(IMAP,2)*YMAP(IMAP,1))+X*YMAP(IMAP,1)+
     -           XMAP(IMAP,1)*YMAP(IMAP,2)-X*YMAP(IMAP,2)-
     -           XMAP(IMAP,4)*YMAP(IMAP,3)+
     -           X*YMAP(IMAP,3)+XMAP(IMAP,3)*YMAP(IMAP,4)-
     -           X*YMAP(IMAP,4)-XMAP(IMAP,1)*Y+XMAP(IMAP,2)*Y-
     -           XMAP(IMAP,3)*Y+XMAP(IMAP,4)*Y-SQRT(DET))/PROD
C            T2 = (-(XMAP(IMAP,2)*YMAP(IMAP,1))+X*YMAP(IMAP,1)+
C     -           XMAP(IMAP,1)*YMAP(IMAP,2)-X*YMAP(IMAP,2)-
C     -           XMAP(IMAP,4)*YMAP(IMAP,3)+
C     -           X*YMAP(IMAP,3)+XMAP(IMAP,3)*YMAP(IMAP,4)-
C     -           X*YMAP(IMAP,4)-XMAP(IMAP,1)*Y+XMAP(IMAP,2)*Y-
C     -           XMAP(IMAP,3)*Y+XMAP(IMAP,4)*Y+SQRT(DET))/PROD
C       print *,' Non-parallel, 2nd estimate: T2 = ',T2
       ELSE
            XP=YMAP(IMAP,1)-YMAP(IMAP,4)
            YP=XMAP(IMAP,4)-XMAP(IMAP,1)
            DN=SQRT(XP**2+YP**2)
            IF(DN.LE.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Element ',IMAP,
     -                ' appears to be degenerate in the 1-4 axis.'
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            XP=XP/DN
            YP=YP/DN
            DPOINT=XP*(X-XMAP(IMAP,1))+YP*(Y-YMAP(IMAP,1))
            DBOX=  XP*(XMAP(IMAP,2)-XMAP(IMAP,1))+
     -             YP*(YMAP(IMAP,2)-YMAP(IMAP,1))
            IF(DBOX.EQ.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Element ',IMAP,
     -                ' appears to be degenerate in the 1-2 axis.'
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            T=-1+2*DPOINT/DBOX
            XT1=XMAP(IMAP,1)+0.5*(T+1)*(XMAP(IMAP,2)-XMAP(IMAP,1))
            YT1=YMAP(IMAP,1)+0.5*(T+1)*(YMAP(IMAP,2)-YMAP(IMAP,1))
            XT2=XMAP(IMAP,4)+0.5*(T+1)*(XMAP(IMAP,3)-XMAP(IMAP,4))
            YT2=YMAP(IMAP,4)+0.5*(T+1)*(YMAP(IMAP,3)-YMAP(IMAP,4))
            DN=(XT1-XT2)**2+(YT1-YT2)**2
            IF(DN.LE.0)THEN
                 PRINT *,' !!!!!! MAPC4  WARNING : Coordinate'//
     -                ' requested at convergence point of element ',
     -                IMAP
       print *,' parallel for t2: t1 = ',t
       print *,' xt1, yt1 = ',xt1,yt1
       print *,' x  , y   = ',x,y
       print *,' xt2, yt2 = ',xt2,yt2
                 T1=0
                 T2=0
                 IFAIL=1
                 RETURN
            ENDIF
            T2=-1+2*((X-XT1)*(XT2-XT1)+(Y-YT1)*(YT2-YT1))/DN
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC4  DEBUG   :'',
     -      '' Isoparametric (u, v):   ('',F12.9,'' , '',F12.9,'')'')')
     -      T1,T2
*   Re-compute the (x,y,z) position for this coordinate.
       IF(LDEBUG)THEN
            XR=XMAP(IMAP, 1)*(1-T1)*(1-T2)/4+
     -         XMAP(IMAP, 2)*(1+T1)*(1-T2)/4+
     -         XMAP(IMAP, 3)*(1+T1)*(1+T2)/4+
     -         XMAP(IMAP, 4)*(1-T1)*(1+T2)/4
            YR=YMAP(IMAP, 1)*(1-T1)*(1-T2)/4+
     -         YMAP(IMAP, 2)*(1+T1)*(1-T2)/4+
     -         YMAP(IMAP, 3)*(1+T1)*(1+T2)/4+
     -         YMAP(IMAP, 4)*(1-T1)*(1+T2)/4
            WRITE(LUNOUT,'(''  ++++++ MAPC4  DEBUG   : Position'',
     -           '' requested:     ('',E12.5,'' , '',E12.5,'')''/
     -           26X,''Position reconstructed: ('',E12.5,'' , '',E12.5,
     -           '')''/
     -           26X,''Difference:             ('',E12.5,'' , '',E12.5,
     -           '')'')') X,Y,XR,YR,X-XR,Y-YR
       ENDIF
*** This should have worked if we get this far.
       IFAIL=0
       END
CDECK  ID>, MAPC5.
       SUBROUTINE MAPC5(X,Y,Z,T1,T2,T3,T4,JAC,DET,IMAP,IFAIL)
*-----------------------------------------------------------------------
*   MAPC5  - Finds the isoparametric cooordinates of point (X,Y) in an
*            8-point ("serendipity") quadratic quadrilateral
*   (Last changed on 16/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
C      logical ldebug,lident
C      parameter (ldebug=.true., lident=.false.)
C      integer lunout
C      parameter(lunout=6)
       REAL X,Y,Z,T1,T2,T3,T4
       DOUBLE PRECISION DETT,
     -      JACT11,JACT12,JACT21,JACT22,
     -      XR,YR,CORR(2),DIFF(2),
     -      JAC(4,4),DET,U,V,TD1,TD2,F
       INTEGER I,K,L,IMAP,IL,ITER,IFAIL
*   Determinant of the quadratic tetrahedron Jacobian
       DETT(U,V,IL)=
     -      (-2*U**3*((XMAP(IL,3)+XMAP(IL,4)-2*XMAP(IL,7))*
     -      (YMAP(IL,1)+YMAP(IL,2)-2*YMAP(IL,5))-(XMAP(IL,1)+XMAP(IL,2)-
     -      2*XMAP(IL,5))*(YMAP(IL,3)+YMAP(IL,4)-2*YMAP(IL,7)))+
     -      2*V**3*(-((XMAP(IL,1)+XMAP(IL,4)-2*XMAP(IL,8))*
     -      (YMAP(IL,2)+YMAP(IL,3)-2*YMAP(IL,6)))+
     -      (XMAP(IL,2)+XMAP(IL,3)-2*XMAP(IL,6))*(YMAP(IL,1)+YMAP(IL,4)-
     -      2*YMAP(IL,8)))+2*(-((XMAP(IL,6)-XMAP(IL,8))*
     -      (YMAP(IL,5)-YMAP(IL,7)))+(XMAP(IL,5)-XMAP(IL,7))*
     -      (YMAP(IL,6)-YMAP(IL,8)))+V*(-(XMAP(IL,7)*YMAP(IL,1))-
     -      2*XMAP(IL,8)*YMAP(IL,1)+XMAP(IL,7)*YMAP(IL,2)-
     -      2*XMAP(IL,8)*YMAP(IL,2)-XMAP(IL,7)*YMAP(IL,3)-
     -      2*XMAP(IL,8)*YMAP(IL,3)+XMAP(IL,5)*(YMAP(IL,1)-YMAP(IL,2)+
     -      YMAP(IL,3)-YMAP(IL,4))+XMAP(IL,7)*YMAP(IL,4)-
     -      2*XMAP(IL,8)*YMAP(IL,4)-XMAP(IL,1)*YMAP(IL,5)+
     -      XMAP(IL,2)*YMAP(IL,5)-XMAP(IL,3)*YMAP(IL,5)+
     -      XMAP(IL,4)*YMAP(IL,5)-2*XMAP(IL,1)*YMAP(IL,6)-
     -      2*XMAP(IL,2)*YMAP(IL,6)-2*XMAP(IL,3)*YMAP(IL,6)-
     -      2*XMAP(IL,4)*YMAP(IL,6)+8*XMAP(IL,8)*YMAP(IL,6)+
     -      XMAP(IL,1)*YMAP(IL,7)-XMAP(IL,2)*YMAP(IL,7)+
     -      XMAP(IL,3)*YMAP(IL,7)-XMAP(IL,4)*YMAP(IL,7)+
     -      2*XMAP(IL,6)*(YMAP(IL,1)+YMAP(IL,2)+YMAP(IL,3)+YMAP(IL,4)-
     -      4*YMAP(IL,8))+2*(XMAP(IL,1)+XMAP(IL,2)+XMAP(IL,3)+
     -      XMAP(IL,4))*YMAP(IL,8))+V**2*(-(XMAP(IL,5)*YMAP(IL,1))+
     -      2*XMAP(IL,6)*YMAP(IL,1)+XMAP(IL,7)*YMAP(IL,1)+
     -      2*XMAP(IL,8)*YMAP(IL,1)+XMAP(IL,5)*YMAP(IL,2)-
     -      2*XMAP(IL,6)*YMAP(IL,2)-XMAP(IL,7)*YMAP(IL,2)-
     -      2*XMAP(IL,8)*YMAP(IL,2)+XMAP(IL,5)*YMAP(IL,3)+
     -      2*XMAP(IL,6)*YMAP(IL,3)-XMAP(IL,7)*YMAP(IL,3)+
     -      2*XMAP(IL,8)*YMAP(IL,3)-XMAP(IL,5)*YMAP(IL,4)-
     -      2*XMAP(IL,6)*YMAP(IL,4)+XMAP(IL,7)*YMAP(IL,4)-
     -      2*XMAP(IL,8)*YMAP(IL,4)+
     -      2*XMAP(IL,3)*(YMAP(IL,2)+YMAP(IL,4))-XMAP(IL,3)*YMAP(IL,5)+
     -      2*XMAP(IL,6)*YMAP(IL,5)-2*XMAP(IL,8)*YMAP(IL,5)-
     -      2*XMAP(IL,3)*YMAP(IL,6)-2*XMAP(IL,5)*YMAP(IL,6)+
     -      2*XMAP(IL,7)*YMAP(IL,6)+XMAP(IL,3)*YMAP(IL,7)-
     -      2*XMAP(IL,6)*YMAP(IL,7)+2*XMAP(IL,8)*YMAP(IL,7)+
     -      XMAP(IL,1)*(2*YMAP(IL,2)+2*YMAP(IL,4)+YMAP(IL,5)-
     -      2*YMAP(IL,6)-YMAP(IL,7)-2*YMAP(IL,8))-
     -      2*(XMAP(IL,3)-XMAP(IL,5)+XMAP(IL,7))*YMAP(IL,8)+XMAP(IL,4)*
     -      (-2*YMAP(IL,1)-2*YMAP(IL,3)+YMAP(IL,5)+
     -      2*YMAP(IL,6)-YMAP(IL,7)+2*YMAP(IL,8))+
     -      XMAP(IL,2)*(-2*YMAP(IL,1)-2*YMAP(IL,3)-YMAP(IL,5)+
     -      2*YMAP(IL,6)+YMAP(IL,7)+2*YMAP(IL,8)))+
     -      U*(XMAP(IL,6)*YMAP(IL,1)-2*XMAP(IL,7)*YMAP(IL,1)-
     -      XMAP(IL,8)*YMAP(IL,1)-XMAP(IL,6)*YMAP(IL,2)-
     -      2*XMAP(IL,7)*YMAP(IL,2)+XMAP(IL,8)*YMAP(IL,2)+
     -      XMAP(IL,6)*YMAP(IL,3)-2*XMAP(IL,7)*YMAP(IL,3)-
     -      XMAP(IL,8)*YMAP(IL,3)-XMAP(IL,6)*YMAP(IL,4)-
     -      2*XMAP(IL,7)*YMAP(IL,4)+XMAP(IL,8)*YMAP(IL,4)-
     -      2*XMAP(IL,2)*YMAP(IL,5)-2*XMAP(IL,3)*YMAP(IL,5)-
     -      2*XMAP(IL,4)*YMAP(IL,5)+8*XMAP(IL,7)*YMAP(IL,5)+
     -      XMAP(IL,2)*YMAP(IL,6)-XMAP(IL,3)*YMAP(IL,6)+
     -      XMAP(IL,4)*YMAP(IL,6)+2*XMAP(IL,5)*(YMAP(IL,1)+
     -      YMAP(IL,2)+YMAP(IL,3)+YMAP(IL,4)-4*YMAP(IL,7))+
     -      2*XMAP(IL,2)*YMAP(IL,7)+2*XMAP(IL,3)*YMAP(IL,7)+
     -      2*XMAP(IL,4)*YMAP(IL,7)-(XMAP(IL,2)-XMAP(IL,3)+
     -      XMAP(IL,4))*YMAP(IL,8)+XMAP(IL,1)*
     -      (-2*YMAP(IL,5)-YMAP(IL,6)+2*YMAP(IL,7)+YMAP(IL,8))+
     -      V**2*(4*XMAP(IL,5)*YMAP(IL,1)-3*XMAP(IL,6)*YMAP(IL,1)-
     -      4*XMAP(IL,7)*YMAP(IL,1)-5*XMAP(IL,8)*YMAP(IL,1)+
     -      4*XMAP(IL,5)*YMAP(IL,2)-5*XMAP(IL,6)*YMAP(IL,2)-
     -      4*XMAP(IL,7)*YMAP(IL,2)-3*XMAP(IL,8)*YMAP(IL,2)+
     -      4*XMAP(IL,5)*YMAP(IL,3)+5*XMAP(IL,6)*YMAP(IL,3)-
     -      4*XMAP(IL,7)*YMAP(IL,3)+3*XMAP(IL,8)*YMAP(IL,3)+
     -      4*XMAP(IL,5)*YMAP(IL,4)+3*XMAP(IL,6)*YMAP(IL,4)-
     -      4*XMAP(IL,7)*YMAP(IL,4)+5*XMAP(IL,8)*YMAP(IL,4)+
     -      8*XMAP(IL,6)*YMAP(IL,5)+8*XMAP(IL,8)*YMAP(IL,5)-
     -      8*XMAP(IL,5)*YMAP(IL,6)+8*XMAP(IL,7)*YMAP(IL,6)-
     -      8*XMAP(IL,6)*YMAP(IL,7)-8*XMAP(IL,8)*YMAP(IL,7)+
     -      XMAP(IL,4)*(5*YMAP(IL,1)+3*YMAP(IL,2)-4*YMAP(IL,5)-
     -      3*YMAP(IL,6)+4*YMAP(IL,7)-5*YMAP(IL,8))+
     -      XMAP(IL,3)*(3*YMAP(IL,1)+5*YMAP(IL,2)-4*YMAP(IL,5)-
     -      5*YMAP(IL,6)+4*YMAP(IL,7)-3*YMAP(IL,8))-
     -      8*XMAP(IL,5)*YMAP(IL,8)+8*XMAP(IL,7)*YMAP(IL,8)+
     -      XMAP(IL,2)*(-5*YMAP(IL,3)-3*YMAP(IL,4)-4*YMAP(IL,5)+
     -      5*YMAP(IL,6)+4*YMAP(IL,7)+3*YMAP(IL,8))+
     -      XMAP(IL,1)*(-3*YMAP(IL,3)-5*YMAP(IL,4)-4*YMAP(IL,5)+
     -      3*YMAP(IL,6)+4*YMAP(IL,7)+5*YMAP(IL,8)))-
     -      2*V*(XMAP(IL,7)*YMAP(IL,1)-3*XMAP(IL,8)*YMAP(IL,1)+
     -      XMAP(IL,7)*YMAP(IL,2)-XMAP(IL,8)*YMAP(IL,2)+
     -      3*XMAP(IL,7)*YMAP(IL,3)-XMAP(IL,8)*YMAP(IL,3)+
     -      3*XMAP(IL,7)*YMAP(IL,4)-3*XMAP(IL,8)*YMAP(IL,4)-
     -      3*XMAP(IL,1)*YMAP(IL,5)-3*XMAP(IL,2)*YMAP(IL,5)-
     -      XMAP(IL,3)*YMAP(IL,5)-XMAP(IL,4)*YMAP(IL,5)+
     -      4*XMAP(IL,8)*YMAP(IL,5)+XMAP(IL,1)*YMAP(IL,6)+
     -      3*XMAP(IL,2)*YMAP(IL,6)+3*XMAP(IL,3)*YMAP(IL,6)+
     -      XMAP(IL,4)*YMAP(IL,6)-4*XMAP(IL,7)*YMAP(IL,6)-
     -      XMAP(IL,1)*YMAP(IL,7)-XMAP(IL,2)*YMAP(IL,7)-
     -      3*XMAP(IL,3)*YMAP(IL,7)-3*XMAP(IL,4)*YMAP(IL,7)+
     -      4*XMAP(IL,8)*YMAP(IL,7)-XMAP(IL,6)*(YMAP(IL,1)+
     -      3*YMAP(IL,2)+3*YMAP(IL,3)+YMAP(IL,4)-
     -      4*(YMAP(IL,5)+YMAP(IL,7)))+(3*XMAP(IL,1)+XMAP(IL,2)+
     -      XMAP(IL,3)+3*XMAP(IL,4)-4*XMAP(IL,7))*YMAP(IL,8)+
     -      XMAP(IL,5)*(3*YMAP(IL,1)+3*YMAP(IL,2)+YMAP(IL,3)+
     -      YMAP(IL,4)-4*(YMAP(IL,6)+YMAP(IL,8)))))+
     -      U**2*(2*XMAP(IL,4)*YMAP(IL,1)-2*XMAP(IL,5)*YMAP(IL,1)-
     -      XMAP(IL,6)*YMAP(IL,1)-2*XMAP(IL,7)*YMAP(IL,1)+
     -      XMAP(IL,8)*YMAP(IL,1)-2*XMAP(IL,1)*YMAP(IL,2)+
     -      2*XMAP(IL,5)*YMAP(IL,2)-XMAP(IL,6)*YMAP(IL,2)+
     -      2*XMAP(IL,7)*YMAP(IL,2)+XMAP(IL,8)*YMAP(IL,2)+
     -      2*XMAP(IL,4)*YMAP(IL,3)-2*XMAP(IL,5)*YMAP(IL,3)+
     -      XMAP(IL,6)*YMAP(IL,3)-2*XMAP(IL,7)*YMAP(IL,3)-
     -      XMAP(IL,8)*YMAP(IL,3)+2*XMAP(IL,5)*YMAP(IL,4)+
     -      XMAP(IL,6)*YMAP(IL,4)+2*XMAP(IL,7)*YMAP(IL,4)-
     -      XMAP(IL,8)*YMAP(IL,4)-2*XMAP(IL,4)*YMAP(IL,5)+
     -      2*XMAP(IL,6)*YMAP(IL,5)-2*XMAP(IL,8)*YMAP(IL,5)-
     -      XMAP(IL,4)*YMAP(IL,6)-2*XMAP(IL,5)*YMAP(IL,6)+
     -      2*XMAP(IL,7)*YMAP(IL,6)-2*XMAP(IL,4)*YMAP(IL,7)-
     -      2*XMAP(IL,6)*YMAP(IL,7)+2*XMAP(IL,8)*YMAP(IL,7)+
     -      XMAP(IL,1)*(-2*YMAP(IL,4)+2*YMAP(IL,5)+YMAP(IL,6)+
     -      2*YMAP(IL,7)-YMAP(IL,8))+(XMAP(IL,4)+2*XMAP(IL,5)-
     -      2*XMAP(IL,7))*YMAP(IL,8)+XMAP(IL,3)*(-2*YMAP(IL,2)-
     -      2*YMAP(IL,4)+2*YMAP(IL,5)-YMAP(IL,6)+
     -      2*YMAP(IL,7)+YMAP(IL,8))-3*V**2*(XMAP(IL,6)*YMAP(IL,1)-
     -      XMAP(IL,7)*YMAP(IL,1)-XMAP(IL,8)*YMAP(IL,1)+
     -      XMAP(IL,6)*YMAP(IL,2)+XMAP(IL,7)*YMAP(IL,2)-
     -      XMAP(IL,8)*YMAP(IL,2)-XMAP(IL,6)*YMAP(IL,3)+
     -      XMAP(IL,7)*YMAP(IL,3)+XMAP(IL,8)*YMAP(IL,3)-
     -      XMAP(IL,6)*YMAP(IL,4)-XMAP(IL,7)*YMAP(IL,4)+
     -      XMAP(IL,8)*YMAP(IL,4)-2*XMAP(IL,6)*YMAP(IL,5)+
     -      2*XMAP(IL,8)*YMAP(IL,5)-2*XMAP(IL,7)*YMAP(IL,6)+
     -      2*XMAP(IL,6)*YMAP(IL,7)-2*XMAP(IL,8)*YMAP(IL,7)+
     -      XMAP(IL,5)*(YMAP(IL,1)-YMAP(IL,2)-YMAP(IL,3)+
     -      YMAP(IL,4)+2*YMAP(IL,6)-2*YMAP(IL,8))+
     -      XMAP(IL,4)*(YMAP(IL,1)-YMAP(IL,3)-YMAP(IL,5)+
     -      YMAP(IL,6)+YMAP(IL,7)-YMAP(IL,8))+2*XMAP(IL,7)*YMAP(IL,8)+
     -      (XMAP(IL,1)-XMAP(IL,3))*(YMAP(IL,2)-YMAP(IL,4)-YMAP(IL,5)-
     -      YMAP(IL,6)+YMAP(IL,7)+YMAP(IL,8)))+
     -      V*(4*XMAP(IL,6)*YMAP(IL,1)+3*XMAP(IL,7)*YMAP(IL,1)-
     -      4*XMAP(IL,8)*YMAP(IL,1)+4*XMAP(IL,6)*YMAP(IL,2)-
     -      3*XMAP(IL,7)*YMAP(IL,2)-4*XMAP(IL,8)*YMAP(IL,2)+
     -      4*XMAP(IL,6)*YMAP(IL,3)-5*XMAP(IL,7)*YMAP(IL,3)-
     -      4*XMAP(IL,8)*YMAP(IL,3)+4*XMAP(IL,6)*YMAP(IL,4)+
     -      5*XMAP(IL,7)*YMAP(IL,4)-4*XMAP(IL,8)*YMAP(IL,4)-
     -      8*XMAP(IL,6)*YMAP(IL,5)+8*XMAP(IL,8)*YMAP(IL,5)+
     -      8*XMAP(IL,7)*YMAP(IL,6)-8*XMAP(IL,6)*YMAP(IL,7)+
     -      8*XMAP(IL,8)*YMAP(IL,7)+XMAP(IL,5)*(5*YMAP(IL,1)-
     -      5*YMAP(IL,2)-3*YMAP(IL,3)+3*YMAP(IL,4)+8*YMAP(IL,6)-
     -      8*YMAP(IL,8))-8*XMAP(IL,7)*YMAP(IL,8)+
     -      XMAP(IL,4)*(3*YMAP(IL,2)+5*YMAP(IL,3)-3*YMAP(IL,5)-
     -      4*YMAP(IL,6)-5*YMAP(IL,7)+4*YMAP(IL,8))+
     -      XMAP(IL,1)*(5*YMAP(IL,2)+3*YMAP(IL,3)-5*YMAP(IL,5)-
     -      4*YMAP(IL,6)-3*YMAP(IL,7)+4*YMAP(IL,8))+XMAP(IL,3)*
     -      (-3*YMAP(IL,1)-5*YMAP(IL,4)+3*YMAP(IL,5)-4*YMAP(IL,6)+
     -      5*YMAP(IL,7)+4*YMAP(IL,8)))+XMAP(IL,2)*((-1+V)*(-2+3*V)*
     -      YMAP(IL,1)+2*YMAP(IL,3)-2*YMAP(IL,5)+YMAP(IL,6)-
     -      2*YMAP(IL,7)-YMAP(IL,8)+V*(-3*YMAP(IL,4)+5*YMAP(IL,5)-
     -      4*YMAP(IL,6)+3*YMAP(IL,7)+4*YMAP(IL,8)-
     -      3*V*(YMAP(IL,3)+YMAP(IL,5)-YMAP(IL,6)-YMAP(IL,7)+
     -      YMAP(IL,8))))))/8
*   Terms of the serendipity Jacobian.
       JACT11(U,V,IL)=(U**2*(-YMAP(IL,1)-YMAP(IL,2)+YMAP(IL,3)+
     -      YMAP(IL,4)+2*YMAP(IL,5)-2*YMAP(IL,7))+2*(-YMAP(IL,5)+
     -      YMAP(IL,7)+V*(YMAP(IL,1)+YMAP(IL,2)+YMAP(IL,3)+YMAP(IL,4)-
     -      2*YMAP(IL,6)-2*YMAP(IL,8)))+U*(YMAP(IL,1)-2*V*YMAP(IL,1)-
     -      YMAP(IL,2)+2*V*YMAP(IL,2)+YMAP(IL,3)+2*V*YMAP(IL,3)-
     -      YMAP(IL,4)-2*V*YMAP(IL,4)-4*V*YMAP(IL,6)+4*V*YMAP(IL,8)))/4
       JACT12(U,V,IL)=(U**2*(XMAP(IL,1)+XMAP(IL,2)-XMAP(IL,3)-
     -      XMAP(IL,4)-2*XMAP(IL,5)+2*XMAP(IL,7))-2*(-XMAP(IL,5)+
     -      XMAP(IL,7)+V*(XMAP(IL,1)+XMAP(IL,2)+XMAP(IL,3)+XMAP(IL,4)-
     -      2*XMAP(IL,6)-2*XMAP(IL,8)))+U*((-1+2*V)*XMAP(IL,1)+
     -      XMAP(IL,2)-2*V*XMAP(IL,2)-XMAP(IL,3)-2*V*XMAP(IL,3)+
     -      XMAP(IL,4)+2*V*XMAP(IL,4)+4*V*XMAP(IL,6)-4*V*XMAP(IL,8)))/4
       JACT21(U,V,IL)=(V*(-YMAP(IL,1)+YMAP(IL,2)-YMAP(IL,3)+YMAP(IL,4))-
     -      2*YMAP(IL,6)+2*U*((-1+V)*YMAP(IL,1)+(-1+V)*YMAP(IL,2)-
     -      YMAP(IL,3)-V*YMAP(IL,3)-YMAP(IL,4)-V*YMAP(IL,4)+
     -      2*YMAP(IL,5)-2*V*YMAP(IL,5)+2*YMAP(IL,7)+2*V*YMAP(IL,7))+
     -      V**2*(YMAP(IL,1)-YMAP(IL,2)-YMAP(IL,3)+YMAP(IL,4)+
     -      2*YMAP(IL,6)-2*YMAP(IL,8))+2*YMAP(IL,8))/4
       JACT22(U,V,IL)=(V*(XMAP(IL,1)-XMAP(IL,2)+XMAP(IL,3)-XMAP(IL,4))+
     -      2*U*(XMAP(IL,1)-V*XMAP(IL,1)+XMAP(IL,2)-V*XMAP(IL,2)+
     -      XMAP(IL,3)+V*XMAP(IL,3)+XMAP(IL,4)+V*XMAP(IL,4)-
     -      2*XMAP(IL,5)+2*V*XMAP(IL,5)-2*XMAP(IL,7)-2*V*XMAP(IL,7))+
     -      2*(XMAP(IL,6)-XMAP(IL,8))+V**2*(-XMAP(IL,1)+XMAP(IL,2)+
     -      XMAP(IL,3)-XMAP(IL,4)-2*XMAP(IL,6)+2*XMAP(IL,8)))/4
*** Debugging.
       IF(LIDENT)PRINT *,' /// ROUTINE MAPC5 ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   : Input'',
     -      '' point:       (x, y) = ('',E12.5,'' , '',E12.5,'')'')')
     -      X,Y
*** This may fail.
       IFAIL=1
*** For now, do not consider degenerate elements.
       IF(ELMDGN(IMAP))THEN
            T1=0
            T2=0
            IFAIL=1
            RETURN
       ENDIF
*** Set tolerance parameter.
       F=0.5
*** Make a first order approximation.
       CALL MAPC4(X,Y,Z,T1,T2,T3,T4,JAC,DET,IMAP,IFAIL)
*   Failure to do this, e.g. due to degenerate elements.
       IF(IFAIL.NE.0)THEN
C            PRINT *,' !!!!!! MAPC5  WARNING : Failure to obtain'//
C     -           ' linear estimate of isoparametric coordinates'//
C     -           ' in element ',IMAP
            T1=0
            T2=0
            RETURN
*   Check whether the point is far outside.
       ELSEIF(T1.LT.-1.0-F.OR.T1.GT.1.0+F.OR.
     -        T2.LT.-1.0-F.OR.T2.GT.1.0+F)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   :'',
     -           '' Point far outside: T1 = '',F12.9,'', T2 = '',
     -           F12.9)') T1,T2
            IFAIL=1
            RETURN
       ENDIF
*   Convert to double precision for subsequent calculations.
       TD1=DBLE(T1)
       TD2=DBLE(T2)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   :'',
     -      '' Linear estimate:   (u, v) = ('',F12.9,'' , '',F12.9,
     -      '')'')') TD1,TD2
*** Iterate to refine the estimate.
       DO 210 ITER=1,10
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   :'',
     -      '' Iteration '',I5,'':   (u, v) = ('',F12.9,'' , '',F12.9,
     -      '')'')') ITER,TD1,TD2
*   Re-compute the (x,y,z) position for this coordinate.
       XR=XMAP(IMAP, 1)*(-(1-TD1)*(1-TD2)*(1+TD1+TD2))/4+
     -    XMAP(IMAP, 2)*(-(1+TD1)*(1-TD2)*(1-TD1+TD2))/4+
     -    XMAP(IMAP, 3)*(-(1+TD1)*(1+TD2)*(1-TD1-TD2))/4+
     -    XMAP(IMAP, 4)*(-(1-TD1)*(1+TD2)*(1+TD1-TD2))/4+
     -    XMAP(IMAP, 5)*(1-TD1)*(1+TD1)*(1-TD2)/2+
     -    XMAP(IMAP, 6)*(1+TD1)*(1+TD2)*(1-TD2)/2+
     -    XMAP(IMAP, 7)*(1-TD1)*(1+TD1)*(1+TD2)/2+
     -    XMAP(IMAP, 8)*(1-TD1)*(1+TD2)*(1-TD2)/2
       YR=YMAP(IMAP, 1)*(-(1-TD1)*(1-TD2)*(1+TD1+TD2))/4+
     -    YMAP(IMAP, 2)*(-(1+TD1)*(1-TD2)*(1-TD1+TD2))/4+
     -    YMAP(IMAP, 3)*(-(1+TD1)*(1+TD2)*(1-TD1-TD2))/4+
     -    YMAP(IMAP, 4)*(-(1-TD1)*(1+TD2)*(1+TD1-TD2))/4+
     -    YMAP(IMAP, 5)*(1-TD1)*(1+TD1)*(1-TD2)/2+
     -    YMAP(IMAP, 6)*(1+TD1)*(1+TD2)*(1-TD2)/2+
     -    YMAP(IMAP, 7)*(1-TD1)*(1+TD1)*(1+TD2)/2+
     -    YMAP(IMAP, 8)*(1-TD1)*(1+TD2)*(1-TD2)/2
*   Store the Jacobian
       JAC(1,1)=JACT11(TD1,TD2,IMAP)
       JAC(1,2)=JACT12(TD1,TD2,IMAP)
       JAC(2,1)=JACT21(TD1,TD2,IMAP)
       JAC(2,2)=JACT22(TD1,TD2,IMAP)
       DET=DETT(TD1,TD2,IMAP)
*   Compute the difference vector
       DIFF(1)=X-XR
       DIFF(2)=Y-YR
*   Update the estimate
       DO 220 L=1,2
       CORR(L)=0.0D0
       DO 230 K=1,2
       CORR(L)=CORR(L)+JAC(L,K)*DIFF(K)/DET
230    CONTINUE
220    CONTINUE
*   Debugging
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   : '',
     -      ''Difference vector: (x, y) = ('',E12.5,
     -      '' , '',E12.5,''), max = '',E12.5/
     -      26X,''Correction vector: (u, v) = ('',F12.9,
     -      '' , '',F12.9,''), max = '',F12.9)')
     -      (DIFF(I),I=1,2),
     -      MAX(ABS(DIFF(1)),ABS(DIFF(2))),
     -      (CORR(I),I=1,2),
     -      MAX(ABS(CORR(1)),ABS(CORR(2)))
*   Update the vector.
       TD1=TD1+CORR(1)
       TD2=TD2+CORR(2)
*   Check for convergence.
       IF(MAX(ABS(CORR(1)),ABS(CORR(2))).LT.1E-5)GOTO 240
210    CONTINUE
       IF(X.GT.MIN(XMAP(IMAP,1),XMAP(IMAP,2),XMAP(IMAP,3),
     -      XMAP(IMAP,4)).AND.X.LT.MAX(XMAP(IMAP,1),XMAP(IMAP,2),
     -      XMAP(IMAP,3),XMAP(IMAP,4)).AND.
     -      Y.GT.MIN(YMAP(IMAP,1),YMAP(IMAP,2),YMAP(IMAP,3),
     -      YMAP(IMAP,4)).AND.Y.LT.MAX(YMAP(IMAP,1),YMAP(IMAP,2),
     -      YMAP(IMAP,3),YMAP(IMAP,4)))
     -      PRINT *,' !!!!!! MAPC5  WARNING : No convergence'//
     -           ' achieved when refining internal isoparametric'//
     -           ' coordinates in element ',IMAP,' at position ',
     -           X,Y
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   : Convergence'',
     -           '' failure in element '',I6,'' for:'')') IMAP
            WRITE(LUNOUT,'(2X,''Pos: '',2(F12.5,2X))') X,Y
            WRITE(LUNOUT,'(2X,''P1:  '',2(F12.5,2X))') XMAP(IMAP,1),
     -           YMAP(IMAP,1)
            WRITE(LUNOUT,'(2X,''P2:  '',2(F12.5,2X))') XMAP(IMAP,2),
     -           YMAP(IMAP,2)
            WRITE(LUNOUT,'(2X,''P3:  '',2(F12.5,2X))') XMAP(IMAP,3),
     -           YMAP(IMAP,3)
            WRITE(LUNOUT,'(2X,''P4:  '',2(F12.5,2X))') XMAP(IMAP,4),
     -           YMAP(IMAP,4)
       ENDIF
       T1=0
       T2=0
       IFAIL=1
       RETURN
*   Convergence reached.
240    CONTINUE
       T1=TD1
       T2=TD2
       T3=0
       T4=0
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   :'',
     -      '' Convergence reached.''/
     -      26X,''Final coordinates: (u, v) = ('',F12.9,'' , '',
     -      F12.9,'')'')') T1,T2
*   Success.
       IFAIL=0
*** Re-compute the (x,y,z) position for this coordinate.
       IF(LDEBUG)THEN
            XR=XMAP(IMAP, 1)*(-(1-TD1)*(1-TD2)*(1+TD1+TD2))/4+
     -         XMAP(IMAP, 2)*(-(1+TD1)*(1-TD2)*(1-TD1+TD2))/4+
     -         XMAP(IMAP, 3)*(-(1+TD1)*(1+TD2)*(1-TD1-TD2))/4+
     -         XMAP(IMAP, 4)*(-(1-TD1)*(1+TD2)*(1+TD1-TD2))/4+
     -         XMAP(IMAP, 5)*(1-TD1)*(1+TD1)*(1-TD2)/2+
     -         XMAP(IMAP, 6)*(1+TD1)*(1+TD2)*(1-TD2)/2+
     -         XMAP(IMAP, 7)*(1-TD1)*(1+TD1)*(1+TD2)/2+
     -         XMAP(IMAP, 8)*(1-TD1)*(1+TD2)*(1-TD2)/2
            YR=YMAP(IMAP, 1)*(-(1-TD1)*(1-TD2)*(1+TD1+TD2))/4+
     -         YMAP(IMAP, 2)*(-(1+TD1)*(1-TD2)*(1-TD1+TD2))/4+
     -         YMAP(IMAP, 3)*(-(1+TD1)*(1+TD2)*(1-TD1-TD2))/4+
     -         YMAP(IMAP, 4)*(-(1-TD1)*(1+TD2)*(1+TD1-TD2))/4+
     -         YMAP(IMAP, 5)*(1-TD1)*(1+TD1)*(1-TD2)/2+
     -         YMAP(IMAP, 6)*(1+TD1)*(1+TD2)*(1-TD2)/2+
     -         YMAP(IMAP, 7)*(1-TD1)*(1+TD1)*(1+TD2)/2+
     -         YMAP(IMAP, 8)*(1-TD1)*(1+TD2)*(1-TD2)/2
            WRITE(LUNOUT,'(''  ++++++ MAPC5  DEBUG   : Position'',
     -           '' requested:     ('',E12.5,'' , '',E12.5,'')''/
     -           26X,''Reconstructed: ('',E12.5,'' , '',E12.5,'')''/
     -           26X,''Difference:    ('',E12.5,'' , '',E12.5,'')'')')
     -           X,Y,XR,YR,X-XR,Y-YR
       ENDIF
       END
CDECK  ID>, BEMBAS.
       SUBROUTINE BEMBAS
*-----------------------------------------------------------------------
*   BEMBAS - Reduces panels to the basic period.
*   (Last changed on 12/ 5/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NPL,IPL,ICOL,IVOL,IFAIL1,IREF,NREF,NX,NY,NZ
       DOUBLE PRECISION XPL(MXPOIN),YPL(MXPOIN),ZPL(MXPOIN),APL,BPL,CPL,
     -      XC,YC,ZC,EPS
       LOGICAL MARK(MXPLAN)
*** Nothing to do if there is no periodicity.
       IF(.NOT.(PERX.OR.PERY.OR.PERZ))RETURN
*** Count panels.
       CALL PLABU1('QUERY',NREF,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMBAS WARNING : Unable to'//
     -           ' count the number of panels.'
            RETURN
       ENDIF
*** Keep track of panels already processed.
       DO 10 IREF=1,MXPLAN
       MARK(IREF)=.FALSE.
10     CONTINUE
*** Loop over the panels.
       DO 20 IREF=1,NREF
       IF(MARK(IREF))GOTO 20
*   Retrieve.
       CALL PLABU1('READ',IREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)GOTO 20
*   Determine centre of gravity.
       XC=0
       YC=0
       ZC=0
       DO 30 IPL=1,NPL
       XC=XC+XPL(IPL)
       YC=YC+YPL(IPL)
       ZC=ZC+ZPL(IPL)
30     CONTINUE
       XC=XC/NPL
       YC=YC/NPL
       ZC=ZC/NPL
*   Any change ?
       EPS=1.0D-6
       IF(PERX)THEN
            NX=ANINT(XC/SX)
            IF(ABS(XC/SX-ANINT(XC/SX)-0.5D0).LT.EPS)NX=NX+1
       ELSE
            NX=0
       ENDIF
       IF(PERY)THEN
            NY=ANINT(YC/SY)
            IF(ABS(YC/SY-ANINT(YC/SY)-0.5D0).LT.EPS)NY=NY+1
       ELSE
            NY=0
       ENDIF
       IF(PERZ)THEN
            NZ=ANINT(ZC/SZ)
            IF(ABS(ZC/SZ-ANINT(ZC/SZ)-0.5D0).LT.EPS)NZ=NZ+1
       ELSE
            NZ=0
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMBAS DEBUG   : Shifts '',
     -      3(F15.8,1X,I3,1X))') XC/SX,NX,YC/SY,NY,ZC/SZ,NZ
*   Skip if there is no shift.
       IF(NX.EQ.0.AND.NY.EQ.0.AND.NZ.EQ.0)GOTO 20
*   Shift for x-periodicity.
       IF(NX.NE.0)THEN
            DO 40 IPL=1,NPL
            XPL(IPL)=XPL(IPL)-SX*NX
40          CONTINUE
       ENDIF
*   Shift for y-periodicity.
       IF(NY.NE.0)THEN
            DO 50 IPL=1,NPL
            YPL(IPL)=YPL(IPL)-SY*NY
50          CONTINUE
       ENDIF
*   Shift for z-periodicity.
       IF(NZ.NE.0)THEN
            DO 60 IPL=1,NPL
            ZPL(IPL)=ZPL(IPL)-SZ*NZ
60          CONTINUE
       ENDIF
*   Store new and delete old.
       CALL PLABU1('DELETE',IREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)PRINT *,' !!!!!! BEMBAS WARNING : Unable to'//
     -      ' delete old panel.'
       CALL PLABU1('STORE',IREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0.OR.IREF.LE.0.OR.IREF.GE.MXPLAN)THEN
            PRINT *,' !!!!!! BEMBAS WARNING : Unable to store panel'//
     -           ' after move to basic period.'
            GOTO 20
       ENDIF
       MARK(IREF)=.TRUE.
*   Next panel.
20     CONTINUE
       END
CDECK  ID>, BEMBU1.
       SUBROUTINE BEMBU1(ACTION,IREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      IVOL1,IVOL2,IFAIL)
*-----------------------------------------------------------------------
*   BEMBU1 - Stores planes of surfaces. Almost a replica of PLABU1.
*   (Last changed on  5/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XBUF(MXPOIN),YBUF(MXPOIN),ZBUF(MXPOIN),
     -      ABUF(MXPLAN),BBUF(MXPLAN),CBUF(MXPLAN),
     -      XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),APL,BPL,CPL
C       double precision dpl
       INTEGER ICBUF(MXPLAN),IVBUF(MXPLAN),NBUF(MXPLAN),ISTART(MXPLAN),
     -      ICURR,IND(MXPLAN),II,IREF,NPL,IVOL1,IVOL2,IFAIL,I,J
       LOGICAL USE(MXPLAN)
       CHARACTER*(*) ACTION
       SAVE NBUF,XBUF,YBUF,ZBUF,ABUF,BBUF,CBUF,IVBUF,ICBUF,
     -      ISTART,ICURR,USE
       DATA ICURR/0/,USE/MXPLAN*.FALSE./,ISTART/MXPLAN*-1/
*** Assume failure.
       IFAIL=1
*** Store a new plane.
       IF(ACTION.EQ.'STORE')THEN
*   Basic check on the data.
            IF(NPL.LT.0.OR.NPL.GT.MXEDGE)THEN
                 PRINT *,' !!!!!! BEMBU1 WARNING : Number of points'//
     -                ' on polygon < 0 or > MXEDGE ; not stored.'
                 RETURN
            ENDIF
*   See whether there is a free slot.
            IREF=0
            DO 10 I=1,MXPLAN
            IF(.NOT.USE(I))THEN
                 IREF=I
                 GOTO 20
            ENDIF
10          CONTINUE
            PRINT *,' !!!!!! BEMBU1 WARNING : No room to store'//
     -           ' further polygons ; increase MXPLAN.'
            RETURN
20          CONTINUE
*   See whether there is free space, garbage collect if not.
            IF(ICURR+NPL.GT.MXPOIN)THEN
C                 CALL SORTZV(ISTART,IND,MXPLAN,-1,0,0)
                 DO 15 I=1,MXPLAN
                 IND(I)=I
15               CONTINUE
                 CALL SORTTI(ISTART,IND,MXPLAN)
                 ICURR=0
                 DO 30 II=1,MXPLAN
                 I=IND(II)
                 IF(ISTART(I).LT.0.OR..NOT.USE(I))GOTO 30
                 DO 40 J=1,NBUF(I)
                 XBUF(ICURR+J)=XBUF(ISTART(I)+J)
                 YBUF(ICURR+J)=YBUF(ISTART(I)+J)
                 ZBUF(ICURR+J)=ZBUF(ISTART(I)+J)
40               CONTINUE
                 ISTART(I)=ICURR
                 ICURR=ICURR+NBUF(I)
30               CONTINUE
            ENDIF
*   See whether there now is enough space.
            IF(ICURR+NPL.GT.MXPOIN)THEN
                 PRINT *,' !!!!!! BEMBU1 WARNING : No room to store'//
     -                ' further points; increase MXPOIN.'
                 RETURN
            ENDIF
*   Store the polygon.
            ISTART(IREF)=ICURR
            USE(IREF)=.TRUE.
            NBUF(IREF)=NPL
            ABUF(IREF)=APL
            BBUF(IREF)=BPL
            CBUF(IREF)=CPL
            ICBUF(IREF)=IVOL1
            IVBUF(IREF)=IVOL2
C            dpl=0
            DO 50 I=1,NPL
            XBUF(ISTART(IREF)+I)=XPL(I)
            YBUF(ISTART(IREF)+I)=YPL(I)
            ZBUF(ISTART(IREF)+I)=ZPL(I)
C            dpl=dpl+apl*xpl(i)+bpl*ypl(i)+cpl*zpl(i)
50          CONTINUE
C            dpl=dpl/npl
C            do i=1,npl
C            if(abs(dpl-xpl(i)*apl-ypl(i)*bpl-zpl(i)*cpl).gt.1e-4)then
C                 print *,' BEMBU1 Offset Error: '
C                 print *,' Point:   ',xpl(i),ypl(i),zpl(i)
C                 print *,' Error:   ',dpl-xpl(i)*apl-ypl(i)*bpl-
C     -                cpl*zpl(i)
C            endif
C            enddo
            ICURR=ICURR+NPL
*** Read back a plane.
       ELSEIF(ACTION.EQ.'READ')THEN
*   Basic checks of the index.
            IF(IREF.LT.1.OR.IREF.GT.MXPLAN)THEN
                 PRINT *,' !!!!!! BEMBU1 WARNING : Polygon reference'//
     -                ' number out of range; not read.'
                 RETURN
            ELSEIF(.NOT.USE(IREF))THEN
                 IF(LDEBUG)PRINT *,' ++++++ BEMBU1 DEBUG   :'//
     -                ' Requested polygon is not defined; not read.'
                 RETURN
            ENDIF
*   Return the polygon.
            DO 100 I=1,NBUF(IREF)
            XPL(I)=XBUF(ISTART(IREF)+I)
            YPL(I)=YBUF(ISTART(IREF)+I)
            ZPL(I)=ZBUF(ISTART(IREF)+I)
100         CONTINUE
            APL=ABUF(IREF)
            BPL=BBUF(IREF)
            CPL=CBUF(IREF)
            IVOL1=ICBUF(IREF)
            IVOL2=IVBUF(IREF)
            NPL=NBUF(IREF)
*** Delete a plane.
       ELSEIF(ACTION.EQ.'DELETE')THEN
*   Basic checks of the index.
            IF(IREF.LT.1.OR.IREF.GT.MXPLAN)THEN
                 PRINT *,' !!!!!! BEMBU1 WARNING : Polygon reference'//
     -                ' number out of range; not deleted.'
                 RETURN
            ELSEIF(.NOT.USE(IREF))THEN
                 PRINT *,' ------ BEMBU1 MESSAGE : Requested polygon'//
     -                ' is currently not defined.'
                 RETURN
            ENDIF
*   Delete the polygon.
            USE(IREF)=.FALSE.
            ISTART(IREF)=-1
*** Reset the buffer.
       ELSEIF(ACTION.EQ.'RESET'.OR.ACTION.EQ.'INITIALISE')THEN
            ICURR=0
            DO 200 I=1,MXPLAN
            NBUF(I)=0
            USE(I)=.FALSE.
            ISTART(I)=-1
200         CONTINUE
*** List the buffer.
       ELSEIF(ACTION.EQ.'LIST'.OR.ACTION.EQ.'PRINT')THEN
            DO 300 I=1,MXPLAN
            IF(USE(I))THEN
                 WRITE(LUNOUT,'(2X,''Polygon '',I4,'' is stored '',
     -                '' from '',I4)') I,ISTART(I)
                 WRITE(LUNOUT,'(2X,''Colour index:     '',I5)') ICBUF(I)
                 WRITE(LUNOUT,'(2X,''Volume index:     '',I5)') IVBUF(I)
                 WRITE(LUNOUT,'(2X,''Plane parameters: '',3E15.8)') 
     -                ABUF(I),BBUF(I),CBUF(I)
                 WRITE(LUNOUT,'(2X,''Number of points: '',I5)') 
     -                NBUF(I)
                 DO 310 J=1,NBUF(I)
                 WRITE(LUNOUT,'(10X,3E15.8)') XBUF(ISTART(I)+J),
     -                YBUF(ISTART(I)+J),ZBUF(ISTART(I)+J)
310              CONTINUE
            ENDIF
300         CONTINUE
*** Query of maximum numbers.
       ELSEIF(ACTION.EQ.'QUERY')THEN
            DO 400 I=MXPLAN,1,-1
            IF(USE(I))THEN
                 IREF=I
                 GOTO 410
            ENDIF
400         CONTINUE
            IREF=0
410         CONTINUE
*** Other actions not known.
       ELSE
            PRINT *,' !!!!!! BEMBU1 WARNING : Unknown action ',
     -           ACTION,' received ; nothing done.'
            IFAIL=1
            RETURN
       ENDIF
*** Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, BEMCHK.
       SUBROUTINE BEMCHK(NPL,XPL,YPL,ZPL,IFAIL)
*-----------------------------------------------------------------------
*   BEMCHK - Removes duplicate branches from a curve.
*   (Last changed on 16/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NPL,I,J,IFAIL,NNEW,JCUT
       DOUBLE PRECISION XPL(NPL),YPL(NPL),ZPL(NPL),EPS,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX
       LOGICAL MARK(MXEDGE)
*** Initial settings.
       IFAIL=1
*** Check number of points.
       IF(NPL.GT.MXEDGE)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCHK DEBUG   :'',
     -           '' Rejected - Too many points.'')')
            RETURN
       ELSEIF(NPL.LT.3)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCHK DEBUG   :'',
     -           '' Rejected - Too few points.'')')
            RETURN
       ENDIF
*** Set tolerances.
       XMIN=XPL(1)
       XMAX=XPL(1)
       YMIN=YPL(1)
       YMAX=YPL(1)
       ZMIN=ZPL(1)
       ZMAX=ZPL(1)
       DO 10 I=2,NPL
       XMIN=MIN(XMIN,XPL(I))
       XMAX=MAX(XMAX,XPL(I))
       YMIN=MIN(YMIN,YPL(I))
       YMAX=MAX(YMAX,YPL(I))
       ZMIN=MIN(ZMIN,ZPL(I))
       ZMAX=MAX(ZMAX,ZPL(I))
10     CONTINUE
*   Set epsilons accordingly.
       EPS=1.0D-6*(1+ABS(XMAX-XMIN)+ABS(YMAX-YMIN)+ABS(ZMAX-ZMIN))
*** Make a first marker list.
1010   CONTINUE
       DO 20 I=1,NPL
       MARK(I)=.FALSE.
20     CONTINUE
*** Find a point that is surrounded on both side by equal points.
       DO 30 I=1,NPL
       JCUT=0
       DO 40 J=1,NPL/2
       IF((XPL(1+MOD(I+J-1,NPL))-XPL(1+MOD(I-J-1+NPL,NPL)))**2+
     -    (YPL(1+MOD(I+J-1,NPL))-YPL(1+MOD(I-J-1+NPL,NPL)))**2+
     -    (ZPL(1+MOD(I+J-1,NPL))-ZPL(1+MOD(I-J-1+NPL,NPL)))**2.GT.
     -    EPS**2)GOTO 50
       JCUT=J
40     CONTINUE
50     CONTINUE
*   See whether we found one.
       IF(JCUT.GT.0)THEN
      print *,' Cutting a tail of ',JCUT,' points.'
            DO 60 J=I-JCUT+1,I+JCUT
            MARK(1+MOD(J-1+NPL,NPL))=.TRUE.
60          CONTINUE
            GOTO 1000
       ENDIF
30     CONTINUE
*** Check for successive identical points.
       DO 70 I=1,NPL
       IF(  (XPL(I)-XPL(1+MOD(I,NPL)))**2+
     -      (YPL(I)-YPL(1+MOD(I,NPL)))**2+
     -      (ZPL(I)-ZPL(1+MOD(I,NPL)))**2.LT.
     -      EPS**2)THEN
      print *,' Found identical points.'
            MARK(I)=.TRUE.
            GOTO 1000
       ENDIF
70     CONTINUE
*** Done.
       IFAIL=1
       IF(NPL.GT.2)IFAIL=0
       RETURN
*** Eliminate the piece.
1000   CONTINUE
       NNEW=0
       DO 80 I=1,NPL
       IF(MARK(I))GOTO 80
       NNEW=NNEW+1
       XPL(NNEW)=XPL(I)
       YPL(NNEW)=YPL(I)
       ZPL(NNEW)=ZPL(I)
80     CONTINUE
       NPL=NNEW
       GOTO 1010
*** Seems OK
       IFAIL=0
       END
CDECK  ID>, BEMCUT.
       SUBROUTINE BEMCUT(IREF, NREFO, IREFO, A,B,C, X0,Y0,Z0)
*-----------------------------------------------------------------------
*   BEMCUT - Cuts one plane with another and keeps only a part.
*            Part kept: a (x-x0) + b (y-y0) + c (z-z0) > 0.
*            Works only for convex areas.
*   (Last changed on 16/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NPL,I,J,NOUT,IREF,NREFO,IREFO(*),IFAIL1,ICOL,IVOL,
     -      CLASS(MXEDGE)
       DOUBLE PRECISION XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),
     -      A,B,C, X0,Y0,Z0, APL,BPL,CPL,DIST,DIST1,EPSD,
     -      PROD1,PROD2,XLAM,XOUT(MXEDGE),YOUT(MXEDGE),ZOUT(MXEDGE)
*** Number of output planes.
       NREFO=0
*** Check normal vector of plane
       IF(A**2+B**2+C**2.LE.0)THEN
            PRINT *,' !!!!!! BEMCUT WARNING : Normal vector of plane'//
     -           ' has zero norm; no cut applied.'
            RETURN
       ENDIF
*** Retrieve the panel.
       CALL PLABU1('READ',IREF,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMCUT WARNING : Unable to retrieve the'//
     -           ' panel; no cut applied.'
            RETURN
*   Check dimensions.
       ELSEIF(NPL.GT.MXEDGE)THEN
            PRINT *,' !!!!!! BEMCUT WARNING : Array dimensions not'//
     -           ' sufficient; no cut applied.'
            RETURN
       ENDIF
*** Debugging.
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   : '',
     -               ''Panel identifier: '',I5/
     -           26X,''Panel normal:     '',3F15.8/
     -           26X,''Cut plane normal: '',3F15.8/
     -           26X,''Cut plane point:  '',3F15.8/
     -           26X,''Polygon:'')') IREF,APL,BPL,CPL,A,B,C,X0,Y0,Z0
            DO 60 I=1,NPL
            WRITE(LUNOUT,'(26X,3F15.8)') XPL(I),YPL(I),ZPL(I)
60          CONTINUE
       ENDIF
*** Set a tolerance for lambda.
       DIST=0
       DO 20 I=1,NPL
       DIST1=ABS((X0-XPL(I))*A+(Y0-YPL(I))*B+(Z0-ZPL(I))*C)/
     -      SQRT(A**2+B**2+C**2)
       IF(DIST1.GT.DIST)DIST=DIST1
       DO 30 J=I+1,NPL
       DIST1=SQRT((XPL(I)-XPL(J))**2+(YPL(I)-YPL(J))**2+
     -      (ZPL(I)-ZPL(J))**2)
       IF(DIST1.GT.DIST)DIST=DIST1
30     CONTINUE
20     CONTINUE
       IF(DIST.LE.0)THEN
            PRINT *,' !!!!!! BEMCUT WARNING : Maximum distance'//
     -           ' equal to zero; no cut applied.'
            RETURN
       ENDIF
       EPSD=1.0D-8*DIST
*** Check for coincident cut plane and panel.
       IF(ABS(ABS(A*APL+B*BPL+C*CPL)-SQRT((A**2+B**2+C**2)*
     -      (APL**2+BPL**2+CPL**2))).LE.1.0D-6*SQRT((A**2+B**2+C**2)*
     -      (APL**2+BPL**2+CPL**2)))THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   :'',
     -           '' Parallel cut-plane and panel.'')')
            DIST=0
            DO 50 I=1,NPL
            DIST=DIST+A*(XPL(I)-X0)+B*(YPL(I)-Y0)+C*(ZPL(I)-Z0)
50          CONTINUE
            IF(DIST.GE.-EPSD*SQRT(A**2+B**2+C**2))THEN
                 NREFO=1
                 CALL PLABU1('STORE',IREFO(NREFO),NPL,XPL,YPL,ZPL,
     -                APL,BPL,CPL,ICOL,IVOL,IFAIL1)
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   :'',
     -                '' Accepted as a whole.'')')
            ELSE
                 NREFO=0
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   :'',
     -                '' Rejected as a whole.'')')
            ENDIF
            RETURN
       ENDIF
*** Loop over the points to classify them
       DO 10 I=1,NPL
       PROD1=((X0-XPL(I))*A+(Y0-YPL(I))*B+(Z0-ZPL(I))*C)/
     -      SQRT(A**2+B**2+C**2)
       IF(ABS(PROD1).LE.EPSD)THEN
            CLASS(I)=0
       ELSEIF(PROD1.LT.0)THEN
            CLASS(I)=+1
       ELSE
            CLASS(I)=-1
       ENDIF
C      print *,' Point ',I,': class: ',class(i)
10     CONTINUE
*** Add points as appropriate.
       NOUT=0
       DO 40 I=1,NPL
C      print *,' *** Point ',I
*   If inside or on the edge, add point 1
       IF(CLASS(I).GE.0)THEN
            NOUT=NOUT+1
            XOUT(NOUT)=XPL(I)
            YOUT(NOUT)=YPL(I)
            ZOUT(NOUT)=ZPL(I)
       ENDIF
*   If going in or out, add the crossing point.
       IF(CLASS(I)*CLASS(1+MOD(I,NPL)).EQ.-1)THEN
            PROD1=(X0               -XPL(I))*A+
     -            (Y0               -YPL(I))*B+
     -            (Z0               -ZPL(I))*C
            PROD2=(XPL(1+MOD(I,NPL))-XPL(I))*A+
     -            (YPL(1+MOD(I,NPL))-YPL(I))*B+
     -            (ZPL(1+MOD(I,NPL))-ZPL(I))*C
*   Check for midpoint crossing
            IF(PROD2**2.GT.1.0D-12*(A**2+B**2+C**2)*(
     -           (XPL(1+MOD(I,NPL))-XPL(I))**2+
     -           (YPL(1+MOD(I,NPL))-YPL(I))**2+
     -           (ZPL(1+MOD(I,NPL))-ZPL(I))**2))THEN
                 XLAM=PROD1/PROD2
            ELSE
      print *,' !!! prod2 = 0'
                 XLAM=0.5
            ENDIF
C      print *,'     lambda = ',xlam
            XLAM=MAX(0.0D0,MIN(1.0D0,XLAM))
            NOUT=NOUT+1
            XOUT(NOUT)=XPL(I)+XLAM*(XPL(1+MOD(I,NPL))-XPL(I))
            YOUT(NOUT)=YPL(I)+XLAM*(YPL(1+MOD(I,NPL))-YPL(I))
            ZOUT(NOUT)=ZPL(I)+XLAM*(ZPL(1+MOD(I,NPL))-ZPL(I))
       ENDIF
40     CONTINUE
*** Copy back the result.
       CALL BEMCHK(NOUT,XOUT,YOUT,ZOUT,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   :'',
     -           '' Did not pass BEMCHK.'')')
       ELSE
            NREFO=NREFO+1
            CALL PLABU1('STORE',IREFO(NREFO),NOUT,XOUT,YOUT,ZOUT,
     -           APL,BPL,CPL,ICOL,IVOL,IFAIL1)
            IF(LDEBUG)THEN
                 WRITE(LUNOUT,'(''  ++++++ BEMCUT DEBUG   : '',
     -                ''Stored after applying cuts.''/
     -                26X,''Panel identifier: '',I5/
     -                26X,''Polygon:'')') IREFO(NREFO)
                 DO 70 I=1,NOUT
                 WRITE(LUNOUT,'(26X,3F15.8)') XOUT(I),YOUT(I),ZOUT(I)
70               CONTINUE
            ENDIF
       ENDIF
       END
CDECK  ID>, BEMSZD.
       SUBROUTINE BEMSZD(IPRIM,DIS,IFAIL)
*-----------------------------------------------------------------------
*   BEMSZD - Determines the discretisation size for a panel.
*            Returns discretisation size in cm, scaled in neBEM
*   (Last changed on 11/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       INTEGER IPRIM, NVTX, ISOL1, ISOL2, IFAIL, IFAIL1, IWIRE, IVOL
       DOUBLE PRECISION XVTX(MXEDGE), YVTX(MXEDGE), ZVTX(MXEDGE),
     -      XNORM, YNORM, ZNORM, DIS, DIS1, DIS2
*** Default response.
       DIS=0.1
       IFAIL=1
*** See whether this is a wire.
       IF(IPRIM.GT.NBEM)THEN
            IWIRE=0
            DO 10 IVOL=1,NSOLID
            IF(ISOLTP(IVOL).NE.1)GOTO 10
            IF(CBUF(ISTART(IVOL)+9).LT.-0.5)IWIRE=IWIRE+1
            IF(IWIRE.EQ.IPRIM-NBEM)THEN
                 DIS=CBUF(ISTART(IVOL)+21)
                 IFAIL=0
                 RETURN
            ENDIF
10          CONTINUE
            PRINT *,' !!!!!! BEMSZD WARNING : Did not find the'//
     -           ' cylinder corresponding to primitive ',IPRIM
            IFAIL=1
            RETURN
       ENDIF
*** Retrieve the panel to determine the solid and norms.
       CALL BEMBU1('READ',IREFB1(IPRIM),NVTX,XVTX,YVTX,ZVTX,
     -      XNORM,YNORM,ZNORM,
     -      ISOL2,ISOL1,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMSZD WARNING : Unable to retrieve'//
     -           ' primitive ',IPRIM
            IFAIL=1
            RETURN
       ENDIF
*** Work out which type solid 1 is.
       IF(ISOL1.GT.NSOLID)THEN
            PRINT *,' !!!!!! BEMSZD WARNING : Solid 1 reference ',ISOL1,
     -           ' out of range; no data returned.'
            IFAIL=1
            RETURN
*   Does not exist.
       ELSEIF(ISOL1.LT.1)THEN
            DIS1=-1
            GOTO 1000
*   Cylinder.
       ELSEIF(ISOLTP(ISOL1).EQ.1)THEN
            CALL PLACYD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Hole.
       ELSEIF(ISOLTP(ISOL1).EQ.2)THEN
            CALL PLACHD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Box.
       ELSEIF(ISOLTP(ISOL1).EQ.3)THEN
            CALL PLABXD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Sphere.
       ELSEIF(ISOLTP(ISOL1).EQ.4)THEN
            CALL PLASPD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Toblerone.
       ELSEIF(ISOLTP(ISOL1).EQ.5)THEN
            CALL PLATBD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Extrusion.
       ELSEIF(ISOLTP(ISOL1).EQ.6)THEN
            CALL PLAEXD(ISOL1,NVTX,XVTX,YVTX,ZVTX,
     -           XNORM,YNORM,ZNORM,DIS1)
*   Anything else.
       ELSE
            PRINT *,' !!!!!! BEMSZD WARNING : Unknown solid 1 shape.'
            IFAIL=1
            RETURN
       ENDIF
C      print *,' Solid 1: Primitive: ',iprim,' nvtx = ',nvtx,
C     -      ' solids: ',isol1, isol2,' Discretisation size: ',dis1
*** Solid 2.
1000   CONTINUE
       IF(ISOL2.GT.NSOLID)THEN
            PRINT *,' !!!!!! BEMSZD WARNING : Solid 2 reference ',ISOL2,
     -           ' out of range; no data returned.'
            IFAIL=1
            RETURN
*   Does not exist.
       ELSEIF(ISOL2.LT.1)THEN
            DIS2=-1
            GOTO 2000
*   Cylinder.
       ELSEIF(ISOLTP(ISOL2).EQ.1)THEN
            CALL PLACYD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Hole.
       ELSEIF(ISOLTP(ISOL2).EQ.2)THEN
            CALL PLACHD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Box.
       ELSEIF(ISOLTP(ISOL2).EQ.3)THEN
            CALL PLABXD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Sphere.
       ELSEIF(ISOLTP(ISOL2).EQ.4)THEN
            CALL PLASPD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Toblerone.
       ELSEIF(ISOLTP(ISOL2).EQ.5)THEN
            CALL PLATBD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Extrusion.
       ELSEIF(ISOLTP(ISOL2).EQ.6)THEN
            CALL PLAEXD(ISOL2,NVTX,XVTX,YVTX,ZVTX,
     -           -XNORM,-YNORM,-ZNORM,DIS2)
*   Anything else.
       ELSE
            PRINT *,' !!!!!! BEMSZD WARNING : Unknown solid 2 shape.'
            IFAIL=1
            RETURN
       ENDIF
C      print *,' Solid 2: Primitive: ',iprim,' nvtx = ',nvtx,
C     -      ' solids: ',isol1, isol2,' Discretisation size: ',dis2
*** Combine.
2000   CONTINUE
       IF(DIS1.LT.0.AND.DIS2.LT.0)THEN
            DIS=-1
       ELSEIF(DIS1.LT.0)THEN
            DIS=DIS2
       ELSEIF(DIS2.LT.0)THEN
            DIS=DIS1
       ELSE
            DIS=MIN(DIS1,DIS2)
       ENDIF
C      print *,' Assigned discretisation: ',dis
*** Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, BEMINT.
       SUBROUTINE BEMINT(IFAIL)
*-----------------------------------------------------------------------
*   BEMINT - Calls the initialisation of neBEM
*   (Last changed on 15/ 4/12.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IFAIL,IVOL,IREF,NREF,ICOL,IPL,NPL,I,IMAX,IBEMST,
     -      ISHAPE1,IMAT1,IBOUND1,IFAIL1,ISHAPE2,IMAT2,IBOUND2,IFAIL2,
     -      IDEBUG
       DOUBLE PRECISION XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),APL,BPL,CPL,
     -      BXMIN,BXMAX,BYMIN,BYMAX,BZMIN,BZMAX,DIST,
     -      EPS1,VOLT1,CHARGE1,EPS2,VOLT2,CHARGE2
       LOGICAL SET
*** Assume this will fail.
       IFAIL=1
*** Check that some solids exist.
       IF(NSOLID.LE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : No solids have been'//
     -           ' defined sofar; no point in running neBEM.'
            RETURN
       ENDIF
*** Check the neBEM status.
       CALL BEMQST(IBEMST)
       IF(IBEMST.LT.1)THEN
            PRINT *,' !!!!!! BEMINT WARNING : neBEM initialisation'//
     -           ' not done yet; trying to do this now.'
            CALL BEMINI(IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! BEMINT WARNING : Failed to'//
     -                ' initialise neBEM; no preparation done.'
                 RETURN
            ENDIF
       ELSEIF(IBEMST.GT.1)THEN
            PRINT *,' ------ BEMINT MESSAGE : neBEM already used;'//
     -           ' re-initialising.'
            CALL BEMEND
            CALL BEMINI(IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! BEMINT WARNING : Failed to'//
     -                ' initialise neBEM; no preparation done.'
                 RETURN
            ENDIF
       ENDIF
*** Progress printing.
       CALL PROINT('neBEM',1,6)
*** Be sure we won't have intersections with the bounding box.
       CALL PROFLD(1,'Finding envelope',-1.0)
       CALL PROSTA(1,0.0)
       DO 40 IVOL=1,NSOLID
       ICOL=0
       CALL PROSTA(1,REAL(IVOL))
*   cylinders ...
       IF(ISOLTP(IVOL).EQ.1)THEN
            CALL PLACYE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   cylindrical holes ...
       ELSEIF(ISOLTP(IVOL).EQ.2)THEN
            CALL PLACHE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   boxes ...
       ELSEIF(ISOLTP(IVOL).EQ.3)THEN
            CALL PLABXE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   spheres ...
       ELSEIF(ISOLTP(IVOL).EQ.4)THEN
            CALL PLASPE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   Toblerone ...
       ELSEIF(ISOLTP(IVOL).EQ.5)THEN
            CALL PLATBE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   extrusion ...
       ELSEIF(ISOLTP(IVOL).EQ.6)THEN
            CALL PLAEXE(IVOL,BXMIN,BYMIN,BZMIN,BXMAX,BYMAX,BZMAX)
*   other things not known.
       ELSE
            PRINT *,' !!!!!! BEMINT WARNING : Solid of unknown type ',
     -           ISOLTP(IVOL),'; not considered for envelope.'
            GOTO 40
       ENDIF
       IF(IVOL.EQ.1)THEN
            GXMIN=BXMIN
            GXMAX=BXMAX
            GYMIN=BYMIN
            GYMAX=BYMAX
            GZMIN=BZMIN
            GZMAX=BZMAX
       ELSE
            GXMIN=MIN(BXMIN,GXMIN)
            GXMAX=MAX(BXMAX,GXMAX)
            GYMIN=MIN(BYMIN,GYMIN)
            GYMAX=MAX(BYMAX,GYMAX)
            GZMIN=MIN(BZMIN,GZMIN)
            GZMAX=MAX(BZMAX,GZMAX)
       ENDIF
40     CONTINUE
*   Enlarge a bit.
       DIST=0.01*ABS(GXMAX-GXMIN)
       GXMIN=GXMIN-DIST
       GXMAX=GXMAX+DIST
       DIST=0.01*ABS(GYMAX-GYMIN)
       GYMIN=GYMIN-DIST
       GYMAX=GYMAX+DIST
       DIST=0.01*ABS(GZMAX-GZMIN)
       GZMIN=GZMIN-DIST
       GZMAX=GZMAX+DIST
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMINT DEBUG   : Envelope''/
     -      26X,E12.5,'' < x < '',E12.5/26X,E12.5,'' < y < '',E12.5/
     -      26X,E12.5,'' < z < '',E12.5)') 
     -      GXMIN,GXMAX,GYMIN,GYMAX,GZMIN,GZMAX
*** Calculate the absolute size threshold accordingly
       BEMSTH=BEMSSC*MAX(GXMAX-GXMIN,GYMAX-GYMIN,GZMAX-GZMIN)**2
*** Pass the option parameters to neBEM.
       IF(LDEBUG)THEN
            IDEBUG=10
       ELSE
            IDEBUG=0
       ENDIF
       CALL BEMPAR(NBEMMN,NBEMMX,BEMTGT,BEMNEW,BEMINV,IDEBUG,BEMSLV)
*** Reset the buffer of the panels.
       CALL PLABU1('RESET',IREF,0,XPL,YPL,ZPL,
     -      0.0D0,0.0D0,0.0D0,0,0,IFAIL1)
       CALL BEMBU1('RESET',IREF,0,XPL,YPL,ZPL,
     -      0.0D0,0.0D0,0.0D0,0,0,IFAIL1)
*** Generate the list of surface pannels.
       CALL PROFLD(1,'Generating volumes',REAL(NSOLID))
       DO 10 IVOL=1,NSOLID
       ICOL=0
       CALL PROSTA(1,REAL(IVOL))
*   cylinders and wires ...
       IF(ISOLTP(IVOL).EQ.1)THEN
            IF(CBUF(ISTART(IVOL)+9).LT.-0.5)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMINT DEBUG   :'',
     -                '' Skipping wire volume '',I5)') IVOL
            ELSE
                 CALL PLACYP(IVOL,ICOL)
            ENDIF
*   cylindrical holes ...
       ELSEIF(ISOLTP(IVOL).EQ.2)THEN
            CALL PLACHP(IVOL,ICOL)
*   boxes ...
       ELSEIF(ISOLTP(IVOL).EQ.3)THEN
            CALL PLABXP(IVOL,ICOL)
*   spheres ...
       ELSEIF(ISOLTP(IVOL).EQ.4)THEN
            CALL PLASPP(IVOL,ICOL)
*   Toblerone ...
       ELSEIF(ISOLTP(IVOL).EQ.5)THEN
            CALL PLATBP(IVOL,ICOL)
*   extrusion ...
       ELSEIF(ISOLTP(IVOL).EQ.6)THEN
            CALL PLAEXP(IVOL,ICOL)
*   other things not known.
       ELSE
            PRINT *,' !!!!!! BEMINT WARNING : Asked to plot a'//
     -           ' solid of unknown type ',ISOLTP(IVOL),
     -           '; not plotted.'
       ENDIF
10     CONTINUE
*** Apply cuts.
       CALL CELSCT('APPLY')
*** Find a volume which encloses all solids.
       CALL PROFLD(1,'Finding bounding box',-1.0)
       CALL PROSTA(1,0.0)
*   Count panels.
       CALL PLABU1('QUERY',NREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMINT DEBUG   : After'',
     -      '' generating, '',I5,'' panels.'')') NREF
*   Make sure that the buffer is OK.
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : Unable to count the'//
     -           ' panels for the solid.'
            CALL PROEND
            RETURN
       ENDIF
*   Loop over all panels.
       SET=.FALSE.
       DO 20 IREF=1,NREF
       CALL PLABU1('READ',IREF,NPL,XPL,YPL,ZPL,APL,BPL,CPL,
     -      ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)GOTO 20
       DO 30 IPL=1,NPL
       IF(SET)THEN
            XMIN=MIN(XMIN,XPL(IPL))
            XMAX=MAX(XMAX,XPL(IPL))
            YMIN=MIN(YMIN,YPL(IPL))
            YMAX=MAX(YMAX,YPL(IPL))
            ZMIN=MIN(ZMIN,ZPL(IPL))
            ZMAX=MAX(ZMAX,ZPL(IPL))
       ELSE
            XMIN=XPL(IPL)
            XMAX=XPL(IPL)
            YMIN=YPL(IPL)
            YMAX=YPL(IPL)
            ZMIN=ZPL(IPL)
            ZMAX=ZPL(IPL)
            SET=.TRUE.
       ENDIF
30     CONTINUE
20     CONTINUE
*** Reduce to basic periodic copy.
       CALL BEMBAS
*** Find contact panels.
       CALL PROFLD(1,'Finding contacts',-1.0)
       CALL PROSTA(1,0.0)
       CALL PLABEM(IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : Finding the'//
     -           ' contact panels failed; neBEM not called.'
            CALL PROEND
            RETURN
       ENDIF
*** Count the number of effectively existing panels.
       CALL PROFLD(1,'Counting surfaces',-1.0)
       CALL PROSTA(1,0.0)
       CALL PLABU1('QUERY',IMAX,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       NBEM=0
       DO 50 I=1,IMAX
*   Retrieve a panel.
       CALL PLABU1('READ',I,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       IF(IFAIL1.NE.0)GOTO 50
*   See whether this is trivial.
       CALL BEMVOL(IVOL,ISHAPE1,IMAT1,EPS1,VOLT1,CHARGE1,IBOUND1,IFAIL1)
       CALL BEMVOL(ICOL,ISHAPE2,IMAT2,EPS2,VOLT2,CHARGE2,IBOUND2,IFAIL2)
       IF(IFAIL1.NE.0.OR.IFAIL2.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : Failure when retrieving'//
     -           ' volume properties; primitive kept.'
       ELSEIF(IBOUND1.EQ.1.AND.IBOUND2.EQ.1.AND.
     -      ABS(VOLT1-VOLT2).LT.1.0D-6*(1+ABS(VOLT1)+ABS(VOLT2)))THEN
            PRINT *,' ++++++ BEMINT DEBUG   : Same voltage, skipped.'
            GOTO 50
       ELSEIF(IBOUND1.EQ.4.AND.IBOUND2.EQ.4.AND.
     -      ABS(EPS1-EPS2).LT.1.0D-6*(1+ABS(EPS1)+ABS(EPS2)))THEN
            PRINT *,' ++++++ BEMINT DEBUG   : Same epsilon, skipped.'
            GOTO 50
       ELSEIF(IBOUND1.EQ.0.AND.IBOUND2.EQ.4.AND.
     -      ABS(EPS2-1.0).LT.1.0D-6)THEN
            PRINT *,' ++++++ BEMINT DEBUG   : Gas to Eps=1, skipped.'
            GOTO 50
       ELSEIF(IBOUND2.EQ.0.AND.IBOUND1.EQ.4.AND.
     -      ABS(EPS1-1.0).LT.1.0D-6)THEN
            PRINT *,' ++++++ BEMINT DEBUG   : Eps=1 to gas, skipped.'
            GOTO 50
       ENDIF
*   Store.
       CALL BEMBU1('STORE',IREF,NPL,XPL,YPL,ZPL,
     -      APL,BPL,CPL,ICOL,IVOL,IFAIL1)
       NBEM=NBEM+1
       IREFB1(NBEM)=IREF
50     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMINT DEBUG   : Highest'',
     -      '' panel: '',I5,'', existing panels: '',I5)')
     -      IMAX,NBEM
*** Transfer the geometry.
       CALL PROFLD(1,'Reading geometry',-1.0)
       CALL PROSTA(1,0.0)
       CALL BEMGEO(IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : neBEM'//
     -           ' reading of the solid structure failed.'
            CALL PROEND
            RETURN
       ENDIF
*** Discretise.
       CALL PROFLD(1,'Generating elements',-1.0)
       CALL PROSTA(1,0.0)
       CALL BEMDIS(IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : neBEM'//
     -           ' element generation failed.'
            CALL PROEND
            RETURN
       ENDIF
*** Establish boundary conditions.
       CALL PROFLD(1,'Boundary conditions',-1.0)
       CALL PROSTA(1,0.0)
       CALL BEMBND(IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : neBEM'//
     -           ' setting of boundary conditions failed.'
            CALL PROEND
            RETURN
       ENDIF
*** Solve (0: find matrix, 1: use existing matrix, not yet respected)
       CALL PROFLD(1,'Solving matrix',-1.0)
       CALL PROSTA(1,0.0)
       CALL BEMSOL(IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! BEMINT WARNING : neBEM solving or'//
     -           ' retrieving of influence matrix failed.'
            CALL PROEND
            RETURN
       ENDIF
*** End of progress printing.
       CALL PROEND
*** Seems to have worked.
       BEMSET=.TRUE.
       IFAIL=0
       END
CDECK  ID>, BEMNPR.
       INTEGER FUNCTION BEMNPR()
*-----------------------------------------------------------------------
*   BEMNPR - Returns the number of surface panels.
*   (Last changed on 12/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER NPR,IVOL
*** Initial value.
       NPR=0
*** Count the wire-shaped cylinders
       DO 10 IVOL=1,NSOLID
       IF(ISOLTP(IVOL).NE.1)GOTO 10
       IF(CBUF(ISTART(IVOL)+9).LT.-0.5)NPR=NPR+1
10     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ BEMNPR DEBUG   : Wires: '',
     -      I5,'', panels: '',I5)') NPR,NBEM
*** Add the number of panels.
       NPR = NPR+NBEM
*** Return the value.
       BEMNPR = NPR
       END
CDECK  ID>, BEMPRI.
       SUBROUTINE BEMPRI(IELEM, NVERTEX,
     -      XVERT, YVERT, ZVERT, XNORM, YNORM, ZNORM,
     -      IVOL1, IVOL2, IFAIL)
*-----------------------------------------------------------------------
*   BEMPRI - Returns one surface panel at the time
*   (Last changed on 14/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER IELEM, NVERTEX, IVOL1, IVOL2, IFAIL, NC1,NC2,NC3,I,IWIRE,
     -      IVOL,IREF
       DOUBLE PRECISION XVERT(*), YVERT(*), ZVERT(*),
     -      XNORM, YNORM, ZNORM,R,ZL,X0,Y0,Z0,FNORM,A,B,C
       CHARACTER*15 AUX1,AUX2,AUX3
*** Check in which domain we are.
       IF(IELEM.GT.NBEM)THEN
*** Count the wire-shaped cylinders.
            IWIRE=0
            DO 10 IVOL=1,NSOLID
            IF(ISOLTP(IVOL).NE.1)GOTO 10
            IF(CBUF(ISTART(IVOL)+9).LT.-0.5)IWIRE=IWIRE+1
            IF(IWIRE.EQ.IELEM-NBEM)THEN
                 IREF=ISTART(IVOL)
                 R= CBUF(IREF+1)
                 ZL=ABS(CBUF(IREF+2))
                 X0=CBUF(IREF+3)
                 Y0=CBUF(IREF+4)
                 Z0=CBUF(IREF+5)
                 FNORM=SQRT(CBUF(IREF+6)**2+CBUF(IREF+7)**2+
     -                CBUF(IREF+8)**2)
                 IF(FNORM.LE.0)THEN
                      PRINT *,' !!!!!! BEMPRI WARNING : Cylinder ',IVOL,
     -                     ' has a zero norm direction vector; skipped.'
                      RETURN
                 ENDIF
                 A= CBUF(IREF+6)/FNORM
                 B= CBUF(IREF+7)/FNORM
                 C= CBUF(IREF+8)/FNORM
                 NVERTEX=2
                 XVERT(1)=X0-ZL*A
                 YVERT(1)=Y0-ZL*B
                 ZVERT(1)=Z0-ZL*C
                 XVERT(2)=X0+ZL*A
                 YVERT(2)=Y0+ZL*B
                 ZVERT(2)=Z0+ZL*C
                 XNORM=R
                 YNORM=0
                 ZNORM=0
                 IVOL1=IVOL
                 IVOL2=0
                 IFAIL=0
                 RETURN
            ENDIF
10          CONTINUE
            PRINT *,' !!!!!! BEMPRI WARNING : Did not find the'//
     -           ' cylinder corresponding to element ',IELEM
            RETURN
       ELSEIF(IELEM.LT.1)THEN
            PRINT *,' !!!!!! BEMPRI WARNING : Element reference ',
     -           IELEM,' out of range.'
            RETURN
       ELSEIF(IREFB1(IELEM).EQ.0)THEN
            PRINT *,' !!!!!! BEMPRI WARNING : Element reference ',
     -           IELEM,' points to non-existent panel.'
            RETURN
       ENDIF
*** Retrieve the element.
       CALL BEMBU1('READ',IREFB1(IELEM),NVERTEX,XVERT,YVERT,ZVERT,
     -      XNORM,YNORM,ZNORM,
     -      IVOL2,IVOL1,IFAIL)
*** Debugging output.
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ BEMPRI DEBUG   : '',
     -           ''Primitive '',I5,'' with '',I3,'' vertices''/
     -           26X,''Volume references: '',I5,2X,I5/
     -           26X,9X,''x [cm]'',11X,''y [cm]'',11X,''z [cm]'')')
     -           IELEM,NVERTEX,IVOL1,IVOL2
            DO 20 I=1,NVERTEX
            CALL OUTFMT(REAL(XVERT(I)),2,AUX1,NC1,'RIGHT')
            CALL OUTFMT(REAL(YVERT(I)),2,AUX2,NC2,'RIGHT')
            CALL OUTFMT(REAL(ZVERT(I)),2,AUX3,NC3,'RIGHT')
            WRITE(LUNOUT,'(26X,A15,2X,A15,2X,A15)') AUX1,AUX2,AUX3
20          CONTINUE
            WRITE(LUNOUT,'(26X,8X,''xn [cm]'',10X,''yn [cm]'',
     -           10X,''zn [cm]'')')
            CALL OUTFMT(REAL(XNORM),2,AUX1,NC1,'RIGHT')
            CALL OUTFMT(REAL(YNORM),2,AUX2,NC2,'RIGHT')
            CALL OUTFMT(REAL(ZNORM),2,AUX3,NC3,'RIGHT')
            WRITE(LUNOUT,'(26X,A15,2X,A15,2X,A15)') AUX1,AUX2,AUX3
       ENDIF
*** Dump
       IF(LBDUMP)THEN
            OPEN(UNIT=12,FILE='bempri.dump',ACCESS='APPEND')
            WRITE(12,'(4I5)') IELEM,NVERTEX,IVOL1,IVOL2
            DO 30 I=1,NVERTEX
            WRITE(12,'(3E12.5)') XVERT(I),YVERT(I),ZVERT(I)
30          CONTINUE
            WRITE(12,'(3E12.5)') XNORM,YNORM,ZNORM
            CLOSE(UNIT=12)
       ENDIF
       END
CDECK  ID>, BEMPER.
       INTEGER FUNCTION BEMPER(IVOL,IX,JX,SSX,IY,JY,SSY,IZ,JZ,SSZ)
*-----------------------------------------------------------------------
*   BEMPER - Returns the periodicities. The volume number is not used
*            since Garfield has only infinite periodicities for all.
*   (Last changed on  5/ 3/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       INTEGER IX,IY,IZ,JX,JY,JZ,IVOL
       DOUBLE PRECISION SSX,SSY,SSZ
*** Default number of repeats
       JX=0
       JY=0
       JZ=0
*** x-direction.
       IF(PERX)THEN
            IX=1
       ELSEIF(PERMX)THEN
            IX=2
       ELSEIF(PERAX)THEN
            IX=3
       ELSEIF(PERRX)THEN
            IX=4
       ELSE
            IX=0
       ENDIF
       IF(IX.GT.0)JX=NBEMPX
       SSX=DBLE(SX)
*** y-direction.
       IF(PERY)THEN
            IY=1
       ELSEIF(PERMY)THEN
            IY=2
       ELSEIF(PERAY)THEN
            IY=3
       ELSEIF(PERRY)THEN
            IY=4
       ELSE
            IY=0
       ENDIF
       IF(IY.GT.0)JY=NBEMPY
       SSY=DBLE(SY)
*** z-direction.
       IF(PERZ)THEN
            IZ=1
       ELSEIF(PERMZ)THEN
            IZ=2
       ELSEIF(PERAZ)THEN
            IZ=3
       ELSEIF(PERRZ)THEN
            IZ=4
       ELSE
            IZ=0
       ENDIF
       IF(IZ.GT.0)JZ=NBEMPZ
       SSZ=DBLE(SZ)
*** Return value.
       BEMPER=0
       END
CDECK  ID>, BEMPLA.
       INTEGER FUNCTION BEMPLA(IXMIN, CXMIN, VXMIN, IXMAX, CXMAX, VXMAX,
     -      IYMIN, CYMIN, VYMIN, IYMAX, CYMAX, VYMAX,
     -      IZMIN, CZMIN, VZMIN, IZMAX, CZMAX, VZMAX)
*-----------------------------------------------------------------------
*   BEMPLA - Returns the bounding planes.
*   (Last changed on  3/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       INTEGER IXMIN, IXMAX, IYMIN, IYMAX,IZMIN, IZMAX
       DOUBLE PRECISION CXMIN, VXMIN, CXMAX, VXMAX,
     -      CYMIN, VYMIN, CYMAX, VYMAX, CZMIN, VZMIN, CZMAX, VZMAX
*** Set the values.
       IF(YNPLAN(1))THEN
            CXMIN=COPLAN(1)
            VXMIN=VTPLAN(1)
            IXMIN=1
       ELSE
            IXMIN=0
       ENDIF
       IF(YNPLAN(2))THEN
            CXMAX=COPLAN(2)
            VXMAX=VTPLAN(2)
            IXMAX=1
       ELSE
            IXMAX=0
       ENDIF
       IF(YNPLAN(3))THEN
            CYMIN=COPLAN(3)
            VYMIN=VTPLAN(3)
            IYMIN=1
       ELSE
            IYMIN=0
       ENDIF
       IF(YNPLAN(4))THEN
            CYMAX=COPLAN(4)
            VYMAX=VTPLAN(4)
            IYMAX=1
       ELSE
            IYMAX=0
       ENDIF
*** Return value.
       BEMPLA=0
       END
CDECK  ID>, BEMVIE.
       SUBROUTINE BEMVIE(IFAIL)
*-----------------------------------------------------------------------
*   BEMVIE - 3D viewing using neBEM generated panels.
*   (Last changed on  5/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IFAIL,IFAIL1,IVOL1,IVOL2,ICOL,IREF,NPL,IOFCOL,
     -      NCOUNT,IBEM
       DOUBLE PRECISION XPL(MXEDGE),YPL(MXEDGE),ZPL(MXEDGE),A,B,C,WW
*** Identification.
       IF(LIDENT)PRINT *,' /// ROUTINE BEMVIE ///'
*** Assume this will fail.
       IFAIL=1
*** No point if BEMSET is not true.
       IF(.NOT.BEMSET)THEN
            PRINT *,' !!!!!! BEMVIE WARNING : BEMSET is not set;'//
     -           ' not preparing for viewing.'
            RETURN
       ENDIF
*** Reset the plot buffer.
       CALL PLABU1('RESET',IREF,0,XPL,YPL,ZPL,
     -      0.0D0,0.0D0,0.0D0,0,0,IFAIL1)
*** Reinitialise colour tables.
       ICOL0=30
       ICOLBX=0
       ICOLPL=0
       ICOLST=0
       ICOLW1=0
       ICOLW2=0
       ICOLW3=0
       ICOLD1=0
       ICOLD2=0
       ICOLD3=0
       ICOLRB=0
*** Loop over the panels.
       CALL PROFLD(1,'Counting surfaces',-1.0)
       CALL PROSTA(1,0.0)
       NCOUNT=0
       DO 10 IBEM=1,NBEM
*   Retrieve a panel.
       CALL BEMBU1('READ',IREFB1(IBEM),NPL,XPL,YPL,ZPL,
     -      A,B,C,IVOL2,IVOL1,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            GOTO 10
       ELSE IF(IVOL1.LT.1.OR.IVOL1.GT.NSOLID)THEN
            PRINT *,' !!!!!! BEMVIE WARNING : Volume1 number ',IVOL1,
     -           ' of panel ',IREF,' out of range; panel skipped.'
            GOTO 10
       ENDIF
*   Count
       NCOUNT=NCOUNT+1
*   Create a colour table according to the volume type.
       IF(ISOLMT(IVOL1).EQ.1)THEN
            IF(ICOLW1.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-1','AREA')
                 ICOLW1=ICOL0
                 CALL COLSHD(ICOLW1)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW1
       ELSEIF(ISOLMT(IVOL1).EQ.2)THEN
            IF(ICOLW2.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-2','AREA')
                 ICOLW2=ICOL0
                 CALL COLSHD(ICOLW2)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW2
       ELSEIF(ISOLMT(IVOL1).EQ.3)THEN
            IF(ICOLW3.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-3','AREA')
                 ICOLW3=ICOL0
                 CALL COLSHD(ICOLW3)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW3
       ELSEIF(ISOLMT(IVOL1).EQ.11)THEN
            IF(ICOLD1.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-1','AREA')
                 ICOLD1=ICOL0
                 CALL COLSHD(ICOLD1)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD1
       ELSEIF(ISOLMT(IVOL1).EQ.12)THEN
            IF(ICOLD2.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-2','AREA')
                 ICOLD2=ICOL0
                 CALL COLSHD(ICOLD2)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD2
       ELSEIF(ISOLMT(IVOL1).EQ.13)THEN
            IF(ICOLD3.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-3','AREA')
                 ICOLD3=ICOL0
                 CALL COLSHD(ICOLD3)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD3
       ELSE
            IOFCOL=0
       ENDIF
*   Assign the appropriate weight.
       CALL COLWGT(A,B,C,WW)
*   And find out which colour we should use.
       IF(WW.GT.0)THEN
            ICOL=IOFCOL+NINT(MIN(1.0D0,WW)*(NPRCOL-1))
       ELSE
            ICOL=IOFCOL
       ENDIF  
*   Store with the appropriate colour.
       CALL PLABU1('STORE',IREF,NPL,XPL,YPL,ZPL,
     -      A,B,C,ICOL,IVOL1,IFAIL1)
       IF(IFAIL1.NE.0)PRINT *,' !!!!!! BEMVIE WARNING : Panel ',IREF,
     -      ' volume 1 storage failed; panel skipped.'
**  Check for volume 2.
       IF(IVOL2.EQ.0)THEN
            IVOL2=IVOL1
            ICOL=8
            GOTO 20
       ELSE IF(IVOL2.LT.1.OR.IVOL2.GT.NSOLID)THEN
            PRINT *,' !!!!!! BEMVIE WARNING : Volume2 number ',IVOL2,
     -           ' of panel ',IREF,' out of range; panel skipped.'
            GOTO 10
       ENDIF
*   Count
       NCOUNT=NCOUNT+1
*   Create a colour table according to the volume type.
       IF(ISOLMT(IVOL2).EQ.1)THEN
            IF(ICOLW1.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-1','AREA')
                 ICOLW1=ICOL0
                 CALL COLSHD(ICOLW1)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW1
       ELSEIF(ISOLMT(IVOL2).EQ.2)THEN
            IF(ICOLW2.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-2','AREA')
                 ICOLW2=ICOL0
                 CALL COLSHD(ICOLW2)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW2
       ELSEIF(ISOLMT(IVOL2).EQ.3)THEN
            IF(ICOLW3.EQ.0)THEN
                 CALL GRATTS('CONDUCTORS-3','AREA')
                 ICOLW3=ICOL0
                 CALL COLSHD(ICOLW3)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLW3
       ELSEIF(ISOLMT(IVOL2).EQ.11)THEN
            IF(ICOLD1.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-1','AREA')
                 ICOLD1=ICOL0
                 CALL COLSHD(ICOLD1)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD1
       ELSEIF(ISOLMT(IVOL2).EQ.12)THEN
            IF(ICOLD2.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-2','AREA')
                 ICOLD2=ICOL0
                 CALL COLSHD(ICOLD2)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD2
       ELSEIF(ISOLMT(IVOL2).EQ.13)THEN
            IF(ICOLD3.EQ.0)THEN
                 CALL GRATTS('DIELECTRIC-3','AREA')
                 ICOLD3=ICOL0
                 CALL COLSHD(ICOLD3)
                 ICOL0=ICOL0+NPRCOL
            ENDIF
            IOFCOL=ICOLD3
       ELSE
            IOFCOL=0
       ENDIF
*   Assign the appropriate weight.
       CALL COLWGT(-A,-B,-C,WW)
*   And find out which colour we should use.
       IF(WW.GT.0)THEN
            ICOL=IOFCOL+NINT(MIN(1.0D0,WW)*(NPRCOL-1))
       ELSE
            ICOL=IOFCOL
       ENDIF  
*   Store with the appropriate colour.
20     CONTINUE
       CALL PLABU1('STORE',IREF,NPL,XPL,YPL,ZPL,
     -      -A,-B,-C,ICOL,IVOL2,IFAIL1)
       IF(IFAIL1.NE.0)PRINT *,' !!!!!! BEMVIE WARNING : Panel ',IREF,
     -      ' volume 2 storage failed; panel skipped.'
*   Next panel.
10     CONTINUE
*** And sort them for plotting.
       CALL PLASRP
       END
CDECK  ID>, BEMVOL.
       SUBROUTINE BEMVOL(ISOL,ISHAPE,IMAT,EPS,VOLT,CHARGE,IBOUND,IFAIL)
*-----------------------------------------------------------------------
*   BEMVOL - Returns information about a solid.
*   (Last changed on 11/10/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER ISOL,ISHAPE,IMAT,IBOUND,IFAIL
       DOUBLE PRECISION EPS,VOLT,CHARGE
*** Solid 0 is the gas.
       IF(ISOL.EQ.0)THEN
            ISHAPE=0
            IMAT=11
            VOLT=0
            CHARGE=0
            EPS=1.0
            IBOUND=0
            IFAIL=0
            RETURN
*** Check solid reference
       ELSEIF(ISOL.LT.1.OR.ISOL.GT.NSOLID)THEN
            PRINT *,' !!!!!! BEMVOL WARNING : Solid reference ',ISOL,
     -           ' out of range; no data returned.'
            IFAIL=1
            RETURN
       ENDIF
*** Return the data: cylinder.
       IF(ISOLTP(ISOL).EQ.1)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+15)
            EPS=CBUF(ISTART(ISOL)+16)
            IBOUND=NINT(CBUF(ISTART(ISOL)+17))
            CHARGE=CBUF(ISTART(ISOL)+18)
*   Hole.
       ELSEIF(ISOLTP(ISOL).EQ.2)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+17)
            EPS=CBUF(ISTART(ISOL)+18)
            IBOUND=NINT(CBUF(ISTART(ISOL)+19))
            CHARGE=CBUF(ISTART(ISOL)+20)
*   Box.
       ELSEIF(ISOLTP(ISOL).EQ.3)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+14)
            EPS=CBUF(ISTART(ISOL)+15)
            IBOUND=NINT(CBUF(ISTART(ISOL)+16))
            CHARGE=CBUF(ISTART(ISOL)+17)
*   Sphere.
       ELSEIF(ISOLTP(ISOL).EQ.4)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+6)
            EPS=CBUF(ISTART(ISOL)+7)
            IBOUND=NINT(CBUF(ISTART(ISOL)+8))
            CHARGE=CBUF(ISTART(ISOL)+9)
*   Toblerone.
       ELSEIF(ISOLTP(ISOL).EQ.5)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+15)
            EPS=CBUF(ISTART(ISOL)+16)
            IBOUND=NINT(CBUF(ISTART(ISOL)+17))
            CHARGE=CBUF(ISTART(ISOL)+18)
*   Extrusion.
       ELSEIF(ISOLTP(ISOL).EQ.6)THEN
            ISHAPE=ISOLTP(ISOL)
            IMAT=ISOLMT(ISOL)
            VOLT=CBUF(ISTART(ISOL)+15)
            EPS=CBUF(ISTART(ISOL)+16)
            IBOUND=NINT(CBUF(ISTART(ISOL)+17))
            CHARGE=CBUF(ISTART(ISOL)+18)
*   Anything else.
       ELSE
            PRINT *,' !!!!!! BEMVOL WARNING : Unknown solid shape.'
            IFAIL=1
            RETURN
       ENDIF
*** Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, BEMVPR.
       SUBROUTINE BEMVPR(IVOL, NPRIM, PRLIST)
*-----------------------------------------------------------------------
*   BEMVPR - Lists primitives belonging to a volume.
*   (Last changed on 13/ 1/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER IVOL, NPRIM, PRLIST(*)
       INTEGER I, NVERTEX, IVOL1, IVOL2, IFAIL, JVOL, IWIRE
       DOUBLE PRECISION XVERT(MXEDGE), YVERT(MXEDGE), ZVERT(MXEDGE),
     -      XNORM, YNORM, ZNORM
*** Initialise count
       NPRIM=0
*** Loop over the panels
       DO 10 I=1,NBEM
*   Retrieve
       CALL BEMBU1('READ',IREFB1(I),NVERTEX,XVERT,YVERT,ZVERT,
     -      XNORM,YNORM,ZNORM,
     -      IVOL2,IVOL1,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! BEMVPR WARNING : Did not find primitive ',
     -           I,'; list may be incomplete.'
            GOTO 10
*   If either of the volume numbers matches ...
       ELSEIF(IVOL.EQ.IVOL1.OR.IVOL.EQ.IVOL2)THEN
            NPRIM=NPRIM+1
            PRLIST(NPRIM)=I
       ENDIF
10     CONTINUE
*** Skip the rest if the volume is not wire.
       IF(ISOLTP(IVOL).NE.1)RETURN
       IF(CBUF(ISTART(IVOL)+9).GT.-0.5)RETURN
*   Count wires up to this volume.
       IWIRE=0
       DO 20 JVOL=1,IVOL
       IF(ISOLTP(JVOL).NE.1)GOTO 20
       IF(CBUF(ISTART(JVOL)+9).LT.-0.5)IWIRE=IWIRE+1
 20    CONTINUE
*   Add the primitive to the list.
       NPRIM=NPRIM+1
       PRLIST(NPRIM)=NBEM+IWIRE
       END
CDECK  ID>, BEMSBC.
       SUBROUTINE BEMSBC(IPRIM1, NPRIM, PRLIST)
*-----------------------------------------------------------------------
*   BEMSBC - Lists primitives with the same boundary condition. For the
*            time being, boundary conditions and volumes are linked.
*   (Last changed on  5/ 4/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBEM,IREFB1(MXPLAN),NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,
     -      BEMNEW,BEMINV,BEMSLV
       DOUBLE PRECISION BEMQTH,BEMSTH,BEMSSC,BEMTGT,BEMEPA,BEMEPD
       LOGICAL LBDUMP
       COMMON /BEMDAT/ BEMQTH,BEMSSC,BEMSTH,BEMTGT,BEMEPA,BEMEPD,
     -      IREFB1,NBEM,NBEMMN,NBEMMX,NBEMPX,NBEMPY,NBEMPZ,BEMNEW,
     -      BEMINV,BEMSLV,LBDUMP
       INTEGER IPRIM1, NPRIM, PRLIST(*)
       INTEGER I, NVERTEX, IVOL1, IVOL2, IVOLR1, IVOLR2, IFAIL
       DOUBLE PRECISION XVERT(MXEDGE), YVERT(MXEDGE), ZVERT(MXEDGE),
     -      XNORM, YNORM, ZNORM
*** Initialise count
       NPRIM=0
*** Check the reference primitive number
       IF(IPRIM1.LT.1.OR.IPRIM1.GT.NBEM)THEN
            PRINT *,' !!!!!! BEMSBC WARNING : Reference primitive'//
     -           ' is out of range; no list returned.'
            RETURN
       ENDIF
*** Find the volumes for the primitive.
       CALL BEMBU1('READ',IREFB1(IPRIM1),NVERTEX,XVERT,YVERT,ZVERT,
     -      XNORM,YNORM,ZNORM,
     -      IVOLR2,IVOLR1,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! BEMSBC WARNING : Unable to retrieve the',
     -           ' reference primitive; no list returned.'
            RETURN
       ENDIF
*** Loop over the panels
       DO 10 I=1,NBEM
*   Retrieve
       CALL BEMBU1('READ',IREFB1(I),NVERTEX,XVERT,YVERT,ZVERT,
     -      XNORM,YNORM,ZNORM,
     -      IVOL2,IVOL1,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! BEMSBC WARNING : Did not find primitive ',
     -           I,'; list may be incomplete.'
            GOTO 10
*   If either of the volume numbers matches ...
       ELSEIF((IVOLR1.GT.0.AND.IVOLR1.EQ.IVOL1).OR.
     -        (IVOLR2.GT.0.AND.IVOLR2.EQ.IVOL2).OR.
     -        (IVOLR1.GT.0.AND.IVOLR1.EQ.IVOL2).OR.
     -        (IVOLR2.GT.0.AND.IVOLR2.EQ.IVOL1))THEN
            NPRIM=NPRIM+1
            PRLIST(NPRIM)=I
       ENDIF
10     CONTINUE
       END
CDECK  ID>, GASMRG.
       SUBROUTINE GASMRG(IFAIL)
*-----------------------------------------------------------------------
*   GASMRG - Merges gas data from a file with existing gas tables.
*   VARIABLES : NWORD       : Number of parameters provided.
*               STRING      : String for character manipulation.
*   (Last changed on 16/ 2/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL MAGOK
       REAL ALFA,B0X,B0Y,B0Z,SUSWIR,SUSGAS,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX
       INTEGER MAGSRC,
     -      IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z
       CHARACTER*(MXCHAR) FUNB0X,FUNB0Y,FUNB0Z
       COMMON /MAGDAT/ ALFA,SUSWIR,SUSGAS,
     -      B0X,B0Y,B0Z,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX,
     -      MAGSRC,IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z,
     -      MAGOK
       COMMON /MAGCHR/ FUNB0X,FUNB0Y,FUNB0Z
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       CHARACTER*(MXCHAR) STRING
       CHARACTER*8 MEMBER
       CHARACTER*(MXNAME) FILE
       CHARACTER*45 DESC
       INTEGER IFAIL,NCFILE,NCMEMB,I,J,K,L,M,N,IOS,IFAIL1,NWORD,INPCMP,
     -      NGASN,NBANGN,NBTABN,INDEXE,INDEXA,INDEXB,
     -      IEMODE,IAMODE,IBMODE,
     -      IVEXTN,IXEXTN,IYEXTN,IDEXTN,IAEXTN,IBEXTN,IMEXTN,IWEXTN,
     -      IOEXTN,IHEXTN,ISEXTN,IEEXTN,IZEXTN,
     -      JVEXTN,JXEXTN,JYEXTN,JDEXTN,JAEXTN,JBEXTN,JMEXTN,JWEXTN,
     -      JOEXTN,JHEXTN,JSEXTN,JEEXTN,JZEXTN,
     -      IATHRN,IBTHRN,IHTHRN,
     -      IVMETN,IXMETN,IYMETN,IDMETN,IAMETN,IBMETN,IMMETN,IWMETN,
     -      IHMETN,IOMETN,ISMETN,IEMETN,IZMETN,
     -      NCLSN,NEXGSN,NIOGSN,IEXC,IION,LOOKEX(MXEXG),LOOKIO(MXIOG),
     -      NQMOL
       LOGICAL DSNCMP,EXIS,GASOKN(20),TAB2DN,REPOLD,HEEDN,SRIMN,
     -      NEWE(MXLIST),NEWB(MXBTAB),NEWA(MXBANG)
       EXTERNAL DSNCMP,INPCMP
       REAL EGASN(MXLIST),BTABN(MXBTAB),BANGN(MXBANG),
     -      VGASN,CVGASN,XGASN,CXGASN,YGASN,CYGASN,
     -      DGASN,CDGASN,OGASN,COGASN,
     -      AGASN,CAGASN,AORIN,BGASN,CBGASN,MGASN,CMGASN,
     -      WGASN,CWGASN,HGASN,CHGASN,SGASN(6),CSGASN(6),
     -      EXGASN(MXEXG),IOGASN(MXIOG),CEXGSN(MXEXG),CIOGSN(MXIOG),
     -      EPSE,EPSA,EPSB,
     -      AN,ZN,EMPRBN,EPAIRN,DLIONN,DTIONN,CMEANN,RHON,
     -      PGASN,TGASN,GASFRN(MXNBMC)
       CHARACTER*10 CLSTPN
       PARAMETER(EPSE=1E-3,EPSA=1E-3,EPSB=1E-3)
*** Identify the routine.
       IF(LIDENT)PRINT *,' /// ROUTINE GASMRG ///'
*** Initialise IFAIL on 1 (i.e. fail).
       IFAIL=1
       FILE=' '
       MEMBER='*'
       NCFILE=8
       NCMEMB=1
*** First decode the argument string, setting file name + member name.
       CALL INPNUM(NWORD)
*   If there's only one argument, it's the dataset name.
       IF(NWORD.GE.2)THEN
            CALL INPSTR(2,2,STRING,NCFILE)
            FILE=STRING
       ENDIF
*   If there's a second argument, it is the member name.
       IF(NWORD.GE.3)THEN
            CALL INPSTR(3,3,STRING,NCMEMB)
            MEMBER=STRING
       ENDIF
*   Other options ?
       REPOLD=.FALSE.
       DO 10 I=4,NWORD
       IF(INPCMP(I,'KEEP-#OLD').NE.0)THEN
            REPOLD=.FALSE.
       ELSEIF(INPCMP(I,'REP#LACE-#OLD').NE.0)THEN
            REPOLD=.TRUE.
       ELSE
            CALL INPMSG(I,'Not a known option')
       ENDIF
10     CONTINUE
*   Print error messages.
       CALL INPERR
*** Check file ane member name lengths.
       IF(NCFILE.GT.MXNAME)THEN
            PRINT *,' !!!!!! GASMRG WARNING : The file name is'//
     -           ' truncated to MXNAME (=',MXNAME,') characters.'
            NCFILE=MIN(NCFILE,MXNAME)
       ENDIF
       IF(NCMEMB.GT.8)THEN
            PRINT *,' !!!!!! GASMRG WARNING : The member name is'//
     -           ' shortened to ',MEMBER,', first 8 characters.'
            NCMEMB=MIN(NCMEMB,8)
       ELSEIF(NCMEMB.LE.0)THEN
            PRINT *,' !!!!!! GASMRG WARNING : The member'//
     -           ' name has zero length, replaced by "*".'
            MEMBER='*'
            NCMEMB=1
       ENDIF
*   Reject the empty file name case.
       IF(FILE.EQ.' '.OR.NWORD.EQ.1)THEN
            PRINT *,' !!!!!! GASMRG WARNING : MERGE must be at least'//
     -           ' followed by a dataset name ; no data are read.'
            RETURN
       ENDIF
*** Open a dataset and inform DSNLOG.
       CALL DSNOPN(FILE,NCFILE,12,'READ-LIBRARY',IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! GASMRG WARNING : Opening ',FILE(1:NCFILE),
     -           ' failed ; gas data are not read.'
            RETURN
       ENDIF
       CALL DSNLOG(FILE,'Gas data  ','Sequential','Read data ')
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : Dataset '',
     -      A,'' opened on unit 12 for data reading.'')') FILE(1:NCFILE)
*   Locate the pointer on the header of the requested member.
       CALL DSNLOC(MEMBER,NCMEMB,'GAS     ',12,EXIS,'RESPECT')
       IF(.NOT.EXIS)THEN
            CALL DSNLOC(MEMBER,NCMEMB,'GAS     ',12,EXIS,'IGNORE')
            IF(EXIS)THEN
                 PRINT *,' ###### GASMRG ERROR   : Gas description '//
     -                MEMBER(1:NCMEMB)//' has been deleted from '//
     -                FILE(1:NCFILE)//'; not read.'
            ELSE
                 PRINT *,' ###### GASMRG ERROR   : Gas description '//
     -                MEMBER(1:NCMEMB)//' not found in '//FILE(1:NCFILE)
            ENDIF
            CLOSE(UNIT=12,IOSTAT=IOS,ERR=2030)
            RETURN
       ENDIF
*   Check that this member contains indeed gas data.
       READ(12,'(A80)',END=2000,IOSTAT=IOS,ERR=2010) STRING
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : Dataset'',
     -      '' header record follows:''/2X,A)') STRING(1:80)
       WRITE(*,'(''  Member '',A8,'' was created on '',A8,
     -      '' at '',A8/''  Remarks: '',A29)')
     -      STRING(32:39),STRING(11:18),STRING(23:30),STRING(51:79)
*   Check the version.
       READ(12,'(A15)',END=2000,IOSTAT=IOS,ERR=2010) STRING
       IF(STRING(1:15).NE.' Version   : 12')THEN
            PRINT *,' !!!!!! GASMRG WARNING : This member'//
     -           ' can not be read because of a change in format.'
            CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
            RETURN
       ENDIF
*** Read the GASOK bits.
       READ(12,'(13X,20L1)',END=2000,IOSTAT=IOS,ERR=2010)
     -      (GASOKN(I),I=1,20)
*** Take the new identifier if there was no identifier yet.
       IF(GASID.EQ.' '.OR.REPOLD)THEN
            READ(12,'(13X,A)',END=2000,IOSTAT=IOS,ERR=2010) GASID
       ELSE
            READ(12,'(13X)',END=2000,IOSTAT=IOS,ERR=2010)
       ENDIF
*** Never take the table function, and reset the old function.
       READ(12,'(13X)',END=2000,IOSTAT=IOS,ERR=2010)
       FCNTAB=' '
       NFTAB=1
*** Dimensions of the table to be merged.
       READ(12,'(13X,L1,5I10)',END=2000,IOSTAT=IOS,ERR=2010)
     -      TAB2DN,NGASN,NBANGN,NBTABN,NEXGSN,NIOGSN
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : Dataset'',
     -      '' to be merged has the following dimensions:''/
     -      26X,''2D = '',L1,'', n_E = '',I5,'', n_angle = '',I5,
     -      '', n_B = '',I5,'', n_exc = '',I5,'', n_ion = '',I5)')
     -      TAB2DN,NGASN,NBANGN,NBTABN,NEXGSN,NIOGSN
*   Read the E field.
       READ(12,'(/(5E15.8))',IOSTAT=IOS,ERR=2010,END=2000)
     -      (EGASN(I),I=1,NGASN)
*   Determine which mode we have to use for the E field.
       IEMODE=1
       DO 60 I=1,MIN(NGAS,NGASN)
       IF(ABS(EGAS(I)-EGASN(I)).GT.EPSE*(ABS(EGAS(I))+ABS(EGASN(I))))
     -      IEMODE=0
60     CONTINUE
       IF(NGAS.NE.NGASN)IEMODE=0
*   Read the angles.
       READ(12,'(/(5E15.8))',IOSTAT=IOS,ERR=2010,END=2000)
     -      (BANGN(I),I=1,NBANGN)
*   Determine which mode we have to use for the angles.
       IAMODE=1
       DO 140 I=1,MIN(NBANG,NBANGN)
       IF(ABS(BANG(I)-BANGN(I)).GT.EPSA*(ABS(BANG(I))+ABS(BANGN(I))))
     -      IAMODE=0
140    CONTINUE
       IF(NBANG.NE.NBANGN)IAMODE=0
*   Read the B field values.
       READ(12,'(/(5E15.8))',IOSTAT=IOS,ERR=2010,END=2000)
     -      (BTABN(I),I=1,NBTABN)
*   Determine which mode we have to use for the B field.
       IBMODE=1
       DO 150 I=1,MIN(NBTAB,NBTABN)
       IF(ABS(BTAB(I)-BTABN(I)).GT.EPSB*(ABS(BTAB(I))+ABS(BTABN(I))))
     -      IBMODE=0
150    CONTINUE
       IF(NBTAB.NE.NBTABN)IBMODE=0
*   Debugging.
       IF(LDEBUG.AND.IEMODE.EQ.0)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : E vectors'',
     -           '' differ.'')')
       ELSEIF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : E vectors'',
     -           '' identical.'')')
       ENDIF
       IF(LDEBUG.AND.IAMODE.EQ.0)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : The angle'',
     -           '' vectors differ.'')')
       ELSEIF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : The angle'',
     -           '' vectors are identical.'')')
       ENDIF
       IF(LDEBUG.AND.IBMODE.EQ.0)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : The B field'',
     -           '' vectors differ.'')')
       ELSEIF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   : The B field'',
     -           '' vectors are identical.'')')
       ENDIF
*   Ensure there is a common mode.
       IF(IEMODE+IAMODE+IBMODE.LT.2)THEN
            PRINT *,' !!!!!! GASMRG WARNING : Existing data and data'//
     -           ' in the file don''t have 2 common axis; not merged.'
            CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
            IFAIL=1
            RETURN
       ENDIF
*** Decide whether we have to produce a 3D table or a 1D table.
       IF((TAB2DN.OR.IBMODE*IAMODE.EQ.0).AND..NOT.TAB2D)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Expanding existing table to 3D mode.'')')
            DO 110 I=1,NGAS
            DO 120 J=1,NBANG
            DO 130 K=1,NBTAB
            VGAS2(I,J,K)=VGAS(I)
            XGAS2(I,J,K)=XGAS(I)
            YGAS2(I,J,K)=YGAS(I)
            DGAS2(I,J,K)=DGAS(I)
            OGAS2(I,J,K)=OGAS(I)
            AGAS2(I,J,K)=AGAS(I)
            AORIG2(I,J,K)=AORIG(I)
            BGAS2(I,J,K)=BGAS(I)
            MGAS2(I,J,K)=MGAS(I)
            WGAS2(I,J,K)=WGAS(I)
            DO 160 L=1,6
            SGAS2(I,J,K,L)=SGAS(I,L)
160         CONTINUE
            HGAS2(I,J,K)=HGAS(I)
            DO 170 L=1,NEXGAS
            EXGAS2(I,J,K,L)=EXGAS(I,L)
170         CONTINUE
            DO 171 L=1,NIOGAS
            IOGAS2(I,J,K,L)=IOGAS(I,L)
171         CONTINUE
130         CONTINUE
120         CONTINUE
110         CONTINUE
            TAB2D=.TRUE.
       ENDIF
*** If the E values differ, warn for lost GASOK bits.
       IF(IEMODE*IBMODE*IAMODE.EQ.0)THEN
            DO 70 I=1,16
            IF(I.EQ.13.OR.I.EQ.14)GOTO 70
*   Check for data currently present which is absent in the new data.
            IF(GASOK(I).AND..NOT.GASOKN(I))THEN
                 IF(I.EQ.1)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' drift velocity is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.2)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ion mobility is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.3)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' longitudinal diffusion is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.4)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' Townsend coefficient is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.6)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' attachment coefficient is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.7)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' Lorentz angle is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.8)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' transverse diffusion is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.9)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' velocity || Bt is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.10)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' velocity || ExB is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.11)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' diffusion tensor is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.12)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ion dissociation data is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.15)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' excitation data is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ELSEIF(I.EQ.16)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ionisation data is absent in'//
     -                     ' the dataset to be added; data reset.'
                 ENDIF
                 GASOK(I)=.FALSE.
*   And for data present in the file but not currently present.
            ELSEIF(GASOKN(I).AND..NOT.GASOK(I))THEN
                 IF(I.EQ.1)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' drift velocity is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.2)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ion mobility is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.3)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' longitudinal diffusion is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.4)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' Townsend coefficient is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.6)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' attachment coefficient is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.7)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' Lorentz angle is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.8)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' transverse diffusion is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.9)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' velocity || Bt is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.10)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' velocity || ExB is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.11)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' diffusion tensor is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.12)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ion dissociation data is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.15)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' excitation data is absent in'//
     -                     ' the existing data; new data not used.'
                 ELSEIF(I.EQ.16)THEN
                      PRINT *,' !!!!!! GASMRG WARNING : The'//
     -                     ' ionisation data is absent in'//
     -                     ' the existing data; new data not used.'
                 ENDIF
                 GASOKN(I)=.FALSE.
            ENDIF
70          CONTINUE
       ENDIF
*** Initialise the "new" flags.
       DO 80 I=1,NGAS
       NEWE(I)=.FALSE.
80     CONTINUE
       DO 90 I=1,NBANG
       NEWA(I)=.FALSE.
90     CONTINUE
       DO 100 I=1,NBTAB
       NEWB(I)=.FALSE.
100    CONTINUE
*** Extend an existing 2D table.
       IF(TAB2D)THEN
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Extending the table in 3D mode.'')')
**  Insert room in the tables for new columns in E.
            IF(IEMODE.EQ.0)THEN
                 DO 200 I=1,NGASN
                 DO 210 J=1,NGAS
*   If it overlaps with existing E, either keep old or new data.
                 IF(ABS(EGASN(I)-EGAS(J)).LE.EPSE*(ABS(EGASN(I))+
     -                ABS(EGAS(J))))THEN
                      IF(REPOLD)THEN
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Replacing existing data for E = ',
     -                          EGAS(J)*PGAS,' V/cm by data from file.'
                           INDEXE=J
                           GOTO 250
                      ELSE
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Keeping existing data for E = ',
     -                          EGAS(J)*PGAS,' V/cm, not using data',
     -                          ' from the file.'
                           GOTO 200
                      ENDIF
*   Otherwise shift all data at higher E values.
                 ELSEIF(EGASN(I).LT.EGAS(J))THEN
                      IF(NGAS+1.LE.MXLIST)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                          '' DEBUG   : Inserting E = '',E15.8,
     -                          '' V/cm at slot '',I5)') EGASN(I)*PGAS,J
                           DO 220 K=1,NBANG
                           DO 230 L=1,NBTAB
                           DO 240 M=NGAS,J,-1
                           VGAS2(M+1,K,L)=VGAS2(M,K,L)
                           XGAS2(M+1,K,L)=XGAS2(M,K,L)
                           YGAS2(M+1,K,L)=YGAS2(M,K,L)
                           DGAS2(M+1,K,L)=DGAS2(M,K,L)
                           OGAS2(M+1,K,L)=OGAS2(M,K,L)
                           AGAS2(M+1,K,L)=AGAS2(M,K,L)
                           AORIG2(M+1,K,L)=AORIG2(M,K,L)
                           BGAS2(M+1,K,L)=BGAS2(M,K,L)
                           MGAS2(M+1,K,L)=MGAS2(M,K,L)
                           WGAS2(M+1,K,L)=WGAS2(M,K,L)
                           DO 290 N=1,6
                           SGAS2(M+1,K,L,N)=SGAS2(M,K,L,N)
290                        CONTINUE
                           HGAS2(M+1,K,L)=HGAS2(M,K,L)
                           DO 291 N=1,NEXGAS
                           EXGAS2(M+1,K,L,N)=EXGAS2(M,K,L,N)
291                        CONTINUE
                           DO 292 N=1,NIOGAS
                           IOGAS2(M+1,K,L,N)=IOGAS2(M,K,L,N)
292                        CONTINUE
                           NEWE(M+1)=NEWE(M)
240                        CONTINUE
230                        CONTINUE
220                        CONTINUE
                           DO 280 M=NGAS,J,-1
                           EGAS(M+1)=EGAS(M)
280                        CONTINUE
                           NGAS=NGAS+1
                           INDEXE=J
                           GOTO 250
                      ELSE
                           GOTO 3010
                      ENDIF
                 ENDIF
*   Next old value.
210              CONTINUE
*   If there is no higher E, then add the line at the end.
                 IF(NGAS+1.GT.MXLIST)GOTO 3010
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                '' DEBUG   : Adding E = '',E15.8,
     -                '' V/cm at the end '',I5)') EGASN(I)*PGAS
                 NGAS=NGAS+1
                 INDEXE=NGAS
*   Zero the new row.
250              CONTINUE
                 EGAS(INDEXE)=EGASN(I)
                 NEWE(INDEXE)=.TRUE.
                 DO 260 K=1,NBANG
                 DO 270 L=1,NBTAB
                 VGAS2(INDEXE,K,L)=0
                 XGAS2(INDEXE,K,L)=0
                 YGAS2(INDEXE,K,L)=0
                 DGAS2(INDEXE,K,L)=0
                 OGAS2(INDEXE,K,L)=0
                 AGAS2(INDEXE,K,L)=0
                 AORIG2(INDEXE,K,L)=0
                 BGAS2(INDEXE,K,L)=0
                 MGAS2(INDEXE,K,L)=0
                 WGAS2(INDEXE,K,L)=0
                 DO 295 N=1,6
                 SGAS2(INDEXE,K,L,N)=0
295              CONTINUE
                 HGAS2(INDEXE,K,L)=0
                 DO 296 N=1,NEXGAS
                 EXGAS2(INDEXE,K,L,N)=0
296              CONTINUE
                 DO 297 N=1,NIOGAS
                 IOGAS2(INDEXE,K,L,N)=0
297              CONTINUE
270              CONTINUE
260              CONTINUE
*   Next new value.
200              CONTINUE
            ENDIF
**  Insert room in the tables for new columns in B.
            IF(IBMODE.EQ.0)THEN
                 DO 300 I=1,NBTABN
                 DO 310 J=1,NBTAB
*   If it overlaps with existing B, either keep old or new data.
                 IF(ABS(BTABN(I)-BTAB(J)).LE.EPSB*(ABS(BTABN(I))+
     -                ABS(BTAB(J))))THEN
                      IF(REPOLD)THEN
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Replacing old data for B = ',BTAB(J)/
     -                          100,' T by data from file.'
                           INDEXB=J
                           GOTO 350
                      ELSE
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Keeping old data for B = ',BTAB(J)/
     -                          100,' T, not using data from file.'
                           GOTO 300
                      ENDIF
*   Otherwise shift all data at higher B values.
                 ELSEIF(BTABN(I).LT.BTAB(J))THEN
                      IF(NBTAB+1.LE.MXBTAB)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                          '' DEBUG   : Inserting B = '',E15.8,
     -                          '' T at slot '',I5)') BTABN(I)/100,J
                           DO 320 K=1,NGAS
                           DO 330 L=1,NBANG
                           DO 340 M=NBTAB,J,-1
                           VGAS2(K,L,M+1)=VGAS2(K,L,M)
                           XGAS2(K,L,M+1)=XGAS2(K,L,M)
                           YGAS2(K,L,M+1)=YGAS2(K,L,M)
                           DGAS2(K,L,M+1)=DGAS2(K,L,M)
                           OGAS2(K,L,M+1)=OGAS2(K,L,M)
                           AGAS2(K,L,M+1)=AGAS2(K,L,M)
                           AORIG2(K,L,M+1)=AORIG2(K,L,M)
                           BGAS2(K,L,M+1)=BGAS2(K,L,M)
                           MGAS2(K,L,M+1)=MGAS2(K,L,M)
                           WGAS2(K,L,M+1)=WGAS2(K,L,M)
                           DO 345 N=1,6
                           SGAS2(K,L,M+1,N)=SGAS2(K,L,M,N)
345                        CONTINUE
                           HGAS2(K,L,M+1)=HGAS2(K,L,M)
                           DO 346 N=1,NEXGAS
                           EXGAS2(K,L,M+1,N)=EXGAS2(K,L,M,N)
346                        CONTINUE
                           DO 347 N=1,NIOGAS
                           IOGAS2(K,L,M+1,N)=IOGAS2(K,L,M,N)
347                        CONTINUE
                           NEWB(M+1)=NEWB(M)
340                        CONTINUE
330                        CONTINUE
320                        CONTINUE
                           DO 380 M=NBTAB,J,-1
                           BTAB(M+1)=BTAB(M)
380                        CONTINUE
                           NBTAB=NBTAB+1
                           INDEXB=J
                           GOTO 350
                      ELSE
                           GOTO 3020
                      ENDIF
                 ENDIF
*   Next old value.
310              CONTINUE
*   If there is no higher B, then add the line at the end.
                 IF(NBTAB+1.GT.MXBTAB)GOTO 3020
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                '' DEBUG   : Adding B = '',E15.8,
     -                '' T at the end '',I5)') BTABN(I)/100
                 NBTAB=NBTAB+1
                 INDEXB=NBTAB
*   Zero the new row.
350              CONTINUE
                 BTAB(INDEXB)=BTABN(I)
                 NEWB(INDEXB)=.TRUE.
                 DO 360 K=1,NGAS
                 DO 370 L=1,NBANG
                 VGAS2(K,L,INDEXB)=0
                 XGAS2(K,L,INDEXB)=0
                 YGAS2(K,L,INDEXB)=0
                 DGAS2(K,L,INDEXB)=0
                 OGAS2(K,L,INDEXB)=0
                 AGAS2(K,L,INDEXB)=0
                 AORIG2(K,L,INDEXB)=0
                 BGAS2(K,L,INDEXB)=0
                 MGAS2(K,L,INDEXB)=0
                 WGAS2(K,L,INDEXB)=0
                 DO 375 N=1,6
                 SGAS2(K,L,INDEXB,N)=0
375              CONTINUE
                 HGAS2(K,L,INDEXB)=0
                 DO 376 N=1,NEXGAS
                 EXGAS2(K,L,INDEXB,N)=0
376              CONTINUE
                 DO 377 N=1,NIOGAS
                 IOGAS2(K,L,INDEXB,N)=0
377              CONTINUE
370              CONTINUE
360              CONTINUE
*   Next new value.
300              CONTINUE
            ENDIF
**  Insert room in the tables for new columns in angle.
            IF(IAMODE.EQ.0)THEN
                 DO 400 I=1,NBANGN
                 DO 410 J=1,NBANG
*   If it overlaps with an existing angle, either keep old or new data.
                 IF(ABS(BANGN(I)-BANG(J)).LE.EPSA*(ABS(BANGN(I))+
     -                ABS(BANG(J))))THEN
                      IF(REPOLD)THEN
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Replacing old data for angle(E,B) = ',
     -                          BANG(J)*180/PI,' degrees by data from'//
     -                          ' the file.'
                           INDEXA=J
                           GOTO 450
                      ELSE
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Keeping old data for angle(E,B) = ',
     -                          BANG(J)*180/PI,' degrees, not using'//
     -                          ' data from file.'
                           GOTO 400
                      ENDIF
*   Otherwise shift all data at higher angles.
                 ELSEIF(BANGN(I).LT.BANG(J))THEN
                      IF(NBANG+1.LE.MXBANG)THEN
                           IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                          '' DEBUG   : Inserting angle = '',E15.8,
     -                          '' degrees at slot '',I5)')
     -                          BANGN(I)*180/PI,J
                           DO 420 K=1,NGAS
                           DO 430 L=1,NBTAB
                           DO 440 M=NBANG,J,-1
                           VGAS2(K,M+1,L)=VGAS2(K,M,L)
                           XGAS2(K,M+1,L)=XGAS2(K,M,L)
                           YGAS2(K,M+1,L)=YGAS2(K,M,L)
                           DGAS2(K,M+1,L)=DGAS2(K,M,L)
                           OGAS2(K,M+1,L)=OGAS2(K,M,L)
                           AGAS2(K,M+1,L)=AGAS2(K,M,L)
                           AORIG2(K,M+1,L)=AORIG2(K,M,L)
                           BGAS2(K,M+1,L)=BGAS2(K,M,L)
                           MGAS2(K,M+1,L)=MGAS2(K,M,L)
                           WGAS2(K,M+1,L)=WGAS2(K,M,L)
                           DO 445 N=1,6
                           SGAS2(K,M+1,L,N)=SGAS2(K,M,L,N)
445                        CONTINUE
                           HGAS2(K,M+1,L)=HGAS2(K,M,L)
                           DO 446 N=1,NEXGAS
                           EXGAS2(K,M+1,L,N)=EXGAS2(K,M,L,N)
446                        CONTINUE
                           DO 447 N=1,NIOGAS
                           IOGAS2(K,M+1,L,N)=IOGAS2(K,M,L,N)
447                        CONTINUE
                           NEWA(M+1)=NEWA(M)
440                        CONTINUE
430                        CONTINUE
420                        CONTINUE
                           DO 480 M=NBANG,J,-1
                           BANG(M+1)=BANG(M)
480                        CONTINUE
                           NBANG=NBANG+1
                           INDEXA=J
                           GOTO 450
                      ELSE
                           GOTO 3030
                      ENDIF
                 ENDIF
*   Next old value.
410              CONTINUE
*   If there is no higher angle, then add the line at the end.
                 IF(NBANG+1.GT.MXBANG)GOTO 3030
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                '' DEBUG   : Adding angle = '',E15.8,
     -                '' degrees at the end '',I5)') BANGN(I)*180/PI
                 NBANG=NBANG+1
                 INDEXA=NBANG
*   Zero the new row.
450              CONTINUE
                 BANG(INDEXA)=BANGN(I)
                 NEWA(INDEXA)=.TRUE.
                 DO 460 K=1,NGAS
                 DO 470 L=1,NBTAB
                 VGAS2(K,INDEXA,L)=0
                 XGAS2(K,INDEXA,L)=0
                 YGAS2(K,INDEXA,L)=0
                 DGAS2(K,INDEXA,L)=0
                 OGAS2(K,INDEXA,L)=0
                 AGAS2(K,INDEXA,L)=0
                 AORIG2(K,INDEXA,L)=0
                 BGAS2(K,INDEXA,L)=0
                 MGAS2(K,INDEXA,L)=0
                 WGAS2(K,INDEXA,L)=0
                 DO 475 N=1,6
                 SGAS2(K,INDEXA,L,N)=0
475              CONTINUE
                 DO 476 N=1,NEXGAS
                 EXGAS2(K,INDEXA,L,N)=0
476              CONTINUE
                 DO 477 N=1,NIOGAS
                 IOGAS2(K,INDEXA,L,N)=0
477              CONTINUE
                 HGAS2(K,INDEXA,L)=0
470              CONTINUE
460              CONTINUE
*   Next new value.
400              CONTINUE
            ENDIF
*** Extend a 1-dimensional table.
       ELSE
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Extending the table in 1D mode.'')')
**  Insert room in the tables for new columns in E.
            IF(IEMODE.EQ.0)THEN
                 DO 700 I=1,NGASN
                 DO 710 J=1,NGAS
*   If it overlaps with existing E, either keep old or new data.
                 IF(ABS(EGASN(I)-EGAS(J)).LE.EPSE*(ABS(EGASN(I))+
     -                ABS(EGAS(J))))THEN
                      IF(REPOLD)THEN
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Replacing existing data for E = ',
     -                          EGAS(J)*PGAS,' V/cm by data from file.'
                           INDEXE=J
                           GOTO 730
                      ELSE
                           PRINT *,' ------ GASMRG MESSAGE :'//
     -                          ' Keeping existing data for E = ',
     -                          EGAS(J)*PGAS,' V/cm, not using data',
     -                          ' from the file.'
                           GOTO 700
                      ENDIF
*   Otherwise shift all data at higher E values.
                 ELSEIF(EGASN(I).LT.EGAS(J))THEN
                      IF(NGAS+1.GT.MXLIST)GOTO 3010
                      IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                     '' DEBUG   : Inserting E = '',E15.8,
     -                     '' V/cm at slot '',I5)') EGASN(I)*PGAS,J
                      DO 720 M=NGAS,J,-1
                      EGAS(M+1)=EGAS(M)
                      VGAS(M+1)=VGAS(M)
                      XGAS(M+1)=XGAS(M)
                      YGAS(M+1)=YGAS(M)
                      DGAS(M+1)=DGAS(M)
                      OGAS(M+1)=OGAS(M)
                      AGAS(M+1)=AGAS(M)
                      AORIG(M+1)=AORIG(M)
                      BGAS(M+1)=BGAS(M)
                      MGAS(M+1)=MGAS(M)
                      WGAS(M+1)=WGAS(M)
                      DO 725 N=1,6
                      SGAS(M+1,N)=SGAS(M,N)
725                   CONTINUE
                      HGAS(M+1)=HGAS(M)
                      DO 726 N=1,NEXGAS
                      EXGAS(M+1,N)=EXGAS(M,N)
726                   CONTINUE
                      DO 727 N=1,NIOGAS
                      IOGAS(M+1,N)=IOGAS(M,N)
727                   CONTINUE
                      NEWE(M+1)=NEWE(M)
720                   CONTINUE
                      NGAS=NGAS+1
                      INDEXE=J
                      GOTO 730
                 ENDIF
*   Next old value.
710              CONTINUE
*   If there is no higher E, then add the line at the end.
                 IF(NGAS+1.GT.MXLIST)GOTO 3010
                 NGAS=NGAS+1
                 INDEXE=NGAS
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG'',
     -                '' DEBUG   : Adding E = '',E15.8,
     -                '' V/cm at end '',I5)') EGASN(I)*PGAS
*   Zero the new row.
730              CONTINUE
                 EGAS(INDEXE)=EGASN(I)
                 NEWE(INDEXE)=.TRUE.
                 VGAS(INDEXE)=0
                 XGAS(INDEXE)=0
                 YGAS(INDEXE)=0
                 DGAS(INDEXE)=0
                 OGAS(INDEXE)=0
                 AGAS(INDEXE)=0
                 AORIG(INDEXE)=0
                 BGAS(INDEXE)=0
                 MGAS(INDEXE)=0
                 WGAS(INDEXE)=0
                 DO 735 N=1,6
                 SGAS(INDEXE,N)=0
735              CONTINUE
                 HGAS(INDEXE)=0
                 DO 736 N=1,NEXGAS
                 EXGAS(INDEXE,N)=0
736              CONTINUE
                 DO 737 N=1,NIOGAS
                 IOGAS(INDEXE,N)=0
737              CONTINUE
*   Next new value.
700              CONTINUE
            ENDIF
       ENDIF
*** Read the gas composition and check.
       READ(12,'(/(5E15.8))',IOSTAT=IOS,ERR=2010,END=2000)
     -      (GASFRN(I),I=1,MXNBMC)
       DO 743 I=1,MXNBMC
       IF(ABS(GASFRN(I)-GASFRM(I)).GT.
     -      1.0E-6*(1+ABS(GASFRN(I))+ABS(GASFRM(I))))THEN
            PRINT *,' !!!!!! GASMRG WARNING : Gas composition'//
     -           ' differs at molecule ',I,'; file not read.'
            CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
            RETURN
       ENDIF
743    CONTINUE
*** Check that the excitations and ionisations match.
       DO 741 I=1,NEXGSN
*   Version 12 update
       read(12,'(19x,a45,2x,4e15.8)',iostat=ios,err=2010)
     -      desc,enexg(i),penprb(i),penrms(i),pendt(i)
C       READ(12,'(19X,A)',IOSTAT=IOS,ERR=2010) DESC
       CALL GASIDE(IEXC,DESC,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! GASMRG WARNING : Excitation'//
     -           ' description ',DESC,' not found.'
            CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
            RETURN
       ELSE
            LOOKEX(I)=IEXC
       ENDIF
741    CONTINUE
       DO 742 I=1,NIOGSN
*   Version 12 update
       read(12,'(19x,a45,2x,e15.8)',iostat=ios,err=2010)
     -      desc,eniog(i)
C       READ(12,'(19X,A)',IOSTAT=IOS,ERR=2010) DESC
       CALL GASIDI(IION,DESC,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! GASMRG WARNING : Ionisation'//
     -           ' description ',DESC,' not found.'
            CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
            RETURN
       ELSE
            LOOKIO(I)=IION
       ENDIF
742    CONTINUE
*** Skip the table header line.
       READ(12,'(1X)',END=2000,IOSTAT=IOS,ERR=2010)
*** Read a table written in 3D format (output always 3D).
       IF(TAB2DN)THEN
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Reading a 3D table.'')')
*   Loop over the table.
            DO 610 I=1,NGASN
            DO 620 J=1,NBANGN
            DO 630 K=1,NBTABN
*   Read the record.
            READ(12,'(8E15.8)',IOSTAT=IOS,ERR=2010,END=2000)
     -           VGASN,XGASN,YGASN,DGASN,OGASN,AGASN,AORIN,BGASN,MGASN,
     -           WGASN,HGASN,(SGASN(N),N=1,6),(EXGASN(N),N=1,NEXGSN),
     -           (IOGASN(N),N=1,NIOGSN)
*   Locate the index at which these values are to be stored.
            INDEXE=0
            DO 640 L=1,NGAS
            IF(ABS(EGASN(I)-EGAS(L)).LE.EPSE*(ABS(EGASN(I))+
     -           ABS(EGAS(L))))INDEXE=L
640         CONTINUE
            INDEXA=0
            DO 650 L=1,NBANG
            IF(ABS(BANGN(J)-BANG(L)).LE.EPSA*(ABS(BANGN(J))+
     -           ABS(BANG(L))))INDEXA=L
650         CONTINUE
            INDEXB=0
            DO 660 L=1,NBTAB
            IF(ABS(BTABN(K)-BTAB(L)).LE.EPSB*(ABS(BTABN(K))+
     -           ABS(BTAB(L))))INDEXB=L
660         CONTINUE
            IF(INDEXE.EQ.0.OR.INDEXA.EQ.0.OR.INDEXB.EQ.0)THEN
                 PRINT *,' !!!!!! GASMRG WARNING : Unable to locate'//
     -                ' the (E,angle,B) insertion point; no gas data'//
     -                ' read.'
                 CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
                 RETURN
            ENDIF
*   Store the data.
            IF(GASOKN( 1).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 1)))
     -           VGAS2(INDEXE,INDEXA,INDEXB)=VGASN
            IF(GASOKN( 2).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 2)))
     -           MGAS2(INDEXE,INDEXA,INDEXB)=MGASN
            IF(GASOKN( 3).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 3)))
     -           DGAS2(INDEXE,INDEXA,INDEXB)=DGASN
            IF(GASOKN( 4).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 4)))THEN
                 AGAS2(INDEXE,INDEXA,INDEXB)=AGASN
                 AORIG2(INDEXE,INDEXA,INDEXB)=AORIN
            ENDIF
            IF(GASOKN( 6).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 6)))
     -           BGAS2(INDEXE,INDEXA,INDEXB)=BGASN
            IF(GASOKN( 7).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 7)))
     -           WGAS2(INDEXE,INDEXA,INDEXB)=WGASN
            IF(GASOKN( 8).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 8)))
     -           OGAS2(INDEXE,INDEXA,INDEXB)=OGASN
            IF(GASOKN( 9).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 9)))
     -           XGAS2(INDEXE,INDEXA,INDEXB)=XGASN
            IF(GASOKN(10).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(10)))
     -           YGAS2(INDEXE,INDEXA,INDEXB)=YGASN
            IF(GASOKN(11).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(11)))THEN
                 DO 635 N=1,6
                 SGAS2(INDEXE,INDEXA,INDEXB,N)=SGASN(N)
635              CONTINUE
            ENDIF
            IF(GASOKN(12).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(12)))
     -           HGAS2(INDEXE,INDEXA,INDEXB)=HGASN
            IF(GASOKN(15).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(15)))THEN
                 DO 636 N=1,NEXGSN
                 EXGAS2(INDEXE,INDEXA,INDEXB,LOOKEX(N))=EXGASN(N)
636              CONTINUE
            ENDIF
            IF(GASOKN(16).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -           NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(16)))THEN
                 DO 637 N=1,NIOGSN
                 IOGAS2(INDEXE,INDEXA,INDEXB,LOOKIO(N))=IOGASN(N)
637              CONTINUE
            ENDIF
630         CONTINUE
620         CONTINUE
610         CONTINUE
**  In case of full overlap, update the GASOK bits.
            IF(IEMODE+IAMODE+IBMODE.EQ.3)THEN
                 DO 500 I=1,12
                 IF(I.EQ.5)GOTO 500
                 IF(GASOKN(I))GASOK(I)=.TRUE.
500              CONTINUE
            ENDIF
*** Read a table written in 1D mode.
       ELSE
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Reading a 1D table.'')')
*   Read the tables proper.
            DO 750 I=1,NGASN
            READ(12,'(8E15.8)',END=2000,IOSTAT=IOS,ERR=2010)
     -           VGASN,CVGASN,XGASN,CXGASN,YGASN,CYGASN,
     -           DGASN,CDGASN,OGASN,COGASN,AGASN,CAGASN,AORIN,
     -           BGASN,CBGASN,MGASN,CMGASN,WGASN,CWGASN,
     -           HGASN,CHGASN,
     -           (SGASN(N),CSGASN(N),N=1,6),
     -           (EXGASN(N),CEXGSN(N),N=1,NEXGSN),
     -           (IOGASN(N),CIOGSN(N),N=1,NIOGSN)
*   Locate the index at which these values are to be stored.
            INDEXE=0
            DO 760 L=1,NGAS
            IF(ABS(EGASN(I)-EGAS(L)).LE.EPSE*(ABS(EGASN(I))+
     -           ABS(EGAS(L))))INDEXE=L
760         CONTINUE
            INDEXA=0
            DO 770 L=1,NBANG
            IF(ABS(BANGN(1)-BANG(L)).LE.EPSA*(ABS(BANGN(1))+
     -           ABS(BANG(L))))INDEXA=L
770         CONTINUE
            INDEXB=0
            DO 780 L=1,NBTAB
            IF(ABS(BTABN(1)-BTAB(L)).LE.EPSB*(ABS(BTABN(1))+
     -           ABS(BTAB(L))))INDEXB=L
780         CONTINUE
            IF(INDEXE.EQ.0.OR.INDEXA.EQ.0.OR.INDEXB.EQ.0)THEN
                 PRINT *,' !!!!!! GASMRG WARNING : Unable to locate'//
     -                ' the (E,angle,B) insertion point; no gas data'//
     -                ' read.'
                 CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
                 RETURN
            ENDIF
*   Store the data.
            IF(TAB2D)THEN
                 IF(GASOKN( 1).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 1)))
     -                VGAS2(INDEXE,INDEXA,INDEXB)=VGASN
                 IF(GASOKN( 2).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 2)))
     -                MGAS2(INDEXE,INDEXA,INDEXB)=MGASN
                 IF(GASOKN( 3).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 3)))
     -                DGAS2(INDEXE,INDEXA,INDEXB)=DGASN
                 IF(GASOKN( 4).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 4)))THEN
                      AGAS2(INDEXE,INDEXA,INDEXB)=AGASN
                      AORIG2(INDEXE,INDEXA,INDEXB)=AORIN
                 ENDIF
                 IF(GASOKN( 6).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 6)))
     -                BGAS2(INDEXE,INDEXA,INDEXB)=BGASN
                 IF(GASOKN( 7).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 7)))
     -                WGAS2(INDEXE,INDEXA,INDEXB)=WGASN
                 IF(GASOKN( 8).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 8)))
     -                OGAS2(INDEXE,INDEXA,INDEXB)=OGASN
                 IF(GASOKN( 9).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK( 9)))
     -                XGAS2(INDEXE,INDEXA,INDEXB)=XGASN
                 IF(GASOKN(10).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(10)))
     -                YGAS2(INDEXE,INDEXA,INDEXB)=YGASN
                 IF(GASOKN(11).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(11)))THEN
                      DO 785 N=1,6
                      SGAS2(INDEXE,INDEXA,INDEXB,N)=SGASN(N)
785                   CONTINUE
                 ENDIF
                 IF(GASOKN(12).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(12)))
     -                HGAS2(INDEXE,INDEXA,INDEXB)=HGASN
                 IF(GASOKN(15).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(15)))THEN
                      DO 786 N=1,NEXGSN
                      EXGAS2(INDEXE,INDEXA,INDEXB,LOOKEX(N))=EXGASN(N)
786                   CONTINUE
                 ENDIF
                 IF(GASOKN(16).AND.(NEWE(INDEXE).OR.NEWA(INDEXA).OR.
     -                NEWB(INDEXB).OR.REPOLD.OR..NOT.GASOK(16)))THEN
                      DO 787 N=1,NIOGSN
                      IOGAS2(INDEXE,INDEXA,INDEXB,LOOKIO(N))=IOGASN(N)
787                   CONTINUE
                 ENDIF
            ELSE
                 IF(GASOKN( 1).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 1)))VGAS(INDEXE)=VGASN
                 IF(GASOKN( 2).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 2)))MGAS(INDEXE)=MGASN
                 IF(GASOKN( 3).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 3)))DGAS(INDEXE)=DGASN
                 IF(GASOKN( 4).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 4)))AGAS(INDEXE)=AGASN
                 IF(GASOKN( 4).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 4)))AORIG(INDEXE)=AORIN
                 IF(GASOKN( 6).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 6)))BGAS(INDEXE)=BGASN
                 IF(GASOKN( 7).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 7)))WGAS(INDEXE)=WGASN
                 IF(GASOKN( 8).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 8)))OGAS(INDEXE)=OGASN
                 IF(GASOKN( 9).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK( 9)))XGAS(INDEXE)=XGASN
                 IF(GASOKN(10).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK(10)))YGAS(INDEXE)=YGASN
                 IF(GASOKN(11).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK(11)))THEN
                      DO 755 N=1,6
                      SGAS(INDEXE,N)=SGASN(N)
755                   CONTINUE
                 ENDIF
                 IF(GASOKN(12).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK(12)))HGAS(INDEXE)=HGASN
                 IF(GASOKN(15).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK(15)))THEN
                      DO 756 N=1,NEXGSN
                      EXGAS(INDEXE,LOOKEX(N))=EXGASN(N)
756                   CONTINUE
                 ENDIF
                 IF(GASOKN(16).AND.(REPOLD.OR.NEWE(INDEXE).OR.
     -                .NOT.GASOK(16)))THEN
                      DO 757 N=1,NIOGSN
                      IOGAS(INDEXE,LOOKIO(N))=IOGASN(N)
757                   CONTINUE
                 ENDIF
            ENDIF
750         CONTINUE
**  Consider extrapolation data only if REPLACE-OLD is set.
            IF(REPOLD)THEN
*   Debugging.
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -                '' Replacing extrapolation data.'')')
*   Read upper extrapolation data.
                 READ(12,'(9X,13I5)',END=2000,IOSTAT=IOS,ERR=2010)
     -                IVEXTN,IXEXTN,IYEXTN,IDEXTN,IAEXTN,IBEXTN,IMEXTN,
     -                IWEXTN,IOEXTN,IHEXTN,ISEXTN,IEEXTN,IZEXTN
*   Replace where appropriate.
                 IF(GASOKN(1))IVEXTR=IVEXTN
                 IF(GASOKN(2))IMEXTR=IMEXTN
                 IF(GASOKN(3))IDEXTR=IDEXTN
                 IF(GASOKN(4))IAEXTR=IAEXTN
                 IF(GASOKN(6))IBEXTR=IBEXTN
                 IF(GASOKN(7))IWEXTR=IWEXTN
                 IF(GASOKN(8))IOEXTR=IOEXTN
                 IF(GASOKN(9))IXEXTR=IXEXTN
                 IF(GASOKN(10))IYEXTR=IYEXTN
                 IF(GASOKN(11))ISEXTR=ISEXTN
                 IF(GASOKN(12))IHEXTR=IHEXTN
                 IF(GASOKN(15))IEEXTR=IEEXTN
                 IF(GASOKN(16))IZEXTR=IZEXTN
*   Read lower extrapolation data.
                 READ(12,'(9X,13I5)',END=2000,IOSTAT=IOS,ERR=2010)
     -                JVEXTN,JXEXTN,JYEXTN,JDEXTN,JAEXTN,JBEXTN,JMEXTN,
     -                JWEXTN,JOEXTN,JHEXTN,JSEXTN,JEEXTN,JZEXTN
*   Replace where appropriate.
                 IF(GASOKN(1))JVEXTR=JVEXTN
                 IF(GASOKN(2))JMEXTR=JMEXTN
                 IF(GASOKN(3))JDEXTR=JDEXTN
                 IF(GASOKN(4))JAEXTR=JAEXTN
                 IF(GASOKN(6))JBEXTR=JBEXTN
                 IF(GASOKN(7))JWEXTR=JWEXTN
                 IF(GASOKN(8))JOEXTR=JOEXTN
                 IF(GASOKN(9))JXEXTR=JXEXTN
                 IF(GASOKN(10))JYEXTR=JYEXTN
                 IF(GASOKN(11))JSEXTR=JSEXTN
                 IF(GASOKN(12))JHEXTR=JHEXTN
                 IF(GASOKN(15))JEEXTR=JEEXTN
                 IF(GASOKN(16))JZEXTR=JZEXTN
**  Otherwise skip the records associated with this.
            ELSE
*   Debugging.
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -                '' Skipping extrapolation data.'')')
*   Skip the 2 records with data.
                 READ(12,'(/)',IOSTAT=IOS,ERR=2010)
            ENDIF
**  Update the GASOK bits for merge mode.
            IF(IEMODE.NE.0)THEN
                 DO 740 I=1,16
                 IF(I.EQ.5.OR.I.EQ.13.OR.I.EQ.14)GOTO 740
                 IF(GASOKN(I))GASOK(I)=.TRUE.
740              CONTINUE
            ENDIF
       ENDIF
*** Replace interpolation methods only when REPLACE-OLD is set.
       IF(REPOLD)THEN
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing interpolation + threshold data.'')')
*   Read the Townsend and attachment threshold data.
            READ(12,'(13X,BN,3I10)',IOSTAT=IOS,ERR=2010)
     -           IATHRN,IBTHRN,IHTHRN
            IF(GASOKN(4))IATHR=IATHRN
            IF(GASOKN(6))IBTHR=IBTHRN
            IF(GASOKN(12))IHTHR=IHTHRN
*   Read the interpolation data.
            READ(12,'(9X,BN,13I5)',IOSTAT=IOS,ERR=2010)
     -           IVMETN,IXMETN,IYMETN,IDMETN,IAMETN,IBMETN,IMMETN,
     -           IWMETN,IOMETN,IHMETN,ISMETN,IEMETN,IZMETN
            IF(GASOK( 1))IVMETH=IVMETN
            IF(GASOK( 2))IMMETH=IMMETN
            IF(GASOK( 3))IDMETH=IDMETN
            IF(GASOK( 4))IAMETH=IAMETN
            IF(GASOK( 6))IBMETH=IBMETN
            IF(GASOK( 7))IWMETH=IWMETN
            IF(GASOK( 8))IOMETH=IOMETN
            IF(GASOK( 9))IXMETH=IXMETN
            IF(GASOK(10))IYMETH=IYMETN
            IF(GASOK(11))ISMETH=ISMETN
            IF(GASOK(12))IHMETH=IHMETN
            IF(GASOK(15))IEMETH=IEMETN
            IF(GASOK(16))IZMETH=IZMETN
**  Otherwise skip the record.
       ELSE
*   Debugging.
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping interpolation + threshold data.'')')
*   Skip the records.
            READ(12,'(/)',IOSTAT=IOS,ERR=2010)
       ENDIF
*** Read cluster data.
       READ(12,'(4(8X,E15.8,1X))',END=2000,IOSTAT=IOS,ERR=2010)
     -      AN,ZN,EMPRBN,EPAIRN
       IF(AN.GT.0.AND.ZN.GT.0.AND.EMPRBN.GT.0.AND.EPAIRN.GT.0.AND.
     -      REPOLD)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing A, Z, EMPROB and EPAIR.'')')
            A=AN
            Z=ZN
            EMPROB=EMPRBN
            EPAIR=EPAIRN
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping A, Z, EMPROB and EPAIR.'')')
       ENDIF
*   Ion diffusion.
       READ(12,'(16X,2E15.8)') DLIONN,DTIONN
       IF(DLIONN.GT.0.AND.DTIONN.GT.0.AND.REPOLD)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing ion diffusion.'')')
            DLION=DLIONN
            DTION=DTIONN
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping ion diffusion.'')')
       ENDIF
*   Further cluster data.
       READ(12,'(4(8X,E15.8,1X))',END=2000,IOSTAT=IOS,ERR=2010)
     -      CMEANN,RHON,PGASN,TGASN
       IF(CMEANN.GT.0.AND.RHON.GT.0.AND.REPOLD)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing mean number of clusters + density.'')')
            CMEAN=CMEANN
            RHO=RHON
            IF(SRMDEN.GT.0)PRINT *,' ------ GASMRG MESSAGE :'//
     -           ' SRIM gas density replaced by new value.'
            SRMDEN=RHO
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping mean number of clusters + density.'')')
       ENDIF
       IF(ABS(PGASN-PGAS).GT.1E-3*(ABS(PGAS)+ABS(PGASN)))THEN
            PRINT *,' ------ GASMRG MESSAGE : The gas pressure of'//
     -           ' the file differs from the currently set pressure.'
            IF(REPOLD)PGAS=PGASN
       ENDIF
       IF(ABS(TGASN-TGAS).GT.1E-3*(ABS(TGAS)+ABS(TGASN)))THEN
            PRINT *,' ------ GASMRG MESSAGE : The gas temperature of'//
     -           ' the file differs from the currently set temperature.'
            IF(REPOLD)TGAS=TGASN
       ENDIF
*   Clustering model and cluster size distribution.
       READ(12,'(13X,A10)',END=2000,IOSTAT=IOS,ERR=2010) CLSTPN
       IF(CLSTPN.NE.'NOT SET'.AND.(CLSTYP.EQ.'NOT SET'.OR.REPOLD))THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing cluster tables.'')')
            READ(12,'(13X,A80)',END=2000,IOSTAT=IOS,ERR=2010) FCNCLS
            READ(12,'(13X,BN,I10)',END=2000,IOSTAT=IOS,ERR=2010) NCLS
            READ(12,'(13X,D25.18)',END=2000,IOSTAT=IOS,ERR=2010) CLSAVE
            DO 800 J=1,NCLS,5
            READ(12,'(5D25.18)',END=2000,IOSTAT=IOS,ERR=2010)
     -           (CLSDIS(I),I=J,MIN(J+4,NCLS))
800         CONTINUE
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping cluster tables.'')')
            READ(12,'(/13X,BN,I10/)',END=2000,IOSTAT=IOS,ERR=2010) NCLSN
            DO 810 J=1,NCLSN,5
            READ(12,'(/)',END=2000,IOSTAT=IOS,ERR=2010)
810         CONTINUE
       ENDIF
*   Clustering GASOK bit.
       IF(GASOKN(5))GASOK(5)=.TRUE.
*   Heed initialisation data.
       READ(12,'(28X,L1)',END=2000,ERR=2010,IOSTAT=IOS) HEEDN
       IF(HEEDN.AND.(REPOLD.OR..NOT.HEEDOK))THEN
            BACKSPACE(12,ERR=2040,IOSTAT=IOS)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing Heed initialisation data.'')')
            CALL GASHGT(IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! GASNRG WARNING : Reading Heed data'//
     -                ' failed ; gas data not available.'
                 RETURN
            ENDIF
       ELSEIF(HEEDN)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Reading but not using Heed initialisation data.'')')
            READ(12,'(18X,I5)',END=2000,ERR=2010,IOSTAT=IOS) NQMOL
            DO 820 I=1,NQMOL
            READ(12,'()',END=2000,ERR=2010,IOSTAT=IOS) 
820         CONTINUE
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping Heed initialisation data.'')')
       ENDIF
*   SRIM initialisation data.
       READ(12,'(28X,L1)',END=2000,ERR=2010,IOSTAT=IOS) SRIMN
       IF(SRIMN.AND.(REPOLD.OR..NOT.SRIMOK))THEN
            BACKSPACE(12,ERR=2040,IOSTAT=IOS)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Replacing SRIM initialisation data.'')')
            CALL GASSGT(IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! GASNRG WARNING : Reading SRIM data'//
     -                ' failed ; gas data not available.'
                 RETURN
            ENDIF
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASMRG DEBUG   :'',
     -           '' Skipping SRIM initialisation data.'')')
       ENDIF
*** Close the file after the operation.
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       IFAIL=0
       CALL TIMLOG('Reading the gas data from a dataset:    ')
       RETURN
*** Handle the I/O error conditions.
2000   CONTINUE
       PRINT *,' ###### GASMRG ERROR   : EOF encountered while'//
     -      ' reading '//FILE(1:NCFILE)//' via unit 12 ;'//
     -      ' no gas data read.'
       CALL INPIOS(IOS)
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       RETURN
2010   CONTINUE
       PRINT *,' ###### GASMRG ERROR   : Error while reading '//
     -      FILE(1:NCFILE)//' via unit 12 ; no gas data read.'
       CALL INPIOS(IOS)
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       RETURN
2030   CONTINUE
       PRINT *,' ###### GASMRG ERROR   : Dataset '//FILE(1:NCFILE)//
     -      ' on unit 12 cannot be closed ; results not predictable.'
       CALL INPIOS(IOS)
       RETURN
2040   CONTINUE
       PRINT *,' ###### GASMRG ERROR   : Error while backspacing on '//
     -      FILE(1:NCFILE)//' via unit 12 ; no gas data read.'
       CALL INPIOS(IOS)
       RETURN
*** Handle dimension errors.
3010   CONTINUE
       PRINT *,' !!!!!! GASMRG WARNING : Number of E fields in the'//
     -      ' table grows beyond MXLIST; reading the file is aborted.'
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       IFAIL=1
       RETURN
3020   CONTINUE
       PRINT *,' !!!!!! GASMRG WARNING : Number of B fields in the'//
     -      ' table grows beyond MXBTAB; reading the file is aborted.'
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       IFAIL=1
       RETURN
3030   CONTINUE
       PRINT *,' !!!!!! GASMRG WARNING : Number of E,B angles in the'//
     -      ' table grows beyond MXBANG; reading the file is aborted.'
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       IFAIL=1
       RETURN
       END
CDECK  ID>, SRMINT.
       SUBROUTINE SRMINT
*-----------------------------------------------------------------------
*   SRMINT - Initialises SRIM data
*   (Last changed on 27/ 6/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
*** Number of records in energy loss and straggling table
       NSRIM = 0
*** Work function
       WSRIM = 0.0
*** Fano factor
       FSRIM = 0.17
*** Number of clusters
       NCSRIM = 0
       END
CDECK  ID>, SRMREA.
       SUBROUTINE SRMREA(FILE,NC,IFAIL)
*-----------------------------------------------------------------------
*   SRMREA - Reads SRIM energy loss tables
*   (Last changed on  8/ 3/13.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       CHARACTER*(*) FILE
       CHARACTER*80 LINE
       INTEGER NC,IFAIL,IFAIL1,NCLINE,NWORD,INPCMP,INPTYP,I,J,ISKIP
       REAL SCALE
       LOGICAL OK
       EXTERNAL INPCMP,INPTYP
*** Assume this will fail.
       IFAIL=1
*** Open the file
       CALL DSNOPN(FILE,NC,12,'READ-FILE',IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! SRMREA WARNING : Unable to open the'//
     -           ' energy loss table ',FILE(1:NC),'; not read.'
            RETURN
       ENDIF
*   Record the opening.
       CALL DSNLOG(FILE(1:NC),'SRIM table','Sequential',
     -      'Read only ')
*   Read the header records, switch to the data file.
       CALL INPSWI('UNIT12')
*** Obtain header information, start with the version
       ISKIP=0
 100   CONTINUE
       CALL INPGET
       CALL INPNUM(NWORD)
       CALL INPSTR(1,NWORD,LINE,NCLINE)
       IF(INDEX(LINE(1:MAX(1,NCLINE)),'SRIM VERSION').NE.0.AND.
     -      LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -           '' SRIM version: '',A)') LINE(1:NCLINE)
       ELSEIF(INDEX(LINE(1:MAX(1,NCLINE)),'CALC. DATE').NE.0.AND.
     -      LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -           '' Run date: '',A)') LINE(1:NCLINE)
       ELSEIF(INDEX(LINE(1:MAX(1,NCLINE)),'ION =').NE.0)THEN
            GOTO 110
       ENDIF
       ISKIP=ISKIP+1
       IF(ISKIP.GT.20)THEN
            PRINT *,' ###### SRMREA ERROR   : Did not find the header'//
     -           ' in SRIM file "',FILE(1:NC),'"; not read.'
            IFAIL=1
            RETURN
       ENDIF
       GOTO 100
 110   CONTINUE
*   Obtain the ion (amu to eV factor from NIST).
       CALL INPSTR(2,NWORD,LINE,NCLINE)
       IF(NCLINE.LE.0)NCLINE=1
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -      '' Ion: '',A)') LINE(1:NCLINE)
       CALL INPSTR(2,2,PNAME,NCPNAM)
       CALL INPCHK(5,2,IFAIL1)
       CALL INPRDR(5,TRMASS,-1.0)
       TRMASS=TRMASS*931.494061
       CALL INPSTR(3,3,LINE,NCLINE)
       LINE(1:1)=' '
       LINE(NCLINE:NCLINE)=' '
       CALL INPRRC(LINE(1:NCLINE),TRCHAR,0.0,IFAIL1)
       IF(TRMASS.LE.0.OR.TRCHAR.LE.0)THEN
            PRINT *,' !!!!!! SRMREA WARNING : Found no valid'//
     -           ' projectile mass and charge in SRIM file;'//
     -           ' data rejected.'
            CALL INPSWI('RESTORE')
            RETURN
       ENDIF
*   Obtain the target density and copy to /GASDAT/ RHO
       CALL INPGET
       CALL INPGET
       IF(INPTYP(2).EQ.2)THEN
            CALL INPCHK(2,2,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 CALL INPERR
                 PRINT *,' !!!!!! SRMREA WARNING : Error reading'//
     -                ' the SRIM gas density; file not read.'
                 CALL INPSWI('RESTORE')
                 RETURN
            ENDIF
            CALL INPRDR(2,SRMDEN,-1.0)
       ELSEIF(INPTYP(3).EQ.2)THEN
            CALL INPCHK(3,2,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 CALL INPERR
                 PRINT *,' !!!!!! SRMREA WARNING : Error reading'//
     -                ' the SRIM gas density; file not read.'
                 CALL INPSWI('RESTORE')
                 RETURN
            ENDIF
            CALL INPRDR(3,SRMDEN,-1.0)
       ELSE
            PRINT *,' !!!!!! SRMREA WARNING : Did not find the'//
     -           ' SRIM gas density; file not read.'
            CALL INPSWI('RESTORE')
            RETURN
       ENDIF
       IF(SRMDEN.GT.0)THEN
            IF(RHO.GT.0)PRINT *,' ------ SRMREA MESSAGE : Earlier'//
     -           ' gas density has been replaced by SRIM data.'
            RHO=SRMDEN
       ELSE
            PRINT *,' !!!!!! SRMREA WARNING : Gas density obtained'//
     -           ' from SRIM file is not positive; file not read.'
            CALL INPSWI('RESTORE')
            RETURN
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -      '' Density: '',E10.3,'' g/cm3'')') SRMDEN
*   Obtain the target composition
       CALL INPGET
       CALL INPGET
       CALL INPGET
       CALL INPGET
10     CONTINUE
       CALL INPGET
       CALL INPSTR(1,1,LINE,NCLINE)
       CALL INPNUM(NWORD)
       IF(NWORD.EQ.0.OR.LINE(2:10).EQ.'=========')GOTO 20
       CALL INPNUM(NWORD)
       CALL INPSTR(1,NWORD,LINE,NCLINE)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -      '' Target material: '',A)') LINE(1:NCLINE)
       GOTO 10
20     CONTINUE
*   Skip the Bragg correction.
       CALL INPGET
*   Obtain the stopping units.
       CALL INPGET
       CALL INPNUM(NWORD)
       CALL INPSTR(3,NWORD,LINE,NCLINE)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -      '' Stopping unit: '',A)') LINE(1:NCLINE)
*   Skip until the line below the table header
       ISKIP=0
80     CONTINUE
       ISKIP=ISKIP+1
       IF(ISKIP.GT.10)THEN
            PRINT *,' !!!!!! SRMREA WARNING : Unable to locate the'//
     -           ' table header; SRIM file not read.'
            CALL INPSWI('RESTORE')
            RETURN
       ENDIF
       CALL INPGET
       CALL INPSTR(1,1,LINE,NCLINE)
       IF(LINE(1:11).NE.'-----------')GOTO 80
*** Read the tables.
       NSRIM=0
       OK=.TRUE.
30     CONTINUE
*   Get a line
       CALL INPGET
*   See whether this is the end
       CALL INPSTR(1,1,LINE,NCLINE)
       IF(LINE(1:10).EQ.'----------')GOTO 40
       CALL INPNUM(NWORD)
       IF(NWORD.NE.10)THEN
            PRINT *,' !!!!!! SRMREA WARNING : Unexpected end of file'//
     -           ' encountered on file ',FILE(1:NC),'.'
            OK=.FALSE.
            GOTO 40
       ENDIF
*   Increment the record
       IF(NSRIM.LT.MXLIST)THEN
            NSRIM=NSRIM+1
       ELSE
            PRINT *,' !!!!!! SRMREA WARNING : Too many input records;'//
     -           ' stopped reading after MXLIST lines.'
            OK=.FALSE.
            GOTO 40
       ENDIF
*   Read the energy [SRIM unit: follows in field 2]
       CALL INPCHK(1,2,IFAIL1)
       CALL INPRDR(1,ESRIM(NSRIM),0.0)
       IF(INPCMP(2,'EV').NE.0)THEN
            ESRIM(NSRIM)=ESRIM(NSRIM)*1e-6
       ELSEIF(INPCMP(2,'KEV').NE.0)THEN
            ESRIM(NSRIM)=ESRIM(NSRIM)*1e-3
       ELSEIF(INPCMP(2,'MEV').NE.0)THEN
            ESRIM(NSRIM)=ESRIM(NSRIM)*1
       ELSEIF(INPCMP(2,'GEV').NE.0)THEN
            ESRIM(NSRIM)=ESRIM(NSRIM)*1e3
       ELSE
            CALL INPSTR(2,2,LINE,NCLINE)
            PRINT *,' !!!!!! SRMREA WARNING : Unknown energy unit'//
     -           ' encountered: "'//LINE(1:NCLINE)//'".'
            OK=.FALSE.
       ENDIF
*   Read the em dedx [SRIM unit: see above, usually 1e3 MeV.cm2/g]
       CALL INPCHK(3,2,IFAIL1)
       CALL INPRDR(3,SRMEM(NSRIM),0.0)
*   Read the hd dedx [SRIM unit: see above, usually 1e3 MeV.cm2/g]
       CALL INPCHK(4,2,IFAIL1)
       CALL INPRDR(4,SRMHD(NSRIM),0.0)
*   Read range [SRIM unit: follows in field 6]
       CALL INPCHK(5,2,IFAIL1)
       CALL INPRDR(5,SRMRNG(NSRIM),0.0)
       IF(INPCMP(6,'A').NE.0)THEN
            SRMRNG(NSRIM)=SRMRNG(NSRIM)*1E-8
       ELSEIF(INPCMP(6,'UM').NE.0)THEN
            SRMRNG(NSRIM)=SRMRNG(NSRIM)*1E-4
       ELSEIF(INPCMP(6,'MM').NE.0)THEN
            SRMRNG(NSRIM)=SRMRNG(NSRIM)*1E-1
       ELSEIF(INPCMP(6,'CM').NE.0)THEN
            SRMRNG(NSRIM)=SRMRNG(NSRIM)*1
       ELSEIF(INPCMP(6,'M').NE.0)THEN
            SRMRNG(NSRIM)=SRMRNG(NSRIM)*1E2
       ELSE
            CALL INPSTR(6,6,LINE,NCLINE)
            PRINT *,' !!!!!! SRMREA WARNING : Range unit is not'//
     -           ' known: "'//LINE(1:NCLINE)//'".'
            OK=.FALSE.
       ENDIF
*   Read straggling [SRIM unit: follows in fields 8 and 10]
       CALL INPCHK(7,2,IFAIL1)
       CALL INPRDR(7,SRMDL(NSRIM),0.0)
       IF(INPCMP(8,'A').NE.0)THEN
            SRMDL(NSRIM)=SRMDL(NSRIM)*1E-8
       ELSEIF(INPCMP(8,'UM').NE.0)THEN
            SRMDL(NSRIM)=SRMDL(NSRIM)*1E-4
       ELSEIF(INPCMP(8,'MM').NE.0)THEN
            SRMDL(NSRIM)=SRMDL(NSRIM)*1E-1
       ELSEIF(INPCMP(8,'CM').NE.0)THEN
            SRMDL(NSRIM)=SRMDL(NSRIM)*1
       ELSEIF(INPCMP(6,'M').NE.0)THEN
            SRMDL(NSRIM)=SRMDL(NSRIM)*1E2
       ELSE
            CALL INPSTR(8,8,LINE,NCLINE)
            PRINT *,' !!!!!! SRMREA WARNING : Longitudinal straggling'//
     -           ' unit is not known: "'//LINE(1:NCLINE)//'".'
            OK=.FALSE.
       ENDIF
       CALL INPCHK(9,2,IFAIL1)
       CALL INPRDR(9,SRMDT(NSRIM),0.0)
       IF(INPCMP(10,'A').NE.0)THEN
            SRMDT(NSRIM)=SRMDT(NSRIM)*1E-8
       ELSEIF(INPCMP(10,'UM').NE.0)THEN
            SRMDT(NSRIM)=SRMDT(NSRIM)*1E-4
       ELSEIF(INPCMP(10,'MM').NE.0)THEN
            SRMDT(NSRIM)=SRMDT(NSRIM)*1E-1
       ELSEIF(INPCMP(10,'CM').NE.0)THEN
            SRMDT(NSRIM)=SRMDT(NSRIM)*1
       ELSEIF(INPCMP(6,'M').NE.0)THEN
            SRMDT(NSRIM)=SRMDT(NSRIM)*1E2
       ELSE
            CALL INPSTR(10,10,LINE,NCLINE)
            PRINT *,' !!!!!! SRMREA WARNING : Transverse straggling'//
     -           ' unit is not known: "'//LINE(1:NCLINE)//'".'
            OK=.FALSE.
       ENDIF
       GOTO 30
40     CONTINUE
*** End of table
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   : Read '',
     -      I5,'' records.'')') NSRIM
*   Skip 2 records of text
       CALL INPGET
       CALL INPGET
*   Read the conversion units and compare with the unit we want
       DO 50 I=1,8
       CALL INPGET
       CALL INPNUM(NWORD)
       CALL INPSTR(2,NWORD,LINE,NCLINE)
       IF(LINE(1:NCLINE).EQ.'MEV / (MG/CM2)'.OR.
     -      LINE(1:NCLINE).EQ.'MEV/(MG/CM2)')THEN
            CALL INPCHK(1,2,IFAIL1)
            CALL INPRDR(1,SCALE,1.0)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMREA DEBUG   :'',
     -          '' Stopping scaling: '',E12.5)') SCALE*1E3
            DO 60 J=1,NSRIM
            SRMEM(J)=SRMEM(J)*SCALE*1E3
            SRMHD(J)=SRMHD(J)*SCALE*1E3
60          CONTINUE
            GOTO 70
       ENDIF
50     CONTINUE
       PRINT *,' !!!!!! SRMREA WARNING : Did not find conversion'//
     -      ' factor for scaling to MeV cm2/mg; no scaling applied.'
       OK=.FALSE.
70     CONTINUE
*** Revert to normal reading
       CALL INPSWI('RESTORE')
*** Close the unit
       CLOSE(UNIT=12,ERR=2030)
*** Seems to have been successful.
       IF(OK)THEN
            IFAIL=0
       ELSE
            IFAIL=1
       ENDIF
       RETURN
*** I/O error handling
2030   CONTINUE
       PRINT *,' !!!!!! SRMREA WARNING : Error closing the input'//
     -      ' file ',FILE(1:NC),'; no immediate problems expected.'
       END
CDECK  ID>, SRMPLT.
       SUBROUTINE SRMPLT
*-----------------------------------------------------------------------
*   SRMPLT - Plots the SRIM tables
*   (Last changed on 13/12/06.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER I
       REAL DEPLT(MXLIST),DEMAX,STRMIN,STRMAX
*** Nothing to plot of there are 0 or fewer points.
       IF(NSRIM.LT.1)THEN
            PRINT *,' !!!!!! SRMPLT WARNING : Fewer than 1 point in'//
     -           ' the SRIM table; not plotted.'
            RETURN
       ENDIF
*** Energy loss
       DEMAX=0
       DO 10 I=1,NSRIM
       DEPLT(I)=SRMDEN*(SRMEM(I)+SRMHD(I))
       IF(DEPLT(I).GT.DEMAX)DEMAX=DEPLT(I)
10     CONTINUE
       CALL GRAOPT('LOG-X, LIN-Y')
       CALL GRCART(ESRIM(1),0.0,ESRIM(NSRIM),DEMAX*1.1,
     -      'Energy [MeV]','Energy loss [MeV/cm]',
     -      'SRIM energy loss')
       IF(NSRIM.GT.1)THEN
            CALL GRATTS('FUNCTION-1','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,DEPLT)
       ELSE
            CALL GRATTS('FUNCTION-1','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,DEPLT)
       ENDIF
       DO 20 I=1,NSRIM
       DEPLT(I)=SRMDEN*SRMEM(I)
20     CONTINUE
       IF(NSRIM.GT.1)THEN
            CALL GRATTS('FUNCTION-2','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,DEPLT)
       ELSE
            CALL GRATTS('FUNCTION-2','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,DEPLT)
       ENDIF
       DO 30 I=1,NSRIM
       DEPLT(I)=SRMDEN*SRMHD(I)
30     CONTINUE
       IF(NSRIM.GT.1)THEN
            CALL GRATTS('FUNCTION-3','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,DEPLT)
       ELSE
            CALL GRATTS('FUNCTION-3','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,DEPLT)
       ENDIF
       CALL GRNEXT
       CALL GRALOG('SRIM energy loss table.                 ')
*** Range and straggling
       STRMIN=SRMRNG(1)
       STRMAX=SRMRNG(1)
       DO 110 I=1,NSRIM
       IF(SRMRNG(I).GT.STRMAX)STRMAX=SRMRNG(I)
       IF(SRMDL(I).GT.STRMAX)STRMAX=SRMDL(I)
       IF(SRMDT(I).GT.STRMAX)STRMAX=SRMDT(I)
       IF(SRMRNG(I).LT.STRMIN)STRMIN=SRMRNG(I)
       IF(SRMDL(I).LT.STRMIN)STRMIN=SRMDL(I)
       IF(SRMDT(I).LT.STRMIN)STRMIN=SRMDT(I)
110    CONTINUE
       CALL GRAOPT('LOG-X, LOG-Y')
       CALL GRCART(ESRIM(1),STRMIN*0.9,ESRIM(NSRIM),STRMAX*1.1,
     -      'Energy [MeV]','Range, Straggling [cm]',
     -      'SRIM range and straggling')
       IF(NSRIM.GT.1)THEN
            CALL GRATTS('FUNCTION-1','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,SRMRNG)
            CALL GRATTS('FUNCTION-2','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,SRMDL)
            CALL GRATTS('FUNCTION-3','POLYLINE')
            CALL GRLINE(NSRIM,ESRIM,SRMDT)
            CALL GRNEXT
       ELSE
            CALL GRATTS('FUNCTION-1','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,SRMRNG)
            CALL GRATTS('FUNCTION-2','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,SRMDL)
            CALL GRATTS('FUNCTION-3','POLYMARKER')
            CALL GRMARK(NSRIM,ESRIM,SRMDT)
            CALL GRNEXT
       ENDIF
       CALL GRALOG('SRIM range and straggling tables.       ')
*** Reset options
       CALL GRAOPT('LIN-X, LIN-Y')
       END
CDECK  ID>, SRMGEN.
       SUBROUTINE SRMGEN(IFAIL)
*-----------------------------------------------------------------------
*   SRMGEN - Generates electrons for a SRIM track
*   (Last changed on 10/12/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL X,Y,Z,E,DEDXEM,DEDXHD,PRANGE,STRLON,STRLAT,SP,CP,ST,CT,
     -      DNORM,STEP,XDIR,YDIR,ZDIR,TRLEN,THETA,PHI,SIGT1,SIGT2,SIGL,
     -      ELOSS,DSUM,RANLAN,RNDUNI,RNDNOR,DIVDIF,RNDDE,DEEM,DEHD,
     -      SRMDEM,SRMDHD,STPMIN,STPMAX,EPOOL,ECL,ERND1
       INTEGER IFAIL,IFAIL1,I
       EXTERNAL DIVDIF,RANLAN,RNDUNI,RNDNOR,RNDDE,SRMDEM,SRMDHD
       LOGICAL FINISH
*** Assume this will fail
       IFAIL=1
*** Reset the cluster count
       NCSRIM=0
*** Initialise error count
       DO 30 I=1,10
       NTRERR(I)=0
30     CONTINUE
*** Initial situation: starting position
       X=XT0
       Y=YT0
       Z=ZT0
*   Initial direction
       XDIR=XT1-XT0
       YDIR=YT1-YT0
       ZDIR=ZT1-ZT0
       TRLEN=SQRT(XDIR**2+YDIR**2+ZDIR**2)
       IF(TRLEN.LE.0)THEN
            PRINT *,' !!!!!! SRMGEN WARNING : Track length = 0; no'//
     -           ' SRIM cluster generation.'
            RETURN
       ENDIF
       XDIR=XDIR/TRLEN
       YDIR=YDIR/TRLEN
       ZDIR=ZDIR/TRLEN
*** Header of debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   : Track'',
     -      '' generation with the following parameters:''/
     -      26X,''Table size         '',I12/
     -      26X,''Track length       '',E12.5,'' cm''/
     -      26X,''Particle energy    '',E12.5,'' MeV''/
     -      26X,''Particle mass      '',E12.5,'' MeV''/
     -      26X,''Particle charge    '',F12.1/
     -      26X,''Work function      '',E12.5,'' eV''/
     -      26X,''Fano factor        '',E12.5/
     -      26X,''Long. straggling:  '',L1/
     -      26X,''Trans. straggling: '',L1/
     -      26X,''Vavilov generator: '',L1/
     -      26X,''Cluster size       '',F12.1)')
     -      NSRIM,TRLEN,TRENER,TRMASS,TRCHAR,WSRIM,FSRIM,
     -      LDLSRM,LDTSRM,LTRVVL,TRNSRM
*   Initial energy
       E=TRENER
*   Total distance covered
       DSUM=0.0
*   Pool of unused energy
       EPOOL=0.0
*** Loop over the clusters
10     CONTINUE
**  See whether the particle has (numerically) stopped.
       IF(ABS(E).LT.1E-20*TRMASS.OR.ABS(E).LT.1E-9*WSRIM)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Particle energy E = '',E12.5,'' MeV such that'',
     -           '' beta2 = 0 or E << W; particle stopped.'')')  E
            ELOSS=E
            GOTO 40
       ENDIF
**  Work out what the energy loss per cm is at the start of the step.
       DEDXEM=SRMDEM(E)*SRMDEN
       DEDXHD=SRMDHD(E)*SRMDEN
       IF(E.LT.ESRIM(1))THEN
            PRANGE=SRMRNG(1)
            STRLON=SRMDL(1)
            STRLAT=SRMDT(1)
       ELSEIF(E.GT.ESRIM(NSRIM))THEN
            PRANGE=SRMRNG(NSRIM)
            STRLON=SRMDL(NSRIM)
            STRLAT=SRMDT(NSRIM)
       ELSE
            PRANGE=DIVDIF(SRMRNG,ESRIM,NSRIM,E,2)
            STRLON=DIVDIF(SRMDL,ESRIM,NSRIM,E,2)
            STRLAT=DIVDIF(SRMDT,ESRIM,NSRIM,E,2)
       ENDIF
       IF(.NOT.LDLSRM)STRLON=0
       IF(.NOT.LDTSRM)STRLAT=0
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   : E = '',
     -      E10.3,'' MeV, dEdx em, hd = '',2E10.3,'' MeV/cm, e-/cm = '',
     -      F10.3)') E,DEDXEM,DEDXHD,1E6*DEDXEM/WSRIM
**  Find the step size for which we get approximately the # clusters.
       IF(TRNSRM.GT.0)THEN
            STEP=(TRNSRM*WSRIM)/(1E6*DEDXEM)
       ELSEIF(TRNSRM.LT.-1.5)THEN
            STEP=TRLEN
       ELSE
            STEP=TRENER/(0.5*MXCLUS*(DEDXEM+DEDXHD))
       ENDIF
*   Truncate if this step exceeds the length.
       IF(DSUM+STEP.GT.TRLEN)THEN
            STEP=TRLEN-DSUM
            FINISH=.TRUE.
       ELSE
            FINISH=.FALSE.
       ENDIF
*   Make an accurate integration of the energy loss over the step.
       CALL SRMRKS(STEP,E,DEEM,DEHD)
**  If the energy loss exceeds the particle energy, truncate step.
       IF(DEEM+DEHD.GT.E)THEN
            CALL SRMDEZ(E,STEP,STPMAX,IFAIL1)
            STEP=STPMAX
            CALL SRMRKS(STEP,E,DEEM,DEHD)
            DEEM=E*DEEM/(DEHD+DEEM)
            DEHD=E-DEEM
            FINISH=.TRUE.
       ELSE
            STPMAX=TRLEN-DSUM
       ENDIF
**  Ensure that this is larger than the minimum modelable step size.
       CALL SRMMST(E,DEEM,STEP,ITFSRM,STPMIN,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! SRMGEN WARNING : Failure computing the'//
     -           ' minimum step size; clustering abandoned.'
            RETURN
       ENDIF
*   No way to find a suitable step size: use fixed energy loss
       IF(STPMIN.GT.STPMAX)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Step min > Step max; depositing all energy.'')')
            ELOSS=DEEM
            IF(ABS(E-DEHD-ELOSS).GT.1E-8*WSRIM)NTRERR(3)=NTRERR(3)+1
            IF(E-ELOSS-DEHD.LT.0)ELOSS=E-DEHD
            FINISH=.TRUE.
*   If needed enlarge the step size
       ELSEIF(STEP.LT.STPMIN)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Enlarging step size.'')')
            STEP=STPMIN
            CALL SRMRKS(STEP,E,DEEM,DEHD)
            IF(DEEM+DEHD.GT.E)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -                '' Excess energy loss; recomputing step_max.'')')
                 CALL SRMDEZ(E,STEP,STPMAX,IFAIL1)
                 STEP=STPMAX
                 CALL SRMRKS(STEP,E,DEEM,DEHD)
                 DEEM=E*DEEM/(DEHD+DEEM)
                 DEHD=E-DEEM
                 ELOSS=DEEM
            ELSE
                 ELOSS=RNDDE(E,DEEM,STEP,ITFSRM)
            ENDIF
*   Draw an actual energy loss for such a step.
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Using existing step size.'')')
            ELOSS=RNDDE(E,DEEM,STEP,ITFSRM)
       ENDIF
**  Ensure we are neither below 0 nor above the total energy.
       IF(ELOSS.LT.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Truncating negative energy loss.'')')
            ELOSS=0
            NTRERR(1)=NTRERR(1)+1
       ELSEIF(ELOSS.GT.E-DEHD)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Excess energy loss, using mean instead.'')')
            IF(ABS(E-DEHD-ELOSS).GT.1E-8*WSRIM)NTRERR(4)=NTRERR(4)+1
            ELOSS=DEEM
            IF(E-ELOSS-DEHD.LT.0)THEN
                 ELOSS=E-DEHD
                 FINISH=.TRUE.
            ENDIF
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   : Step'',
     -      '' length = '',E10.3,'' cm, mean loss = '',E10.3,
     -      '' MeV, actual loss = '',E10.3,'' MeV.'')')
     -       STEP,DEEM,ELOSS
**  Add a cluster.
40     CONTINUE
       IF(NCSRIM.GE.MXCLUS)THEN
            PRINT *,' !!!!!! SRMGEN WARNING : Maximum number of'//
     -           ' clusters reached; clustering abandoned.'
            RETURN
       ENDIF
       NCSRIM=NCSRIM+1
       XSRIM(NCSRIM)=X
       YSRIM(NCSRIM)=Y
       ZSRIM(NCSRIM)=Z
       IF(FSRIM.LE.0)THEN
            NESRIM(NCSRIM)=INT((ELOSS+EPOOL)/(1.0E-6*WSRIM))
            ECSRIM(NCSRIM)=1.0E-6*WSRIM*NESRIM(NCSRIM)
       ELSE
            ECL=ELOSS+EPOOL
            NESRIM(NCSRIM)=0.0
            ECSRIM(NCSRIM)=0.0
50          CONTINUE
            CALL RNDHWF(1.0E-6*WSRIM,FSRIM,ERND1)
            IF(ECL-ERND1.GE.0)THEN
                 NESRIM(NCSRIM)=NESRIM(NCSRIM)+1
                 ECSRIM(NCSRIM)=ECSRIM(NCSRIM)+ERND1
                 ECL=ECL-ERND1
                 GOTO 50
            ENDIF
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''EM + pool: '',E12.5,
     -           '' eV, w: '',E12.5,'' eV, E/w: '',E12.5,
     -           '', n: '',I10)')
     -           1.0E6*(ELOSS+EPOOL),WSRIM,(ELOSS+EPOOL)/(1.0E-6*WSRIM),
     -           NESRIM(NCSRIM)
       ENDIF
       EKSRIM(NCSRIM)=E
       EPOOL=(ELOSS+EPOOL) - ECSRIM(NCSRIM)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   : Cluster '',
     -      I5,'' at ('',E10.3,'','',E10.3,'','',E10.3,
     -      '') cm, e = '',E10.3,'' MeV, n = '',I10,
     -      '', pool = '',E10.3,'' MeV.'')')
     -      NCSRIM,XSRIM(NCSRIM),YSRIM(NCSRIM),ZSRIM(NCSRIM),
     -      ECSRIM(NCSRIM),NESRIM(NCSRIM),EPOOL
**  Keep track of the length and energy
       DSUM=DSUM+STEP
       E=E-ELOSS-DEHD
*   Stop of the flag is raised
       IF(FINISH)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Finishing flag raised.'')')
            GOTO 20
*   Stop if the distance has been reached
       ELSEIF(DSUM.GT.TRLEN)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Reached track length d = '',E10.3,'' cm.'')') TRLEN
            GOTO 20
*   Single cluster
       ELSEIF(TRNSRM.LT.-1.5)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Single cluster requested.'')')
            GOTO 20
*   No energy left
       ELSEIF(E.LE.TRENER*1E-9)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMGEN DEBUG   :'',
     -           '' Energy exhausted.'')')
            GOTO 20
       ENDIF
**  Draw scattering distances
       SIGT1=RNDNOR(0.0,SQRT(STEP/PRANGE)*STRLAT)
       SIGT2=RNDNOR(0.0,SQRT(STEP/PRANGE)*STRLAT)
       SIGL=RNDNOR(0.0,SQRT(STEP/PRANGE)*STRLON)
*   Rotation angles to bring z-axis in line 
       IF(XDIR**2+ZDIR**2.LE.0)THEN
            IF(YDIR.LT.0)THEN
                 THETA=-PI/2
            ELSEIF(YDIR.GT.0)THEN
                 THETA=+PI/2
            ELSE
                 PRINT *,' !!!!!! SRMGEN WARNING : Encountered'//
     -                ' zero step length; clustering abandoned.'
                 RETURN
            ENDIF
            PHI=0
       ELSE
            PHI=ATAN2(XDIR,ZDIR)
            THETA=ATAN2(YDIR,SQRT(XDIR**2+ZDIR**2))
       ENDIF
*   Update position
       CP=COS(PHI)
       CT=COS(THETA)
       SP=SIN(PHI)
       ST=SIN(THETA)
       X=X+STEP*XDIR+CP*SIGT1-SP*ST*SIGT2+SP*CT*SIGL
       Y=Y+STEP*YDIR+            CT*SIGT2   +ST*SIGL
       Z=Z+STEP*ZDIR-SP*SIGT1-CP*ST*SIGT2+CP*CT*SIGL
**  Update direction
       if(.false.)then
       XDIR=STEP*XDIR+CP*SIGT1-SP*ST*SIGT2+SP*CT*SIGL
       YDIR=STEP*YDIR+            CT*SIGT2   +ST*SIGL
       ZDIR=STEP*ZDIR-SP*SIGT1-CP*ST*SIGT2+CP*CT*SIGL
       DNORM=SQRT(XDIR**2+YDIR**2+ZDIR**2)
       IF(DNORM.LE.0)THEN
            PRINT *,' !!!!!! SRMGEN WARNING : Step length = 0;'//
     -           ' clustering abandoned.'
            RETURN
       ENDIF
       XDIR=XDIR/DNORM
       YDIR=YDIR/DNORM
       ZDIR=ZDIR/DNORM
       endif
       GOTO 10
*** End of loop.
20     CONTINUE
*   Print error messages
       CALL SRMERR
*   Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, SRMMST.
       SUBROUTINE SRMMST(EKIN,DE,STEP,MODEL,STPMIN,IFAIL)
*-----------------------------------------------------------------------
*   SRMMST - Determines the smallest step size for which there is little
*            or no risk of finding negative energy fluctuations.
*   VARIABLES : EKIN       : Kinetic energy [MeV]
*               DE         : Mean em energy loss over the step [MeV]
*               STEP       : Step length as guessed [cm]
*               STPMIN     : Minimum step length needed [cm]
*               BETA2      : Velocity-squared
*               GAMMA      : Projectile gamma
*               EMAX       : Maximum energy transfer per collision [MeV]
*               XI         : Rutherford term [MeV]
*               FCONST     : Proportionality constant
*               EMASS      : Electron mass [MeV]
*   (Last changed on 25/ 3/07.)
*-----------------------------------------------------------------------
       implicit none
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       REAL EKIN,DE,STEP,STPMIN,
     -      FCONST,EMASS,GAMMA,BETA2,EMAX,XLMIN,RKLIM,
     -      XI,XINEW,RKAPPA,RKNEW,STPNOW,DENOW,EXPMAX
       INTEGER MODEL,IFAIL,ITER
       LOGICAL RETRY
*** Fixed values.
       PARAMETER(FCONST=0.1534, EMASS=0.510999,EXPMAX=30)
*** By default, assume the step is right.
       STPMIN=STEP
*** Count interations
       ITER=0
*** By default, this works.
       IFAIL=0
*** Check correctness.
       IF(EKIN.LE.0.OR.DE.LE.0.OR.STEP.LE.0)THEN
            PRINT *,' !!!!!! SRMMST WARNING : Input parameters not'//
     -           ' valid: Ekin = ',EKIN,' MeV, dE = ',DE,
     -           ' MeV, step length = ',STEP,' cm.'
            IFAIL=1
            RETURN
       ELSEIF(TRMASS.LE.0.OR.ABS(TRCHAR).LE.0)THEN
            PRINT *,' !!!!!! SRMMST WARNING : Track parameters not'//
     -           ' valid: mass = ',TRMASS,' MeV, charge = ',TRCHAR
            IFAIL=1
            RETURN
       ELSEIF(A.LE.0.OR.Z.LE.0.OR.RHO.LE.0)THEN
            PRINT *,' !!!!!! SRMMST WARNING : Gas parameters not'//
     -           ' valid: A = ',A,', Z = ',Z,' density = ',RHO,' g/cm3.'
            IFAIL=1
            RETURN
       ENDIF
*** Basic kinematic parameters
       IF(EKIN.GT.1E-5*TRMASS)THEN
            BETA2 = 1-1/(1+EKIN/TRMASS)**2
       ELSE
            BETA2 = 2*EKIN/TRMASS
       ENDIF
       GAMMA = 1+EKIN/TRMASS
*** Compute maximum energy transfer
       EMAX = 2*EMASS*BETA2*GAMMA**2/
     -      (1+2*GAMMA*EMASS/TRMASS+(EMASS/TRMASS)**2)
*** Compute the Rutherford term 
       XI = FCONST * TRCHAR**2 * Z * RHO * STEP / (A*BETA2)
*** Compute the scaling parameter
       RKAPPA = XI/EMAX
*** Step size and energy loss
       DENOW=DE
       STPNOW=STEP
*** Debugging output.
10     CONTINUE
       RETRY = .FALSE.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMMST DEBUG   : Settings''/
     -      26X,''dE = '',E10.3,'' MeV, step = '',E10.3,'' cm,''/
     -      26X,''Ekin = '',E10.3,'' MeV, beta2 = '',E10.3,
     -          '', gamma = '',F10.3,'',''/
     -      26X,''Agas = '',F10.3,'', Zgas = '',F10.3,
     -          '', rho = '',E10.3,'' g/cm3,''/
     -      26X,''Qpart = '',F10.3,'', mpart = '',F10.3,'' MeV,''/
     -      26X,''Emax = '',E10.3,'' MeV, xi = '',E10.3,'' MeV'',
     -          '', kappa = '',E10.3,''.'')')
     -      DENOW,STPNOW,EKIN,BETA2,GAMMA,A,Z,RHO,TRCHAR,TRMASS,EMAX,
     -      XI,RKAPPA
*** No fluctuations: any step is permitted
       IF(MODEL.LE.0.OR.MODEL.GT.4)THEN
            STPMIN=STPNOW
*   Landau distribution
       ELSEIF(MODEL.EQ.1)THEN
            XLMIN = -3
            IF(-XLMIN-1.0+0.577215-BETA2-DENOW/XI.LT.-EXPMAX)THEN
                 RKLIM=0
            ELSE
                 RKLIM=EXP(-XLMIN-1.0+0.577215-BETA2-DENOW/XI)
            ENDIF
            STPMIN=STPNOW*(RKLIM/RKAPPA)
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Landau distribution'',
     -           '' is imposed.''/26X,''kappa_min = '',E12.5,
     -           '', d_min = '',E12.5,'' cm'')') RKLIM,STPMIN
*   Vavilov distribution, ensure we're in range.
       ELSEIF(MODEL.EQ.2)THEN
            IF(RKAPPA.LT.0.1)THEN
                 XLMIN = -2.7
            ELSEIF(RKAPPA.LT.1)THEN
                 XLMIN = -2.9
            ELSEIF(RKAPPA.LT.2)THEN
                 XLMIN = -3.0
            ELSEIF(RKAPPA.LT.3)THEN
                 XLMIN = -3.1
            ELSEIF(RKAPPA.LT.4)THEN
                 XLMIN = -3.2
            ELSEIF(RKAPPA.LT.5)THEN
                 XLMIN = -3.3
            ELSEIF(RKAPPA.LT.6)THEN
                 XLMIN = -3.4
            ELSEIF(RKAPPA.LT.7)THEN
                 XLMIN = -3.5
            ELSEIF(RKAPPA.LT.8)THEN
                 XLMIN = -3.6
            ELSE
                 XLMIN = -3.7
            ENDIF
            IF(-XLMIN-1.0+0.577215-BETA2-DENOW/XI.LT.-EXPMAX)THEN
                 RKLIM=0
            ELSE
                 RKLIM=EXP(-XLMIN-1.0+0.577215-BETA2-DENOW/XI)
            ENDIF
            STPMIN=STPNOW*(RKLIM/RKAPPA)
            XINEW=FCONST * TRCHAR**2 * Z * RHO * STPMIN / (A*BETA2)
            RKNEW=XINEW/EMAX
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Vavilov distribution'',
     -           '' is imposed.''/26X,''kappa_min = '',E12.5,
     -           '', d_min = '',E12.5,'' cm''/26X,''kappa_new = '',
     -           E12.5,'', xi_new = '',E12.5,'' MeV'')')
     -           RKLIM,STPMIN,RKNEW,XINEW
            IF(STPMIN.GT.STPNOW*1.1)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''New pass needed'',
     -                '' because of step size increase.'')')
                 RETRY=.TRUE.
            ENDIF
*   Gaussian model
       ELSEIF(MODEL.EQ.3)THEN
            STPMIN=STPNOW*16*XI*EMAX*(1-BETA2/2)/DENOW**2
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Gaussian distribution'',
     -           '' is imposed.''/26X,''d_min = '',E12.5,'' cm.''/26X,
     -           ''sigma/mu_old = '',E12.5,'', sigma/mu_min = '',
     -           E12.5)') STPMIN,SQRT(XI*EMAX*(1-BETA2/2))/DE,
     -           SQRT((FCONST * TRCHAR**2 *
     -           Z * RHO * STPMIN / (A*BETA2))*EMAX*(1-BETA2/2))/
     -           (STPMIN*DENOW/STPNOW)
*   Combined model: for low kappa, use the Landau distribution.
       ELSEIF(RKAPPA.LT.0.05)THEN
            XLMIN = -3
            IF(-XLMIN-1.0+0.577215-BETA2-DENOW/XI.LT.-EXPMAX)THEN
                 RKLIM=0
            ELSE
                 RKLIM=EXP(-XLMIN-1.0+0.577215-BETA2-DENOW/XI)
            ENDIF
            STPMIN=STPNOW*(RKLIM/RKAPPA)
            XINEW=FCONST * TRCHAR**2 * Z * RHO * STPMIN / (A*BETA2)
            RKNEW=XINEW/EMAX
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Landau distribution'',
     -           '' automatic.''/26X,''kappa_min = '',E12.5,
     -           '', d_min = '',E12.5,'' cm'')') RKLIM,STPMIN
            IF(RKNEW.GT.0.05.OR.STPMIN.GT.STPNOW*1.1)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''New pass needed'',
     -                '' because of model change or'',
     -                '' step size increase.'')')
                 RETRY=.TRUE.
            ENDIF
*   For medium kappa, use the Vavilov distribution
       ELSEIF(RKAPPA.LT.5)THEN
            IF(RKAPPA.LT.0.1)THEN
                 XLMIN = -2.7
            ELSEIF(RKAPPA.LT.1)THEN
                 XLMIN = -2.9
            ELSEIF(RKAPPA.LT.2)THEN
                 XLMIN = -3.0
            ELSEIF(RKAPPA.LT.3)THEN
                 XLMIN = -3.1
            ELSEIF(RKAPPA.LT.4)THEN
                 XLMIN = -3.2
            ELSEIF(RKAPPA.LT.5)THEN
                 XLMIN = -3.3
            ELSEIF(RKAPPA.LT.6)THEN
                 XLMIN = -3.4
            ELSEIF(RKAPPA.LT.7)THEN
                 XLMIN = -3.5
            ELSEIF(RKAPPA.LT.8)THEN
                 XLMIN = -3.6
            ELSE
                 XLMIN = -3.7
            ENDIF
            IF(-XLMIN-1.0+0.577215-BETA2-DENOW/XI.LT.-EXPMAX)THEN
                 RKLIM=0
            ELSE
                 RKLIM=EXP(-XLMIN-1.0+0.577215-BETA2-DENOW/XI)
            ENDIF
            STPMIN=STPNOW*(RKLIM/RKAPPA)
            XINEW=FCONST * TRCHAR**2 * Z * RHO * STPMIN / (A*BETA2)
            RKNEW=XINEW/EMAX
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Vavilov distribution'',
     -           '' automatic.''/26X,''kappa_min = '',E12.5,
     -           '', d_min = '',E12.5,'' cm''/26X,''kappa_new = '',
     -           E12.5,'', xi_new = '',E12.5,'' MeV'')')
     -           RKLIM,STPMIN,RKNEW,XINEW
            IF(RKNEW.GT.5.OR.STPMIN.GT.STPNOW*1.1)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''New pass needed'',
     -                '' because of model change or'',
     -                '' step size increase.'')')
                 RETRY=.TRUE.
            ENDIF
*   And for large kappa, use the Gaussian values.
       ELSE
            STPMIN=STPNOW*16*XI*EMAX*(1-BETA2/2)/DENOW**2
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Gaussian distribution'',
     -           '' automatic.''/26X,''d_min = '',E12.5,'' cm.''/26X,
     -           ''sigma/mu_old = '',E12.5,'', sigma/mu_min = '',
     -           E12.5)') STPMIN,SQRT(XI*EMAX*(1-BETA2/2))/DE,
     -           SQRT((FCONST * TRCHAR**2 *
     -           Z * RHO * STPMIN / (A*BETA2))*EMAX*(1-BETA2/2))/
     -           (STPMIN*DENOW/STPNOW)
       ENDIF
*** See whether we should do another pass
       IF(STPNOW.LT.STPMIN)THEN
            IF(RETRY.AND.ITER.LT.10)THEN
                 ITER=ITER+1
                 RKAPPA=RKNEW
                 XI=XINEW
                 DENOW=DENOW*STPMIN/STPNOW
                 STPNOW=STPMIN
                 GOTO 10
            ELSEIF(RETRY)THEN
                 PRINT *,' !!!!!! SRMMST WARNING : No convergence'//
     -                ' reached on step size.'
                 NTRERR(7)=NTRERR(7)+1
            ELSE
                 IF(LDEBUG)WRITE(LUNOUT,'(26X,''Step size must be'',
     -                '' increased to '',E12.5,'' cm'')') STPMIN
            ENDIF
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(26X,''Step size OK, minimum: '',
     -           E12.5,'' cm'')') STPMIN
       ENDIF
       END
CDECK  ID>, SRMDEZ.
       SUBROUTINE SRMDEZ(EKIN,STEP,STPMAX,IFAIL)
*-----------------------------------------------------------------------
*   SRMDEZ - Determines the distance over which the particle is likely
*            to lose all its energy.
*   VARIABLES : EKIN       : Kinetic energy [MeV]
*               STEP       : Step length as guessed [cm]
*               STPMAX     : Maximum step
*   (Last changed on 25/ 3/07.)
*-----------------------------------------------------------------------
       implicit none
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       REAL EKIN,STEP,STPMAX,DEEM,DEHD,ST1,DE1,ST2,DE2,ST3,DE3
       INTEGER IFAIL,ITER
*** Default result
       IFAIL=1
       STPMAX=STEP
*** Find the energy loss expected for the present step length.
       ST1=STEP
       CALL SRMRKS(ST1,EKIN,DEEM,DEHD)
       DE1=DEEM+DEHD
*   Do nothing if this is OK
       IF(DE1.LT.EKIN)THEN
            IFAIL=0
            RETURN
       ENDIF
*** Find a smaller step for which the energy loss is less than EKIN
       ST2=STEP/2
       ITER=0
10     CONTINUE
       ITER=ITER+1
*   See where we stand
       CALL SRMRKS(ST2,EKIN,DEEM,DEHD)
       DE2=DEEM+DEHD
*   Not yet below the kinetic energy: new iteration.
       IF(DE2.GT.EKIN)THEN
            ST1=ST2
            DE1=DE2
            ST2=ST2/2
            IF(ITER.LT.20)THEN
                 GOTO 10
            ELSE
                 PRINT *,' !!!!!! SRMDEZ WARNING : Did not find a'//
     -                ' smaller step in 20 iterations; abandoned.'
                 NTRERR(6)=NTRERR(6)+1
                 STPMAX=0.5*(ST1+ST2)
                 IFAIL=1
                 RETURN
            ENDIF
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMDEZ DEBUG   : '',
     -      ''Step 1 = '',E12.5,'' cm, dE 1 = '',E12.5,'' MeV''/26X
     -      ''Step 2 = '',E12.5,'' cm, dE 2 = '',E12.5,'' MeV'')')
     -      ST1,DE1-EKIN,ST2,DE2-EKIN
*** Now perform a bisection
       ITER=0
20     CONTINUE
       ITER=ITER+1
*   Avoid division by zero.
       IF(DE2.EQ.DE1)THEN
            PRINT *,' !!!!!! SRMDEZ WARNING : Bisection failed due to'//
     -           ' equal energy loss for 2 step sizes; abandoned.'
            NTRERR(6)=NTRERR(6)+1
            STPMAX=0.5*(ST1+ST2)
            IFAIL=1
            RETURN
       ENDIF
*   Estimate step to give total energy loss.
       IF(ABS(DE1-EKIN).LT.0.01*ABS(DE2-DE1).OR.
     -      ABS(DE1-EKIN).GT.0.99*ABS(DE2-DE1))THEN
            ST3=0.5*(ST1+ST2)
       ELSE
            ST3=ST1-(ST2-ST1)*(DE1-EKIN)/(DE2-DE1)
       ENDIF
*   See how well we are doing.
       CALL SRMRKS(ST3,EKIN,DEEM,DEHD)
       DE3=DEEM+DEHD
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMDEZ DEBUG   : '',
     -      ''Step 1 = '',E12.5,'' cm, dE 1 = '',E12.5,'' MeV''/26X
     -      ''Step 2 = '',E12.5,'' cm, dE 2 = '',E12.5,'' MeV''/26X
     -      ''Step 3 = '',E12.5,'' cm, dE 3 = '',E12.5,'' MeV'')')
     -      ST1,DE1-EKIN,ST2,DE2-EKIN,ST3,DE3-EKIN
*   Update the estimates above and below.
       IF(DE3.GT.EKIN)THEN
            ST1=ST3
            DE1=DE3
       ELSE
            ST2=ST3
            DE2=DE3
       ENDIF
*   See whether we've converged.
       IF(ABS(DE3-EKIN).LT.1E-3*(ABS(DE3)+ABS(EKIN)).OR.
     -      ABS(ST1-ST2).LT.1E-3*(ABS(ST1)+ABS(ST2)))THEN
            STPMAX=ST1-(ST2-ST1)*(DE1-EKIN)/(DE2-DE1)
            IFAIL=0
            RETURN
       ELSEIF(ITER.LT.20)THEN
            GOTO 20
       ELSE
            PRINT *,' !!!!!! SRMDEZ WARNING : Bisection did not'//
     -           ' converge in 20 steps; abandoned.'
            STPMAX=ST1-(ST2-ST1)*(DE1-EKIN)/(DE2-DE1)
            NTRERR(6)=NTRERR(6)+1
            IFAIL=1
            RETURN
       ENDIF
       END
CDECK  ID>, SRMRKS.
       SUBROUTINE SRMRKS(STEP,ESTART,DEEM,DEHD)
*-----------------------------------------------------------------------
*   SRMRKS - Precise energy loss integration over a step.
*   (Last changed on 26/10/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       REAL STEP,ESTART,DEEM,DEHD,S,EPS,
     -      EM21,HD21,EM22,HD22,E2,
     -      EM41,HD41,EM42,HD42,EM43,HD43,EM44,HD44,E4,
     -      DIVDIF,SRMDEM,SRMDHD
       INTEGER I,ITER,NDIV
       EXTERNAL DIVDIF,SRMDEM,SRMDHD
*** Identification.
       IF(LIDENT)PRINT *,' /// ROUTINE SRMRKS ///'
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMRKS DEBUG   :'',
     -      '' Estart = '',E12.5,'' MeV '',
     -      '', step length = '',E12.5,'' cm.'')') ESTART,STEP
*** Precision
       EPS=1.0E-2
*** Initial settings and return point
       NDIV=1
       ITER=0
10     CONTINUE
       ITER=ITER+1
       E4=ESTART
       E2=ESTART
       DEEM=0
       DEHD=0
*** Compute RK2 and RK4 over the number of sub-divisions
       S=STEP/REAL(NDIV)
       DO 20 I=1,NDIV
**  RK2: Initial point
       EM21=S*SRMDEM(E2)*SRMDEN
       HD21=S*SRMDHD(E2)*SRMDEN
*   Mid-way point
       EM22=S*SRMDEM(E2-(EM21+HD21)/2)*SRMDEN
       HD22=S*SRMDHD(E2-(EM21+HD21)/2)*SRMDEN
**  RK4: Initial point
       EM41=S*SRMDEM(E4)*SRMDEN
       HD41=S*SRMDHD(E4)*SRMDEN
*   Mid-way point
       EM42=S*SRMDEM(E4-(EM41+HD41)/2)*SRMDEN
       HD42=S*SRMDHD(E4-(EM41+HD41)/2)*SRMDEN
*   Second mid-point estimate
       EM43=S*SRMDEM(E4-(EM42+HD42)/2)*SRMDEN
       HD43=S*SRMDHD(E4-(EM42+HD42)/2)*SRMDEN
*   End point estimate
       EM44=S*SRMDEM(E4-(EM43+HD43))*SRMDEN
       HD44=S*SRMDHD(E4-(EM43+HD43))*SRMDEN
*   Store the energy loss terms (according to RK4)
       DEEM=DEEM+EM41/6.0+EM42/3.0+EM43/3.0+EM44/6.0
       DEHD=DEHD+HD41/6.0+HD42/3.0+HD43/3.0+HD44/6.0
*   Trace the RK2 energy
       E2=E2-(EM22+HD22)
*   Store the new energy computed with RK4
       E4=E4-((EM41+HD41)/6.0+(EM42+HD42)/3.0+
     -        (EM43+HD43)/3.0+(EM44+HD44)/6.0)
20     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMRKS DEBUG   :'',
     -      '' Iteration '',I3,'' with '',I3,'' divisions, losses: ''/
     -      26X,''dE4 = '',E12.5,'', dE2 = '',E12.5,'' MeV''/
     -      26X,''EM4 = '',E12.5,'', HD4 = '',E12.5,'' MeV'')')
     -      ITER,NDIV,ESTART-E2,ESTART-E4,DEEM,DEHD
*   Compare the two estimates
       IF(ABS(E2-E4).GT.EPS*(ABS(E2)+ABS(E4)+ABS(ESTART)))THEN
            IF(ITER.GT.10)THEN
                 PRINT *,' !!!!!! SRMRKS WARNING : No convergence'//
     -                ' achieved integrating energy loss.'
                 NTRERR(5)=NTRERR(5)+1
            ELSE
                 NDIV=NDIV*2
                 GOTO 10
            ENDIF
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SRMRKS DEBUG   :'',
     -           '' Convergence achieved at eps = '',E10.3)') EPS
       ENDIF
       END
CDECK  ID>, SRMDEM.
       REAL FUNCTION SRMDEM(E)
*-----------------------------------------------------------------------
*   SRMDEM - Returns the em differential energy loss at energy E
*   (Last changed on 10/ 3/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
        REAL E,DIVDIF
        EXTERNAL DIVDIF
*** Below the first table point.
        IF(E.LT.ESRIM(1))THEN
             SRMDEM=SRMEM(1)
*   Above the last.
        ELSEIF(E.GT.ESRIM(NSRIM))THEN
             SRMDEM=SRMEM(NSRIM)
*   Inside the table.
        ELSE
             SRMDEM=DIVDIF(SRMEM,ESRIM,NSRIM,E,2)
        ENDIF
        END
CDECK  ID>, SRMDHD.
       REAL FUNCTION SRMDHD(E)
*-----------------------------------------------------------------------
*   SRMDHD - Returns the hd differential energy loss at energy E
*   (Last changed on 10/ 3/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
        REAL E,DIVDIF
        EXTERNAL DIVDIF
*** Below the first table point.
        IF(E.LT.ESRIM(1))THEN
             SRMDHD=SRMHD(1)
*   Above the last.
        ELSEIF(E.GT.ESRIM(NSRIM))THEN
             SRMDHD=SRMHD(NSRIM)
*   Inside the table.
        ELSE
             SRMDHD=DIVDIF(SRMHD,ESRIM,NSRIM,E,2)
        ENDIF
        END
CDECK  ID>, SRMERR.
       SUBROUTINE SRMERR
*-----------------------------------------------------------------------
*   SRMERR - Prints error messages from SRIM clustering
*   (Last changed on 27/ 3/07.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       INTEGER I,NTOT
*** Count errors.
       NTOT=0
       DO 10 I=1,10
*   Count 4 is just a warning.
       IF(I.EQ.4)GOTO 10
*   Count the rest
       NTOT=NTOT+NTRERR(I)
10     CONTINUE
*** Header.
       IF(NTOT.GT.0)THEN
            WRITE(LUNOUT,'(''  !!!!!! SRMERR WARNING : Total errors'',
     -           '' during clustering:        '',I10)') NTOT
       ELSE
            RETURN
       ENDIF
*** Consider all error messages and warnings.
       IF(NTRERR(1).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Negative energy loss generated:        '',I10)') NTRERR(1)
       IF(NTRERR(2).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Vavilov (kappa,beta2) out of range:    '',I10)') NTRERR(2)
       IF(NTRERR(3).GT.0)WRITE(LUNOUT,'(26X,
     -      ''No suitable generator found:           '',I10)') NTRERR(3)
       IF(NTRERR(4).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Excess energy generated:               '',I10)') NTRERR(4)
       IF(NTRERR(5).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Energy loss integration not converged: '',I10)') NTRERR(5)
       IF(NTRERR(6).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Range estimate did not converge:       '',I10)') NTRERR(6)
       IF(NTRERR(7).GT.0)WRITE(LUNOUT,'(26X,
     -      ''Minimum step size search failed:       '',I10)') NTRERR(7)
       END
CDECK  ID>, GASSWR.
       SUBROUTINE GASSWR(IFAIL)
*-----------------------------------------------------------------------
*   GASSWR - Writes SRIM clustering data
*   (Last changed on 19/ 9/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER IFAIL,IOS,I
*** Assume for the moment that writing will work.
       IFAIL=0
*** Show whether iniialisation has been performed.
       WRITE(12,'(''  SRIM initialisation done: '',L1)',ERR=2010,
     -      IOSTAT=IOS) SRIMOK
*** Write the table if present
       IF(SRIMOK)THEN
            WRITE(12,'(''  Table lines:           '',I15/
     -                 ''  Density [g/cm3]:       '',E15.8/
     -                 ''  Work function [eV]:    '',E15.8/
     -                 ''  Fano factor:           '',E15.8/
     -                 ''  Particle name:         '',I5,A/
     -                 ''  Particle mass [MeV]    '',E15.8/
     -                 ''  Particle charge [p]    '',E15.8/
     -                 ''  Long. straggling [y/n] '',L1/
     -                 ''  Trans straggling [y/n] '',L1/
     -                 ''  Precise Vavilov  [y/n] '',L1/
     -                 ''  Target cluster size    '',E15.8)',
     -            ERR=2010,IOSTAT=IOS) NSRIM,SRMDEN,WSRIM,FSRIM,
     -            NCPNAM,PNAME,TRMASS,TRCHAR,LDLSRM,LDTSRM,LTRVVL,TRNSRM
            DO 10 I=1,NSRIM
            WRITE(12,'(6E15.8)',ERR=2010,IOSTAT=IOS) 
     -          ESRIM(I),SRMEM(I),SRMHD(I),SRMRNG(I),SRMDT(I),SRMDL(I)
10          CONTINUE
       ENDIF
       RETURN
*** Errors during I/O.
2010   CONTINUE
       PRINT *,' !!!!!! GASSWR WARNING : I/O error occurred while'//
     -      ' writing SRIM initialisation data.'
       CALL INPIOS(IOS)
       IFAIL=1
       END
CDECK  ID>, GASSGT.
       SUBROUTINE GASSGT(IFAIL)
*-----------------------------------------------------------------------
*   GASSGT - Retrieves SRIM clustering data
*   (Last changed on 19/ 9/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER IFAIL,IOS,I
*** Assume for the moment that reading will work.
       IFAIL=0
*** See whether initialisation should be performed.
       READ(12,'(28X,L1)',ERR=2010,IOSTAT=IOS) SRIMOK
*** Read data if present
       IF(SRIMOK)THEN
            READ(12,'(25X,I15/25X,E15.8/25X,E15.8/25X,E15.8/
     -           25X,I5,A/25X,E15.8/25X,E15.8/25X,L1/25X,L1/25X,L1/
     -           25X,E15.8)',ERR=2010,IOSTAT=IOS)
     -           NSRIM,SRMDEN,WSRIM,FSRIM,
     -           NCPNAM,PNAME,TRMASS,TRCHAR,LDLSRM,LDTSRM,LTRVVL,TRNSRM
            DO 10 I=1,NSRIM
            READ(12,'(6E15.8)',ERR=2010,IOSTAT=IOS) 
     -           ESRIM(I),SRMEM(I),SRMHD(I),SRMRNG(I),SRMDT(I),SRMDL(I)
10          CONTINUE
       ENDIF
       RETURN
*   Errors during I/O.
2010   CONTINUE
       PRINT *,' !!!!!! GASSGT WARNING : I/O error occurred while'//
     -      ' retrieving SRIM initialisation data.'
       CALL INPIOS(IOS)
       IFAIL=1
       END
CDECK  ID>, GASSG8.
       SUBROUTINE GASSG8(IFAIL)
*-----------------------------------------------------------------------
*   GASSG8 - Retrieves SRIM clustering data
*   (Last changed on 27/ 6/07. Renamed on 18/ 9/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       REAL SRMDEN,ESRIM,SRMEM,SRMHD,SRMRNG,SRMDT,SRMDL,WSRIM,FSRIM,
     -      XSRIM,YSRIM,ZSRIM,ECSRIM,EKSRIM
       INTEGER NSRIM,NCSRIM,NESRIM
       COMMON /SRMDAT/ 
     -      ESRIM(MXLIST),SRMEM(MXLIST),
     -      SRMHD(MXLIST),SRMRNG(MXLIST),SRMDT(MXLIST),SRMDL(MXLIST),
     -      XSRIM(MXCLUS),YSRIM(MXCLUS),ZSRIM(MXCLUS),ECSRIM(MXCLUS),
     -      EKSRIM(MXCLUS),SRMDEN,WSRIM,FSRIM,
     -      NSRIM,NCSRIM,NESRIM(MXCLUS)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       INTEGER IFAIL,IOS,I
*** Assume for the moment that reading will work.
       IFAIL=0
*** See whether initialisation should be performed.
       READ(12,'(28X,L1)',ERR=2010,IOSTAT=IOS) SRIMOK
*** Read data if present
       IF(SRIMOK)THEN
            READ(12,'(25X,I15/25X,E15.8/25X,E15.8/25X,E15.8)',
     -           ERR=2010,IOSTAT=IOS) NSRIM,SRMDEN,WSRIM,FSRIM
            DO 10 I=1,NSRIM
            READ(12,'(6E15.8)',ERR=2010,IOSTAT=IOS) 
     -           ESRIM(I),SRMEM(I),SRMHD(I),SRMRNG(I),SRMDT(I),SRMDL(I)
10          CONTINUE
       ENDIF
       RETURN
*   Errors during I/O.
2010   CONTINUE
       PRINT *,' !!!!!! GASSG0 WARNING : I/O error occurred while'//
     -      ' retrieving SRIM initialisation data.'
       CALL INPIOS(IOS)
       IFAIL=1
       END
CDECK  ID>, EFIELD.
       SUBROUTINE EFIELD(XIN,YIN,ZIN,EX,EY,EZ,ETOT,VOLT,IOPT,ILOC)
*-----------------------------------------------------------------------
*   EFIELD - Subroutine calculating the electric field and the potential
*            at a given place. It makes use of the routines POT...,
*            depending on the type of the cell.
*   VARIABLES : XPOS       : x-coordinate of the place where the field
*                            is to be calculated.
*               YPOS, ZPOS : y- and z-coordinates
*               EX, EY, EZ : x-, y-, z-component of the electric field.
*               VOLT       : potential at (XPOS,YPOS).
*               IOPT       : 1 if both E and V are required, 0 if only E
*                            is to be computed.
*               ILOC       : Tells where the point is located (0: normal
*                            I > 0: in wire I, -1: outside a plane,
*                            -5: in a material, -6: outside the mesh, 
*                            -10: unknown potential).
*   (Last changed on 19/ 3/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       REAL XIN,YIN,ZIN,EX,EY,EZ,ETOT,VOLT,XPOS,YPOS,ZPOS,DXWIR,DYWIR,
     -      AROT,EX3D,EY3D,EZ3D,V3D,EXBGF,EYBGF,EZBGF,VBGF,XAUX,YAUX,
     -      EXD,EYD,VOLTD
       INTEGER IOUT,ILOC,IOPT,I
*** Initialise the field for returns without actual calculations.
       EX=0.0
       EY=0.0
       EZ=0.0
       ETOT=0.0
       VOLT=0.0
       ILOC=0
*** For boundary element methods, just transfer.
       IF(ICTYPE.EQ.-1)THEN
            XPOS=XIN
            YPOS=YIN
            ZPOS=ZIN
*** For finite element programs, just transfer.
       ELSEIF(ICTYPE.EQ.0)THEN
            XPOS=XIN
            YPOS=YIN
            ZPOS=ZIN
*** In case of periodicity, move the point into the basic cell.
       ELSE
            IF(PERX)THEN
                 XPOS=XIN-SX*ANINT(XIN/SX)
            ELSE
                 XPOS=XIN
            ENDIF
            IF(PERY.AND.TUBE)THEN
                 CALL CFMCTP(XIN,YIN,XPOS,YPOS,1)
                 AROT=180*SY*ANINT((PI*YPOS)/(SY*180.0))/PI
                 YPOS=YPOS-AROT
                 CALL CFMPTC(XPOS,YPOS,XPOS,YPOS,1)
            ELSEIF(PERY)THEN
                 YPOS=YIN-SY*ANINT(YIN/SY)
            ELSE
                 YPOS=YIN
            ENDIF
*   Move the point to the correct side of the plane.
            IF(PERX.AND.YNPLAN(1).AND.XPOS.LE.COPLAN(1))XPOS=XPOS+SX
            IF(PERX.AND.YNPLAN(2).AND.XPOS.GE.COPLAN(2))XPOS=XPOS-SX
            IF(PERY.AND.YNPLAN(3).AND.YPOS.LE.COPLAN(3))YPOS=YPOS+SY
            IF(PERY.AND.YNPLAN(4).AND.YPOS.GE.COPLAN(4))YPOS=YPOS-SY
*   In case (XPOS,YPOS) is located behind a plane there is no field.
            IOUT=0
            IF(TUBE)THEN
                 CALL INTUBE(XPOS,YPOS,COTUBE,NTUBE,IOUT)
                 IF(IOUT.NE.0)VOLT=VTTUBE
            ELSE
                 IF(YNPLAN(1).AND.XPOS.LT.COPLAN(1))IOUT=1
                 IF(YNPLAN(2).AND.XPOS.GT.COPLAN(2))IOUT=2
                 IF(YNPLAN(3).AND.YPOS.LT.COPLAN(3))IOUT=3
                 IF(YNPLAN(4).AND.YPOS.GT.COPLAN(4))IOUT=4
                 IF(IOUT.EQ.1)VOLT=VTPLAN(1)
                 IF(IOUT.EQ.2)VOLT=VTPLAN(2)
                 IF(IOUT.EQ.3)VOLT=VTPLAN(3)
                 IF(IOUT.EQ.4)VOLT=VTPLAN(4)
            ENDIF
            IF(IOUT.NE.0)THEN
                 ILOC=-4
                 RETURN
            ENDIF
**  If (XPOS,YPOS) is within a wire, there is no field either.
            DO 10 I=1,NWIRE
*   Correct for x-periodicity.
            IF(PERX)THEN
                 DXWIR=(XPOS-X(I))-SX*ANINT((XPOS-X(I))/SX)
            ELSE
                 DXWIR=XPOS-X(I)
            ENDIF
*   Correct for y-periodicity.
            IF(PERY.AND..NOT.TUBE)THEN
                 DYWIR=(YPOS-Y(I))-SY*ANINT((YPOS-Y(I))/SY)
            ELSE
                 DYWIR=YPOS-Y(I)
            ENDIF
*   Check the actual position.
            IF(DXWIR**2+DYWIR**2.LT.0.25*D(I)**2)THEN
                 VOLT=V(I)
                 ILOC=I
                 RETURN
            ENDIF
*   Next wire.
10          CONTINUE
       ENDIF
*** Call the appropriate potential calculation function.
       IF(ICTYPE.EQ.-1)THEN
            CALL EFCBEM(XPOS,YPOS,ZPOS,EX,EY,EZ,VOLT,IOPT,ILOC)
       ELSEIF(ICTYPE.EQ.0)THEN
            CALL EFCFMP(XPOS,YPOS,ZPOS,EX,EY,EZ,VOLT,IOPT,ILOC)
            IF(ILOC.NE.0.AND.ILOC.NE.-5)RETURN
       ELSEIF(ICTYPE.EQ.1.AND.NXMATT.EQ.0.AND.NYMATT.EQ.0)THEN
            CALL EFCA00(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.1)THEN
            CALL EFDA00(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.2)THEN
            CALL EFCB1X(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.3)THEN
            CALL EFCB1Y(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.4)THEN
            CALL EFCB2X(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.5)THEN
            CALL EFCB2Y(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.6)THEN
            CALL EFCC10(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.7)THEN
            CALL EFCC2X(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.8)THEN
            CALL EFCC2Y(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.9)THEN
            CALL EFCC30(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.10)THEN
            CALL EFCD10(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.11)THEN
            CALL EFCD20(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSEIF(ICTYPE.EQ.12)THEN
            CALL EFCD30(XPOS,YPOS,EX,EY,VOLT,IOPT)
C       ELSEIF(ICTYPE.EQ.13)THEN
C           CALL EFCD40(XPOS,YPOS,EX,EY,VOLT,IOPT)
       ELSE
            ILOC=-10
            RETURN
       ENDIF
*** Add dipole terms if requested
       IF(LDIPOL)THEN
            IF(ICTYPE.EQ.1)THEN
                 CALL EMCA00(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSEIF(ICTYPE.EQ.2)THEN
                 CALL EMCB1X(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSEIF(ICTYPE.EQ.3)THEN
                 CALL EMCB1Y(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSEIF(ICTYPE.EQ.4)THEN
                 CALL EMCB2X(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSEIF(ICTYPE.EQ.5)THEN
                 CALL EMCB2Y(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSEIF(ICTYPE.EQ.6)THEN
                 CALL EMCC10(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ELSE
                 EXD=0
                 EYD=0
                 VOLTD=0
                 CALL EMCA00(XPOS,YPOS,EXD,EYD,VOLTD,IOPT)
            ENDIF
            EX=EX+EXD
            EY=EY+EYD
            VOLT=VOLT+VOLTD
       ENDIF
*** Rotate the field in some special cases.
       IF(ICTYPE.GT.0)THEN
            IF(PERY.AND.TUBE)THEN
                 CALL CFMCTP(EX,EY,XAUX,YAUX,1)
                 YAUX=YAUX+AROT
                 CALL CFMPTC(XAUX,YAUX,EX,EY,1)
            ENDIF
*** Correct for the equipotential planes.
            EX=EX-CORVTA
            EY=EY-CORVTB
            VOLT=VOLT+CORVTA*XPOS+CORVTB*YPOS+CORVTC
       ENDIF
*** Add three dimensional point charges.
       IF(N3D.GT.0)THEN
            IF(ICTYPE.EQ.1.OR.ICTYPE.EQ.2.OR.ICTYPE.EQ.3)THEN
                 CALL E3DA00(XIN,YIN,ZIN,EX3D,EY3D,EZ3D,V3D)
            ELSEIF(ICTYPE.EQ.4)THEN
                 CALL E3DB2X(XIN,YIN,ZIN,EX3D,EY3D,EZ3D,V3D)
            ELSEIF(ICTYPE.EQ.5)THEN
                 CALL E3DB2Y(XIN,YIN,ZIN,EX3D,EY3D,EZ3D,V3D)
            ELSEIF(ICTYPE.EQ.10)THEN
                 CALL E3DD10(XIN,YIN,ZIN,EX3D,EY3D,EZ3D,V3D)
            ELSE
                 EX3D=0.0
                 EY3D=0.0
                 EZ3D=0.0
                 V3D=0.0
                 CALL E3DA00(XIN,YIN,ZIN,EX3D,EY3D,EZ3D,V3D)
            ENDIF
            EX=EX+EX3D
            EY=EY+EY3D
            EZ=EZ+EZ3D
            VOLT=VOLT+V3D
       ENDIF
*** Add a background field if present.
       IF(IENBGF.GT.0)THEN
            CALL EFCBGF(XIN,YIN,ZIN,EXBGF,EYBGF,EZBGF,VBGF)
            EX=EX+EXBGF
            EY=EY+EYBGF
            EZ=EZ+EZBGF
            VOLT=VOLT+VBGF
       ENDIF
*** Finally calculate the value of ETOT (magnitude of the E-field).
       ETOT=SQRT(EX**2+EY**2+EZ**2)
       END
CDECK  ID>, EMCC10.
       SUBROUTINE EMCC10(XPOS,YPOS,EX,EY,VOLT,IOPT)
*-----------------------------------------------------------------------
*   EMCC10 - Dipole terms for doubly periodic potentials.
*   (Last changed on  3/ 4/2013.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       REAL XPOS,YPOS,EX,EY,VOLT,DX,DY,EXHELP,EYHELP,VHELP,VDIP
       INTEGER IOPT,I
       COMPLEX ZETA,ZSIN,ZCOF,ZU,ZUNEW,ZTERM1,ZTERM2,WSUM
*** Calculate theta1'/theta1
       VDIP = 0
       DO 10 I=1,NWIRE
       ZETA=ZMULT*CMPLX(XPOS-X(I),YPOS-Y(I))
       IF(ABS(AIMAG(ZETA)).LT.+15.0)THEN
            ZSIN=SIN(ZETA)
            ZCOF=4.0*ZSIN**2-2.0
            ZU=-P1-ZCOF*P2
            ZUNEW=1.0-ZCOF*ZU-P2
            ZTERM1=(ZUNEW+ZU)*ZSIN
            ZU=-3.0*P1-ZCOF*5.0*P2
            ZUNEW=1.0-ZCOF*ZU-5.0*P2
            ZTERM2=(ZUNEW-ZU)*COS(ZETA)
            IF(MODE.EQ.1)THEN
                 VDIP = VDIP - 2*AMP2(I)*
     -                REAL(CMPLX(COSPH2(I),SINPH2(I))*
     -                     CMPLX(PI/SX,0)*ZTERM2/ZTERM1) -
     -                AMP2(I)*SINPH2(I)*Y(I)*8*PI/(SX*SY)
                 print *,' i = ',i,' theta = ',- 4*AMP2(I)*
     -                REAL(CMPLX(COSPH2(I),SINPH2(I))*
     -                     CMPLX(PI/SX,0)*ZTERM2/ZTERM1),
     -                -AMP2(I)*SINPH2(I)*Y(I)*8*PI/(SX*SY)
            ELSE
                 VDIP = VDIP - 4*AMP2(I)*
     -                REAL(CMPLX(COSPH2(I),SINPH2(I))*
     -                     CMPLX(0,PI/SY)*ZTERM2/ZTERM1)
                 VDIP = VDIP - AMP2(I)*COSPH2(I)*X(I)*8*PI/(SX*SY)
            ENDIF
C            print *,' Wire ',i,' amp = ',amp2(i), 'angles = ',
C     -           cosph2(i),sinph2(i),' zeta = ',zeta,' mode = ',mode
       ENDIF
 10    CONTINUE
*** Compare with A potential.
       CALL EMCA00(XPOS,YPOS,EX,EY,VOLT,IOPT)
       print *,' Vdip C = ',VDIP,' A = ',VOLT, VDIP/VOLT
       END
CDECK  ID>, EFCFMP.
       SUBROUTINE EFCFMP(XIN,YIN,ZIN,EX,EY,EZ,VOLT,IOPT,ILOC)
*-----------------------------------------------------------------------
*   EFCFMP - Interpolates the field map at (XPOS,YPOS,ZPOS).
*   (Last changed on  9/ 1/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       REAL XIN,YIN,ZIN,XPOS,YPOS,ZPOS,EX,EY,EZ,VOLT,XNEW,YNEW,ZNEW,
     -      T1,T2,T3,T4,AUXPHI,AUXR,AROT,XAUX,YAUX,ER,EAXIS,RCOOR,ZCOOR,
     -      DN1DUH,DN2DUH,DN3DUH,DN4DUH,DN5DUH,DN6DUH,DN7DUH,DN8DUH,
     -      DN1DVH,DN2DVH,DN3DVH,DN4DVH,DN5DVH,DN6DVH,DN7DVH,DN8DVH,
     -      DN1DWH,DN2DWH,DN3DWH,DN4DWH,DN5DWH,DN6DWH,DN7DWH,DN8DWH,
     -      DN1DUP,DN2DUP,DN3DUP,DN4DUP,DN5DUP,DN6DUP,
     -      DN1DVP,DN2DVP,DN3DVP,DN4DVP,DN5DVP,DN6DVP,
     -      DN1DWP,DN2DWP,DN3DWP,DN4DWP,DN5DWP,DN6DWP,
     -      DT1DX,DT2DX,DT3DX,DT4DX,
     -      DT1DY,DT2DY,DT3DY,DT4DY,
     -      DT1DZ,DT2DZ,DT3DZ,DT4DZ
       DOUBLE PRECISION JAC(4,4),DET
       INTEGER IOPT,ILOC,IMAP,NX,NY,NZ
       LOGICAL MIRRX,MIRRY,MIRRZ
*** Derivatives of the shape functions for hexahedrals.
       DN1DUH(T1,T2,T3)=-(1 - T2)*(1 - T3)/8
       DN2DUH(T1,T2,T3)= (1 - T2)*(1 - T3)/8
       DN3DUH(T1,T2,T3)= (1 + T2)*(1 - T3)/8
       DN4DUH(T1,T2,T3)=-(1 + T2)*(1 - T3)/8
       DN5DUH(T1,T2,T3)=-(1 - T2)*(1 + T3)/8
       DN6DUH(T1,T2,T3)= (1 - T2)*(1 + T3)/8
       DN7DUH(T1,T2,T3)= (1 + T2)*(1 + T3)/8
       DN8DUH(T1,T2,T3)=-(1 + T2)*(1 + T3)/8
       DN1DVH(T1,T2,T3)=-(1 - T1)*(1 - T3)/8
       DN2DVH(T1,T2,T3)=-(1 + T1)*(1 - T3)/8
       DN3DVH(T1,T2,T3)= (1 + T1)*(1 - T3)/8
       DN4DVH(T1,T2,T3)= (1 - T1)*(1 - T3)/8
       DN5DVH(T1,T2,T3)=-(1 - T1)*(1 + T3)/8
       DN6DVH(T1,T2,T3)=-(1 + T1)*(1 + T3)/8
       DN7DVH(T1,T2,T3)= (1 + T1)*(1 + T3)/8
       DN8DVH(T1,T2,T3)= (1 - T1)*(1 + T3)/8
       DN1DWH(T1,T2,T3)=-(1 - T1)*(1 - T2)/8
       DN2DWH(T1,T2,T3)=-(1 + T1)*(1 - T2)/8
       DN3DWH(T1,T2,T3)=-(1 + T1)*(1 + T2)/8
       DN4DWH(T1,T2,T3)=-(1 - T1)*(1 + T2)/8
       DN5DWH(T1,T2,T3)= (1 - T1)*(1 - T2)/8
       DN6DWH(T1,T2,T3)= (1 + T1)*(1 - T2)/8
       DN7DWH(T1,T2,T3)= (1 + T1)*(1 + T2)/8
       DN8DWH(T1,T2,T3)= (1 - T1)*(1 + T2)/8
*** Derivatives of the shape functions for pentahedrals.
       DN1DUP(T1,T2,T3)=(-1+T3)/2
       DN2DUP(T1,T2,T3)=( 1-T3)/2
       DN3DUP(T1,T2,T3)=0
       DN4DUP(T1,T2,T3)=(-1-T3)/2
       DN5DUP(T1,T2,T3)=( 1+T3)/2
       DN6DUP(T1,T2,T3)=0
       DN1DVP(T1,T2,T3)=(-1+T3)/2
       DN2DVP(T1,T2,T3)=0
       DN3DVP(T1,T2,T3)=( 1-T3)/2
       DN4DVP(T1,T2,T3)=(-1-T3)/2
       DN5DVP(T1,T2,T3)=0
       DN6DVP(T1,T2,T3)=( 1+T3)/2
       DN1DWP(T1,T2,T3)=(-1+T1+T2)/2
       DN2DWP(T1,T2,T3)=-T1/2
       DN3DWP(T1,T2,T3)=-T2/2
       DN4DWP(T1,T2,T3)=( 1-T1-T2)/2
       DN5DWP(T1,T2,T3)= T1/2
       DN6DWP(T1,T2,T3)= T2/2
*** Debugging output
C      print *,' EFCFMP called for ',XIN,YIN,ZIN,
C     -     ' maptyp = ',maptyp,' mapord = ',mapord
*** Initial values.
       EX=0
       EY=0
       EZ=0
       VOLT=0
       ILOC=0
       XPOS=XIN-XFMOFF
       YPOS=YIN-YFMOFF
       ZPOS=ZIN-ZFMOFF
*** First see whether we at all have a grid.
       IF(.NOT.MAPFLG(1))RETURN
*** Initial values
       AROT=0
       RCOOR=0
       ZCOOR=0
*** If chamber is periodic, reduce to the cell volume.
       MIRRX=.FALSE.
       IF(PERX)THEN
            XPOS=XMMIN+MOD(XPOS-XMMIN,XMMAX-XMMIN)
            IF(XPOS.LT.XMMIN)XPOS=XPOS+(XMMAX-XMMIN)
       ELSEIF(PERMX)THEN
            XNEW=XMMIN+MOD(XPOS-XMMIN,XMMAX-XMMIN)
            IF(XNEW.LT.XMMIN)XNEW=XNEW+(XMMAX-XMMIN)
            NX=NINT((XNEW-XPOS)/(XMMAX-XMMIN))
            IF(NX.NE.2*(NX/2))THEN
                 XNEW=XMMIN+XMMAX-XNEW
                 MIRRX=.TRUE.
            ENDIF
            XPOS=XNEW
       ENDIF
       IF(PERAX.AND.(ZPOS.NE.0.OR.YPOS.NE.0))THEN
            AUXR=SQRT(ZPOS**2+YPOS**2)
            AUXPHI=ATAN2(ZPOS,YPOS)
            AROT=(XAMAX-XAMIN)*ANINT((AUXPHI-0.5*(XAMIN+XAMAX))/
     -           (XAMAX-XAMIN))
            IF(AUXPHI-AROT.LT.XAMIN)AROT=AROT-(XAMAX-XAMIN)
            IF(AUXPHI-AROT.GT.XAMAX)AROT=AROT+(XAMAX-XAMIN)
            AUXPHI=AUXPHI-AROT
            YPOS=AUXR*COS(AUXPHI)
            ZPOS=AUXR*SIN(AUXPHI)
       ENDIF
       MIRRY=.FALSE.
       IF(PERY)THEN
            YPOS=YMMIN+MOD(YPOS-YMMIN,YMMAX-YMMIN)
            IF(YPOS.LT.YMMIN)YPOS=YPOS+(YMMAX-YMMIN)
       ELSEIF(PERMY)THEN
            YNEW=YMMIN+MOD(YPOS-YMMIN,YMMAX-YMMIN)
            IF(YNEW.LT.YMMIN)YNEW=YNEW+(YMMAX-YMMIN)
            NY=NINT((YNEW-YPOS)/(YMMAX-YMMIN))
            IF(NY.NE.2*(NY/2))THEN
                 YNEW=YMMIN+YMMAX-YNEW
                 MIRRY=.TRUE.
            ENDIF
            YPOS=YNEW
       ENDIF
       IF(PERAY.AND.(XPOS.NE.0.OR.ZPOS.NE.0))THEN
            AUXR=SQRT(XPOS**2+ZPOS**2)
            AUXPHI=ATAN2(XPOS,ZPOS)
            AROT=(YAMAX-YAMIN)*ANINT((AUXPHI-0.5*(YAMIN+YAMAX))/
     -           (YAMAX-YAMIN))
            IF(AUXPHI-AROT.LT.YAMIN)AROT=AROT-(YAMAX-YAMIN)
            IF(AUXPHI-AROT.GT.YAMAX)AROT=AROT+(YAMAX-YAMIN)
            AUXPHI=AUXPHI-AROT
            ZPOS=AUXR*COS(AUXPHI)
            XPOS=AUXR*SIN(AUXPHI)
       ENDIF
       MIRRZ=.FALSE.
       IF(PERZ)THEN
            ZPOS=ZMMIN+MOD(ZPOS-ZMMIN,ZMMAX-ZMMIN)
            IF(ZPOS.LT.ZMMIN)ZPOS=ZPOS+(ZMMAX-ZMMIN)
       ELSEIF(PERMZ)THEN
            ZNEW=ZMMIN+MOD(ZPOS-ZMMIN,ZMMAX-ZMMIN)
            IF(ZNEW.LT.ZMMIN)ZNEW=ZNEW+(ZMMAX-ZMMIN)
            NZ=NINT((ZNEW-ZPOS)/(ZMMAX-ZMMIN))
            IF(NZ.NE.2*(NZ/2))THEN
                 ZNEW=ZMMIN+ZMMAX-ZNEW
                 MIRRZ=.TRUE.
            ENDIF
            ZPOS=ZNEW
       ENDIF
       IF(PERAZ.AND.(YPOS.NE.0.OR.XPOS.NE.0))THEN
            AUXR=SQRT(YPOS**2+XPOS**2)
            AUXPHI=ATAN2(YPOS,XPOS)
            AROT=(ZAMAX-ZAMIN)*ANINT((AUXPHI-0.5*(ZAMIN+ZAMAX))/
     -           (ZAMAX-ZAMIN))
            IF(AUXPHI-AROT.LT.ZAMIN)AROT=AROT-(ZAMAX-ZAMIN)
            IF(AUXPHI-AROT.GT.ZAMAX)AROT=AROT+(ZAMAX-ZAMIN)
            AUXPHI=AUXPHI-AROT
            XPOS=AUXR*COS(AUXPHI)
            YPOS=AUXR*SIN(AUXPHI)
       ENDIF
*** If we have a rotationally symmetric field map, store coordinates.
       IF(PERRX)THEN
            RCOOR=SQRT(YPOS**2+ZPOS**2)
            ZCOOR=XPOS
       ELSEIF(PERRY)THEN
            RCOOR=SQRT(XPOS**2+ZPOS**2)
            ZCOOR=YPOS
       ELSEIF(PERRZ)THEN
            RCOOR=SQRT(XPOS**2+YPOS**2)
            ZCOOR=ZPOS
       ENDIF
       IF(PERRX.OR.PERRY.OR.PERRZ)THEN
            XPOS=RCOOR
            YPOS=ZCOOR
            ZPOS=0
       ENDIF
C      print *,' Original: ',xin,yin,zin
C      print *,' Reduced:  ',xpos,ypos,zpos
*** Locate the point.
       CALL MAPIND(XPOS,YPOS,ZPOS,T1,T2,T3,T4,JAC,DET,IMAP)
       IF(IMAP.LE.0.OR.IMAP.GT.NMAP)THEN
            ILOC=-6
            RETURN
       ENDIF
*** Linear interpolation in straight triangles ...
       IF((MAPTYP.EQ.1.OR.MAPTYP.EQ.2.OR.MAPTYP.EQ.3).AND.
     -      MAPORD.EQ.1)THEN
            IF(LSFDER)THEN
                 DET=-(XMAP(IMAP,2)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,3)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,3)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3))
                 DT1DX=(YMAP(IMAP,3) - YMAP(IMAP,2))/DET
                 DT1DY=(XMAP(IMAP,2) - XMAP(IMAP,3))/DET
                 DT2DX=(YMAP(IMAP,1) - YMAP(IMAP,3))/DET
                 DT2DY=(XMAP(IMAP,3) - XMAP(IMAP,1))/DET
                 DT3DX=(YMAP(IMAP,2) - YMAP(IMAP,1))/DET
                 DT3DY=(XMAP(IMAP,1) - XMAP(IMAP,2))/DET
                 VOLT=VMAP(IMAP,1)*T1+VMAP(IMAP,2)*T2+VMAP(IMAP,3)*T3
                 EX=VMAP(IMAP, 1)*DT1DX+
     -              VMAP(IMAP, 2)*DT2DX+
     -              VMAP(IMAP, 3)*DT3DX
                 EY=VMAP(IMAP, 1)*DT1DY+
     -              VMAP(IMAP, 2)*DT2DY+
     -              VMAP(IMAP, 3)*DT3DY
                 EZ=0
            ELSE
                 IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -                VMAP(IMAP,1)*T1+VMAP(IMAP,2)*T2+VMAP(IMAP,3)*T3
                 IF(MAPFLG(2))EX=
     -                EXMAP(IMAP,1)*T1+EXMAP(IMAP,2)*T2+EXMAP(IMAP,3)*T3
                 IF(MAPFLG(3))EY=
     -                EYMAP(IMAP,1)*T1+EYMAP(IMAP,2)*T2+EYMAP(IMAP,3)*T3
                 IF(MAPFLG(4))EZ=
     -                EZMAP(IMAP,1)*T1+EZMAP(IMAP,2)*T2+EZMAP(IMAP,3)*T3
            ENDIF
**  quadratic interpolation in straight triangles ...
       ELSEIF(MAPTYP.EQ.2.AND.MAPORD.EQ.2)THEN
*   By gradient of the potential
            IF(LSFDER)THEN
                 DET=-(XMAP(IMAP,2)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,3)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,3)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3))
                 DT1DX=(YMAP(IMAP,3) - YMAP(IMAP,2))/DET
                 DT1DY=(XMAP(IMAP,2) - XMAP(IMAP,3))/DET
                 DT2DX=(YMAP(IMAP,1) - YMAP(IMAP,3))/DET
                 DT2DY=(XMAP(IMAP,3) - XMAP(IMAP,1))/DET
                 DT3DX=(YMAP(IMAP,2) - YMAP(IMAP,1))/DET
                 DT3DY=(XMAP(IMAP,1) - XMAP(IMAP,2))/DET
                 VOLT=VMAP(IMAP,1)*T1*(2*T1-1)+
     -                VMAP(IMAP,2)*T2*(2*T2-1)+
     -                VMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*VMAP(IMAP,4)*T1*T2+
     -                4*VMAP(IMAP,5)*T1*T3+
     -                4*VMAP(IMAP,6)*T2*T3
                 EX=VMAP(IMAP, 1)*(4*T1-1)*DT1DX+
     -              VMAP(IMAP, 2)*(4*T2-1)*DT2DX+
     -              VMAP(IMAP, 3)*(4*T3-1)*DT3DX+
     -              VMAP(IMAP, 4)*(4*T2*DT1DX+4*T1*DT2DX)+
     -              VMAP(IMAP, 5)*(4*T3*DT1DX+4*T1*DT3DX)+
     -              VMAP(IMAP, 6)*(4*T3*DT2DX+4*T2*DT3DX)
                 EY=VMAP(IMAP, 1)*(4*T1-1)*DT1DY+
     -              VMAP(IMAP, 2)*(4*T2-1)*DT2DY+
     -              VMAP(IMAP, 3)*(4*T3-1)*DT3DY+
     -              VMAP(IMAP, 4)*(4*T2*DT1DY+4*T1*DT2DY)+
     -              VMAP(IMAP, 5)*(4*T3*DT1DY+4*T1*DT3DY)+
     -              VMAP(IMAP, 6)*(4*T3*DT2DY+4*T2*DT3DY)
                 EZ=0
*   By interpolation of field maps.
            ELSE
                 IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -                VMAP(IMAP,1)*T1*(2*T1-1)+
     -                VMAP(IMAP,2)*T2*(2*T2-1)+
     -                VMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*VMAP(IMAP,4)*T1*T2+
     -                4*VMAP(IMAP,5)*T1*T3+
     -                4*VMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(2))EX=
     -                EXMAP(IMAP,1)*T1*(2*T1-1)+
     -                EXMAP(IMAP,2)*T2*(2*T2-1)+
     -                EXMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EXMAP(IMAP,4)*T1*T2+
     -                4*EXMAP(IMAP,5)*T1*T3+
     -                4*EXMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(3))EY=
     -                EYMAP(IMAP,1)*T1*(2*T1-1)+
     -                EYMAP(IMAP,2)*T2*(2*T2-1)+
     -                EYMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EYMAP(IMAP,4)*T1*T2+
     -                4*EYMAP(IMAP,5)*T1*T3+
     -                4*EYMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(4))EZ=
     -                EZMAP(IMAP,1)*T1*(2*T1-1)+
     -                EZMAP(IMAP,2)*T2*(2*T2-1)+
     -                EZMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EZMAP(IMAP,4)*T1*T2+
     -                4*EZMAP(IMAP,5)*T1*T3+
     -                4*EZMAP(IMAP,6)*T2*T3
            ENDIF
**  or quadratic interpolation in curved triangles ...
       ELSEIF((MAPTYP.EQ.3.AND.MAPORD.EQ.2).OR.
     -      (MAPTYP.EQ.5.AND.MAPORD.EQ.2.AND.ELMDGN(IMAP)))THEN
*   By gradient of the potential
            IF(LSFDER)THEN
                 VOLT=VMAP(IMAP,1)*T1*(2*T1-1)+
     -                VMAP(IMAP,2)*T2*(2*T2-1)+
     -                VMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*VMAP(IMAP,4)*T1*T2+
     -                4*VMAP(IMAP,5)*T1*T3+
     -                4*VMAP(IMAP,6)*T2*T3
                 EX=-(VMAP(IMAP, 1)*(4*T1-1)*JAC(1,2)+
     -                VMAP(IMAP, 2)*(4*T2-1)*JAC(2,2)+
     -                VMAP(IMAP, 3)*(4*T3-1)*JAC(3,2)+
     -                VMAP(IMAP, 4)*(4*T2*JAC(1,2)+4*T1*JAC(2,2))+
     -                VMAP(IMAP, 5)*(4*T3*JAC(1,2)+4*T1*JAC(3,2))+
     -                VMAP(IMAP, 6)*(4*T3*JAC(2,2)+4*T2*JAC(3,2)))/DET
                 EY=-(VMAP(IMAP, 1)*(4*T1-1)*JAC(1,3)+
     -                VMAP(IMAP, 2)*(4*T2-1)*JAC(2,3)+
     -                VMAP(IMAP, 3)*(4*T3-1)*JAC(3,3)+
     -                VMAP(IMAP, 4)*(4*T2*JAC(1,3)+4*T1*JAC(2,3))+
     -                VMAP(IMAP, 5)*(4*T3*JAC(1,3)+4*T1*JAC(3,3))+
     -                VMAP(IMAP, 6)*(4*T3*JAC(2,3)+4*T2*JAC(3,3)))/DET
                 EZ=0
*   By interpolation of field maps.
            ELSE
                 IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -                VMAP(IMAP,1)*T1*(2*T1-1)+
     -                VMAP(IMAP,2)*T2*(2*T2-1)+
     -                VMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*VMAP(IMAP,4)*T1*T2+
     -                4*VMAP(IMAP,5)*T1*T3+
     -                4*VMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(2))EX=
     -                EXMAP(IMAP,1)*T1*(2*T1-1)+
     -                EXMAP(IMAP,2)*T2*(2*T2-1)+
     -                EXMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EXMAP(IMAP,4)*T1*T2+
     -                4*EXMAP(IMAP,5)*T1*T3+
     -                4*EXMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(3))EY=
     -                EYMAP(IMAP,1)*T1*(2*T1-1)+
     -                EYMAP(IMAP,2)*T2*(2*T2-1)+
     -                EYMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EYMAP(IMAP,4)*T1*T2+
     -                4*EYMAP(IMAP,5)*T1*T3+
     -                4*EYMAP(IMAP,6)*T2*T3
                 IF(MAPFLG(4))EZ=
     -                EZMAP(IMAP,1)*T1*(2*T1-1)+
     -                EZMAP(IMAP,2)*T2*(2*T2-1)+
     -                EZMAP(IMAP,3)*T3*(2*T3-1)+
     -                4*EZMAP(IMAP,4)*T1*T2+
     -                4*EZMAP(IMAP,5)*T1*T3+
     -                4*EZMAP(IMAP,6)*T2*T3
            ENDIF
*** 8-node "serendipity" non-degenerate quadrilaterals, quadratic ...
       ELSEIF(MAPTYP.EQ.5.AND.MAPORD.EQ.2)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)THEN
                 VOLT=
     -                -VMAP(IMAP,1)*(1-T1)*(1-T2)*(1+T1+T2)/4-
     -                VMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T1+T2)/4-
     -                VMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T1-T2)/4-
     -                VMAP(IMAP,4)*(1-T1)*(1+T2)*(1+T1-T2)/4+
     -                VMAP(IMAP,5)*(1-T1)*(1+T1)*(1-T2)/2+
     -                VMAP(IMAP,6)*(1+T1)*(1+T2)*(1-T2)/2+
     -                VMAP(IMAP,7)*(1-T1)*(1+T1)*(1+T2)/2+
     -                VMAP(IMAP,8)*(1-T1)*(1+T2)*(1-T2)/2
            ENDIF
            IF(LSFDER.AND.MAPFLG(5))THEN
                 EX=-(VMAP(IMAP, 1)*((1-T2)*(2*T1+T2)*JAC(1,1)+
     -                               (1-T1)*(T1+2*T2)*JAC(2,1))/4+
     -                VMAP(IMAP, 2)*((1-T2)*(2*T1-T2)*JAC(1,1)-
     -                               (1+T1)*(T1-2*T2)*JAC(2,1))/4+
     -                VMAP(IMAP, 3)*((1+T2)*(2*T1+T2)*JAC(1,1)+
     -                               (1+T1)*(T1+2*T2)*JAC(2,1))/4+
     -                VMAP(IMAP, 4)*((1+T2)*(2*T1-T2)*JAC(1,1)-
     -                               (1-T1)*(T1-2*T2)*JAC(2,1))/4+
     -                VMAP(IMAP, 5)*(T1*(T2-1)       *JAC(1,1)+
     -                               (T1-1)*(T1+1)   *JAC(2,1)/2)+
     -                VMAP(IMAP, 6)*((1-T2)*(1+T2)   *JAC(1,1)/2-
     -                               (1+T1)*T2       *JAC(2,1))+
     -                VMAP(IMAP, 7)*(-T1*(1+T2)      *JAC(1,1)+
     -                               (1-T1)*(1+T1)   *JAC(2,1)/2)+
     -                VMAP(IMAP, 8)*((T2-1)*(T2+1)   *JAC(1,1)/2+
     -                               (T1-1)*T2       *JAC(2,1)))/DET
                 EY=-(VMAP(IMAP, 1)*((1-T2)*(2*T1+T2)*JAC(1,2)+
     -                               (1-T1)*(T1+2*T2)*JAC(2,2))/4+
     -                VMAP(IMAP, 2)*((1-T2)*(2*T1-T2)*JAC(1,2)-
     -                               (1+T1)*(T1-2*T2)*JAC(2,2))/4+
     -                VMAP(IMAP, 3)*((1+T2)*(2*T1+T2)*JAC(1,2)+
     -                               (1+T1)*(T1+2*T2)*JAC(2,2))/4+
     -                VMAP(IMAP, 4)*((1+T2)*(2*T1-T2)*JAC(1,2)-
     -                               (1-T1)*(T1-2*T2)*JAC(2,2))/4+
     -                VMAP(IMAP, 5)*(T1*(T2-1)       *JAC(1,2)+
     -                               (T1-1)*(T1+1)   *JAC(2,2)/2)+
     -                VMAP(IMAP, 6)*((1-T2)*(1+T2)   *JAC(1,2)/2-
     -                               (1+T1)*T2       *JAC(2,2))+
     -                VMAP(IMAP, 7)*(-T1*(1+T2)      *JAC(1,2)+
     -                               (1-T1)*(1+T1)   *JAC(2,2)/2)+
     -                VMAP(IMAP, 8)*((T2-1)*(T2+1)   *JAC(1,2)/2+
     -                               (T1-1)*T2       *JAC(2,2)))/DET
            ELSEIF(.NOT.LSFDER)THEN
                 IF(MAPFLG(2))EX=
     -                -EXMAP(IMAP,1)*(1-T1)*(1-T2)*(1+T1+T2)/4-
     -                 EXMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T1+T2)/4-
     -                 EXMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T1-T2)/4-
     -                 EXMAP(IMAP,4)*(1-T1)*(1+T2)*(1+T1-T2)/4+
     -                 EXMAP(IMAP,5)*(1-T1)*(1+T1)*(1-T2)/2+
     -                 EXMAP(IMAP,6)*(1+T1)*(1+T2)*(1-T2)/2+
     -                 EXMAP(IMAP,7)*(1-T1)*(1+T1)*(1+T2)/2+
     -                 EXMAP(IMAP,8)*(1-T1)*(1+T2)*(1-T2)/2
                 IF(MAPFLG(3))EY=
     -                -EYMAP(IMAP,1)*(1-T1)*(1-T2)*(1+T1+T2)/4-
     -                 EYMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T1+T2)/4-
     -                 EYMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T1-T2)/4-
     -                 EYMAP(IMAP,4)*(1-T1)*(1+T2)*(1+T1-T2)/4+
     -                 EYMAP(IMAP,5)*(1-T1)*(1+T1)*(1-T2)/2+
     -                 EYMAP(IMAP,6)*(1+T1)*(1+T2)*(1-T2)/2+
     -                 EYMAP(IMAP,7)*(1-T1)*(1+T1)*(1+T2)/2+
     -                 EYMAP(IMAP,8)*(1-T1)*(1+T2)*(1-T2)/2
            ENDIF
*** A 3-dimensional interpolation (tetrahedra), linear ...
       ELSEIF((MAPTYP.EQ.11.OR.MAPTYP.EQ.12.OR.MAPTYP.EQ.13).AND.
     -      MAPORD.EQ.1)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=VMAP(IMAP,1)*T1+
     -           VMAP(IMAP,2)*T2+VMAP(IMAP,3)*T3+VMAP(IMAP,4)*T4
            IF(LSFDER)THEN
                 DET = XMAP(IMAP,2)*YMAP(IMAP,3)*ZMAP(IMAP,1)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,4)*ZMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)*ZMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,4)*ZMAP(IMAP,2)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,1)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)*ZMAP(IMAP,3)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,4)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,2)*YMAP(IMAP,4)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,4)*(YMAP(IMAP,2)*ZMAP(IMAP,1)-
     -                               YMAP(IMAP,3)*ZMAP(IMAP,1)-
     -                               YMAP(IMAP,1)*ZMAP(IMAP,2)+
     -                               YMAP(IMAP,3)*ZMAP(IMAP,2)+
     -                               YMAP(IMAP,1)*ZMAP(IMAP,3)-
     -                               YMAP(IMAP,2)*ZMAP(IMAP,3))+
     -                 XMAP(IMAP,2)*YMAP(IMAP,1)*ZMAP(IMAP,4)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)*ZMAP(IMAP,4)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)*ZMAP(IMAP,4)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3)*ZMAP(IMAP,4)+
     -                 XMAP(IMAP,3)*(YMAP(IMAP,4)*ZMAP(IMAP,1)+
     -                               YMAP(IMAP,1)*ZMAP(IMAP,2)-
     -                               YMAP(IMAP,4)*ZMAP(IMAP,2)-
     -                               YMAP(IMAP,1)*ZMAP(IMAP,4)-
     -                               YMAP(IMAP,2)*ZMAP(IMAP,1)+
     -                               YMAP(IMAP,2)*ZMAP(IMAP,4))
                 EX=-(VMAP(IMAP,1)*(
     -                     YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                     YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,2)*(
     -                     YMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))+
     -                     YMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,1)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,3)*(
     -                     YMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                     YMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,4)*(
     -                     YMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                     YMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                     YMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))))/
     -                DET
                 EY=-(VMAP(IMAP,1)*(
     -                     XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                     XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,2)*(
     -                     XMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                     XMAP(IMAP,1)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,3)*(
     -                     XMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                     XMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                VMAP(IMAP,4)*(
     -                     XMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                     XMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                     XMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))))/
     -                DET
                 EZ=-(VMAP(IMAP,1)*(
     -                     XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                     XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))+
     -                VMAP(IMAP,2)*(
     -                     XMAP(IMAP,4)*(-YMAP(IMAP,1)+YMAP(IMAP,3))+
     -                     XMAP(IMAP,3)*( YMAP(IMAP,1)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,1)*(-YMAP(IMAP,3)+YMAP(IMAP,4)))+
     -                VMAP(IMAP,3)*(
     -                     XMAP(IMAP,4)*( YMAP(IMAP,1)-YMAP(IMAP,2))+
     -                     XMAP(IMAP,1)*( YMAP(IMAP,2)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,2)*(-YMAP(IMAP,1)+YMAP(IMAP,4)))+
     -                VMAP(IMAP,4)*(
     -                     XMAP(IMAP,3)*(-YMAP(IMAP,1)+YMAP(IMAP,2))+
     -                     XMAP(IMAP,2)*( YMAP(IMAP,1)-YMAP(IMAP,3))+
     -                     XMAP(IMAP,1)*(-YMAP(IMAP,2)+YMAP(IMAP,3))))/
     -                DET
            ELSE
                 IF(MAPFLG(2))EX=EXMAP(IMAP,1)*T1+EXMAP(IMAP,2)*T2+
     -                EXMAP(IMAP,3)*T3+EXMAP(IMAP,4)*T4
                 IF(MAPFLG(3))EY=EYMAP(IMAP,1)*T1+EYMAP(IMAP,2)*T2+
     -                EYMAP(IMAP,3)*T3+EYMAP(IMAP,4)*T4
                 IF(MAPFLG(4))EZ=EZMAP(IMAP,1)*T1+EZMAP(IMAP,2)*T2+
     -                EZMAP(IMAP,3)*T3+EZMAP(IMAP,4)*T4
            ENDIF
**  or quadratic in linear tetrahedra ....
       ELSEIF(MAPTYP.EQ.12.AND.MAPORD.EQ.2)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*T1*(2*T1-1)+VMAP(IMAP,2)*T2*(2*T2-1)+
     -           VMAP(IMAP,3)*T3*(2*T3-1)+VMAP(IMAP,4)*T4*(2*T4-1)+
     -           4*VMAP(IMAP,5)*T1*T2+4*VMAP(IMAP,6)*T1*T3+
     -           4*VMAP(IMAP,7)*T1*T4+4*VMAP(IMAP,8)*T2*T3+
     -           4*VMAP(IMAP,9)*T2*T4+4*VMAP(IMAP,10)*T3*T4
            IF(LSFDER)THEN
*   Determinant of the Jacobian.
                 DET=-((ZMAP(IMAP,1)-ZMAP(IMAP,2))*
     -                 (XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))+
     -                 (XMAP(IMAP,1)-XMAP(IMAP,2))*
     -                 (YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                 (YMAP(IMAP,1)-YMAP(IMAP,2))*
     -                 (XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4))))
*   Elements of the Jacobian
                 DT1DX=(YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))/DET
                 DT1DY=(XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))/DET
                 DT1DZ=(XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))/DET
                 DT2DX=(YMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))+
     -                  YMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,1)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))/DET
                 DT2DY=(XMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                  XMAP(IMAP,1)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))/DET
                 DT2DZ=(XMAP(IMAP,4)*(-YMAP(IMAP,1)+YMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( YMAP(IMAP,1)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,1)*(-YMAP(IMAP,3)+YMAP(IMAP,4)))/DET
                 DT3DX=(YMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                  YMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))/DET
                 DT3DY=(XMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                  XMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))/DET
                 DT3DZ=(XMAP(IMAP,4)*( YMAP(IMAP,1)-YMAP(IMAP,2))+
     -                  XMAP(IMAP,1)*( YMAP(IMAP,2)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-YMAP(IMAP,1)+YMAP(IMAP,4)))/DET
                 DT4DX=(YMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3)))/DET
                 DT4DY=(XMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                  XMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3)))/DET
                 DT4DZ=(XMAP(IMAP,3)*(-YMAP(IMAP,1)+YMAP(IMAP,2))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,1)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,1)*(-YMAP(IMAP,2)+YMAP(IMAP,3)))/DET
*   Electric field
                 EX=VMAP(IMAP, 1)*(4*T1-1)*DT1DX+
     -              VMAP(IMAP, 2)*(4*T2-1)*DT2DX+
     -              VMAP(IMAP, 3)*(4*T3-1)*DT3DX+
     -              VMAP(IMAP, 4)*(4*T4-1)*DT4DX+
     -              VMAP(IMAP, 5)*(4*T2*DT1DX+4*T1*DT2DX)+
     -              VMAP(IMAP, 6)*(4*T3*DT1DX+4*T1*DT3DX)+
     -              VMAP(IMAP, 7)*(4*T4*DT1DX+4*T1*DT4DX)+
     -              VMAP(IMAP, 8)*(4*T3*DT2DX+4*T2*DT3DX)+
     -              VMAP(IMAP, 9)*(4*T4*DT2DX+4*T2*DT4DX)+
     -              VMAP(IMAP,10)*(4*T4*DT3DX+4*T3*DT4DX)
                 EY=VMAP(IMAP, 1)*(4*T1-1)*DT1DY+
     -              VMAP(IMAP, 2)*(4*T2-1)*DT2DY+
     -              VMAP(IMAP, 3)*(4*T3-1)*DT3DY+
     -              VMAP(IMAP, 4)*(4*T4-1)*DT4DY+
     -              VMAP(IMAP, 5)*(4*T2*DT1DY+4*T1*DT2DY)+
     -              VMAP(IMAP, 6)*(4*T3*DT1DY+4*T1*DT3DY)+
     -              VMAP(IMAP, 7)*(4*T4*DT1DY+4*T1*DT4DY)+
     -              VMAP(IMAP, 8)*(4*T3*DT2DY+4*T2*DT3DY)+
     -              VMAP(IMAP, 9)*(4*T4*DT2DY+4*T2*DT4DY)+
     -              VMAP(IMAP,10)*(4*T4*DT3DY+4*T3*DT4DY)
                 EZ=VMAP(IMAP, 1)*(4*T1-1)*DT1DZ+
     -              VMAP(IMAP, 2)*(4*T2-1)*DT2DZ+
     -              VMAP(IMAP, 3)*(4*T3-1)*DT3DZ+
     -              VMAP(IMAP, 4)*(4*T4-1)*DT4DZ+
     -              VMAP(IMAP, 5)*(4*T2*DT1DZ+4*T1*DT2DZ)+
     -              VMAP(IMAP, 6)*(4*T3*DT1DZ+4*T1*DT3DZ)+
     -              VMAP(IMAP, 7)*(4*T4*DT1DZ+4*T1*DT4DZ)+
     -              VMAP(IMAP, 8)*(4*T3*DT2DZ+4*T2*DT3DZ)+
     -              VMAP(IMAP, 9)*(4*T4*DT2DZ+4*T2*DT4DZ)+
     -              VMAP(IMAP,10)*(4*T4*DT3DZ+4*T3*DT4DZ)
            ELSE
                 IF(MAPFLG(2))EX=
     -                EXMAP(IMAP,1)*T1*(2*T1-1)+
     -                EXMAP(IMAP,2)*T2*(2*T2-1)+
     -                EXMAP(IMAP,3)*T3*(2*T3-1)+
     -                EXMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EXMAP(IMAP,5)*T1*T2+
     -                4*EXMAP(IMAP,6)*T1*T3+
     -                4*EXMAP(IMAP,7)*T1*T4+
     -                4*EXMAP(IMAP,8)*T2*T3+
     -                4*EXMAP(IMAP,9)*T2*T4+
     -                4*EXMAP(IMAP,10)*T3*T4
                 IF(MAPFLG(3))EY=
     -                EYMAP(IMAP,1)*T1*(2*T1-1)+
     -                EYMAP(IMAP,2)*T2*(2*T2-1)+
     -                EYMAP(IMAP,3)*T3*(2*T3-1)+
     -                EYMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EYMAP(IMAP,5)*T1*T2+
     -                4*EYMAP(IMAP,6)*T1*T3+
     -                4*EYMAP(IMAP,7)*T1*T4+
     -                4*EYMAP(IMAP,8)*T2*T3+
     -                4*EYMAP(IMAP,9)*T2*T4+
     -                4*EYMAP(IMAP,10)*T3*T4
                 IF(MAPFLG(4))EZ=
     -                EZMAP(IMAP,1)*T1*(2*T1-1)+
     -                EZMAP(IMAP,2)*T2*(2*T2-1)+
     -                EZMAP(IMAP,3)*T3*(2*T3-1)+
     -                EZMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EZMAP(IMAP,5)*T1*T2+
     -                4*EZMAP(IMAP,6)*T1*T3+
     -                4*EZMAP(IMAP,7)*T1*T4+
     -                4*EZMAP(IMAP,8)*T2*T3+
     -                4*EZMAP(IMAP,9)*T2*T4+
     -                4*EZMAP(IMAP,10)*T3*T4
            ENDIF
**  or quadratic in quadratic tetrahedra ....
       ELSEIF(MAPTYP.EQ.13.AND.MAPORD.EQ.2)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*T1*(2*T1-1)+VMAP(IMAP,2)*T2*(2*T2-1)+
     -           VMAP(IMAP,3)*T3*(2*T3-1)+VMAP(IMAP,4)*T4*(2*T4-1)+
     -           4*VMAP(IMAP,5)*T1*T2+4*VMAP(IMAP,6)*T1*T3+
     -           4*VMAP(IMAP,7)*T1*T4+4*VMAP(IMAP,8)*T2*T3+
     -           4*VMAP(IMAP,9)*T2*T4+4*VMAP(IMAP,10)*T3*T4
            IF(LSFDER.AND.MAPFLG(5))THEN
                 EX=-(VMAP(IMAP, 1)*(4*T1-1)*JAC(1,2)+
     -                VMAP(IMAP, 2)*(4*T2-1)*JAC(2,2)+
     -                VMAP(IMAP, 3)*(4*T3-1)*JAC(3,2)+
     -                VMAP(IMAP, 4)*(4*T4-1)*JAC(4,2)+
     -                VMAP(IMAP, 5)*(4*T2*JAC(1,2)+4*T1*JAC(2,2))+
     -                VMAP(IMAP, 6)*(4*T3*JAC(1,2)+4*T1*JAC(3,2))+
     -                VMAP(IMAP, 7)*(4*T4*JAC(1,2)+4*T1*JAC(4,2))+
     -                VMAP(IMAP, 8)*(4*T3*JAC(2,2)+4*T2*JAC(3,2))+
     -                VMAP(IMAP, 9)*(4*T4*JAC(2,2)+4*T2*JAC(4,2))+
     -                VMAP(IMAP,10)*(4*T4*JAC(3,2)+4*T3*JAC(4,2)))/DET
                 EY=-(VMAP(IMAP, 1)*(4*T1-1)*JAC(1,3)+
     -                VMAP(IMAP, 2)*(4*T2-1)*JAC(2,3)+
     -                VMAP(IMAP, 3)*(4*T3-1)*JAC(3,3)+
     -                VMAP(IMAP, 4)*(4*T4-1)*JAC(4,3)+
     -                VMAP(IMAP, 5)*(4*T2*JAC(1,3)+4*T1*JAC(2,3))+
     -                VMAP(IMAP, 6)*(4*T3*JAC(1,3)+4*T1*JAC(3,3))+
     -                VMAP(IMAP, 7)*(4*T4*JAC(1,3)+4*T1*JAC(4,3))+
     -                VMAP(IMAP, 8)*(4*T3*JAC(2,3)+4*T2*JAC(3,3))+
     -                VMAP(IMAP, 9)*(4*T4*JAC(2,3)+4*T2*JAC(4,3))+
     -                VMAP(IMAP,10)*(4*T4*JAC(3,3)+4*T3*JAC(4,3)))/DET
                 EZ=-(VMAP(IMAP, 1)*(4*T1-1)*JAC(1,4)+
     -                VMAP(IMAP, 2)*(4*T2-1)*JAC(2,4)+
     -                VMAP(IMAP, 3)*(4*T3-1)*JAC(3,4)+
     -                VMAP(IMAP, 4)*(4*T4-1)*JAC(4,4)+
     -                VMAP(IMAP, 5)*(4*T2*JAC(1,4)+4*T1*JAC(2,4))+
     -                VMAP(IMAP, 6)*(4*T3*JAC(1,4)+4*T1*JAC(3,4))+
     -                VMAP(IMAP, 7)*(4*T4*JAC(1,4)+4*T1*JAC(4,4))+
     -                VMAP(IMAP, 8)*(4*T3*JAC(2,4)+4*T2*JAC(3,4))+
     -                VMAP(IMAP, 9)*(4*T4*JAC(2,4)+4*T2*JAC(4,4))+
     -                VMAP(IMAP,10)*(4*T4*JAC(3,4)+4*T3*JAC(4,4)))/DET
            ELSEIF(.NOT.LSFDER)THEN
                 IF(MAPFLG(2))EX=
     -                EXMAP(IMAP,1)*T1*(2*T1-1)+
     -                EXMAP(IMAP,2)*T2*(2*T2-1)+
     -                EXMAP(IMAP,3)*T3*(2*T3-1)+
     -                EXMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EXMAP(IMAP,5)*T1*T2+
     -                4*EXMAP(IMAP,6)*T1*T3+
     -                4*EXMAP(IMAP,7)*T1*T4+
     -                4*EXMAP(IMAP,8)*T2*T3+
     -                4*EXMAP(IMAP,9)*T2*T4+
     -                4*EXMAP(IMAP,10)*T3*T4
                 IF(MAPFLG(3))EY=
     -                EYMAP(IMAP,1)*T1*(2*T1-1)+
     -                EYMAP(IMAP,2)*T2*(2*T2-1)+
     -                EYMAP(IMAP,3)*T3*(2*T3-1)+
     -                EYMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EYMAP(IMAP,5)*T1*T2+
     -                4*EYMAP(IMAP,6)*T1*T3+
     -                4*EYMAP(IMAP,7)*T1*T4+
     -                4*EYMAP(IMAP,8)*T2*T3+
     -                4*EYMAP(IMAP,9)*T2*T4+
     -                4*EYMAP(IMAP,10)*T3*T4
                 IF(MAPFLG(4))EZ=
     -                EZMAP(IMAP,1)*T1*(2*T1-1)+
     -                EZMAP(IMAP,2)*T2*(2*T2-1)+
     -                EZMAP(IMAP,3)*T3*(2*T3-1)+
     -                EZMAP(IMAP,4)*T4*(2*T4-1)+
     -                4*EZMAP(IMAP,5)*T1*T2+
     -                4*EZMAP(IMAP,6)*T1*T3+
     -                4*EZMAP(IMAP,7)*T1*T4+
     -                4*EZMAP(IMAP,8)*T2*T3+
     -                4*EZMAP(IMAP,9)*T2*T4+
     -                4*EZMAP(IMAP,10)*T3*T4
            ENDIF
*** Or an interpolation on a non-degerate hexahedron, interpolate.
       ELSEIF(MAPTYP.EQ.14.AND..NOT.ELMDGN(IMAP).AND..NOT.LSFDER)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*(1-T1)*(1-T2)*(1-T3)/8+
     -           VMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T3)/8+
     -           VMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T3)/8+
     -           VMAP(IMAP,4)*(1-T1)*(1+T2)*(1-T3)/8+
     -           VMAP(IMAP,5)*(1-T1)*(1-T2)*(1+T3)/8+
     -           VMAP(IMAP,6)*(1+T1)*(1-T2)*(1+T3)/8+
     -           VMAP(IMAP,7)*(1+T1)*(1+T2)*(1+T3)/8+
     -           VMAP(IMAP,8)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(2))EX=
     -           EXMAP(IMAP,1)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EXMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EXMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EXMAP(IMAP,4)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EXMAP(IMAP,5)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EXMAP(IMAP,6)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EXMAP(IMAP,7)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EXMAP(IMAP,8)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(3))EY=
     -           EYMAP(IMAP,1)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EYMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EYMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EYMAP(IMAP,4)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EYMAP(IMAP,5)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EYMAP(IMAP,6)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EYMAP(IMAP,7)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EYMAP(IMAP,8)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(4))EZ=
     -           EZMAP(IMAP,1)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EZMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EZMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EZMAP(IMAP,4)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EZMAP(IMAP,5)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EZMAP(IMAP,6)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EZMAP(IMAP,7)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EZMAP(IMAP,8)*(1-T1)*(1+T2)*(1+T3)/8
**  or an interpolation on a non-degerate hexahedron, derivatives.
       ELSEIF(MAPTYP.EQ.14.AND..NOT.ELMDGN(IMAP).AND.LSFDER)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*(1-T1)*(1-T2)*(1-T3)/8+
     -           VMAP(IMAP,2)*(1+T1)*(1-T2)*(1-T3)/8+
     -           VMAP(IMAP,3)*(1+T1)*(1+T2)*(1-T3)/8+
     -           VMAP(IMAP,4)*(1-T1)*(1+T2)*(1-T3)/8+
     -           VMAP(IMAP,5)*(1-T1)*(1-T2)*(1+T3)/8+
     -           VMAP(IMAP,6)*(1+T1)*(1-T2)*(1+T3)/8+
     -           VMAP(IMAP,7)*(1+T1)*(1+T2)*(1+T3)/8+
     -           VMAP(IMAP,8)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(5))EX=
     -         -(VMAP(IMAP,1)*(DN1DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,2)*(DN2DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,3)*(DN3DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,4)*(DN4DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,5)*(DN5DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,6)*(DN6DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,7)*(DN7DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,8)*(DN8DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,1)))/DET
            IF(MAPFLG(5))EY=
     -         -(VMAP(IMAP,1)*(DN1DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,2)*(DN2DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,3)*(DN3DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,4)*(DN4DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,5)*(DN5DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,6)*(DN6DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,7)*(DN7DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,8)*(DN8DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,2)))/DET
            IF(MAPFLG(5))EZ=
     -         -(VMAP(IMAP,1)*(DN1DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,2)*(DN2DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,3)*(DN3DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,4)*(DN4DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,5)*(DN5DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,6)*(DN6DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,7)*(DN7DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,8)*(DN8DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,3)))/DET
**  or an interpolation on a degerate hexahedron, interpolate
       ELSEIF(MAPTYP.EQ.14.AND.ELMDGN(IMAP).AND..NOT.LSFDER)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*(1-T1-T2)*(1-T3)/2+
     -           VMAP(IMAP,2)*      T1 *(1-T3)/2+
     -           VMAP(IMAP,3)*      T2 *(1-T3)/2+
     -           VMAP(IMAP,5)*(1-T1-T2)*(1+T3)/2+
     -           VMAP(IMAP,6)*      T1 *(1+T3)/2+
     -           VMAP(IMAP,7)*      T2 *(1+T3)/2
            IF(MAPFLG(2))EX=
     -           EXMAP(IMAP,1)*(1-T1-T2)*(1-T3)/2+
     -           EXMAP(IMAP,2)*      T1 *(1-T3)/2+
     -           EXMAP(IMAP,3)*      T2 *(1-T3)/2+
     -           EXMAP(IMAP,5)*(1-T1-T2)*(1+T3)/2+
     -           EXMAP(IMAP,6)*      T1 *(1+T3)/2+
     -           EXMAP(IMAP,7)*      T2 *(1+T3)/2
            IF(MAPFLG(3))EY=
     -           EYMAP(IMAP,1)*(1-T1-T2)*(1-T3)/2+
     -           EYMAP(IMAP,2)*      T1 *(1-T3)/2+
     -           EYMAP(IMAP,3)*      T2 *(1-T3)/2+
     -           EYMAP(IMAP,5)*(1-T1-T2)*(1+T3)/2+
     -           EYMAP(IMAP,6)*      T1 *(1+T3)/2+
     -           EYMAP(IMAP,7)*      T2 *(1+T3)/2
            IF(MAPFLG(4))EZ=
     -           EZMAP(IMAP,1)*(1-T1-T2)*(1-T3)/2+
     -           EZMAP(IMAP,2)*      T1 *(1-T3)/2+
     -           EZMAP(IMAP,3)*      T2 *(1-T3)/2+
     -           EZMAP(IMAP,5)*(1-T1-T2)*(1+T3)/2+
     -           EZMAP(IMAP,6)*      T1 *(1+T3)/2+
     -           EZMAP(IMAP,7)*      T2 *(1+T3)/2
**  or an interpolation on a degerate hexahedron, derivatives.
       ELSEIF(MAPTYP.EQ.14.AND.ELMDGN(IMAP).AND.LSFDER)THEN
            IF(MAPFLG(5).AND.IOPT.EQ.1)VOLT=
     -           VMAP(IMAP,1)*(1-T1-T2)*(1-T3)/2+
     -           VMAP(IMAP,2)*      T1 *(1-T3)/2+
     -           VMAP(IMAP,3)*      T2 *(1-T3)/2+
     -           VMAP(IMAP,5)*(1-T1-T2)*(1+T3)/2+
     -           VMAP(IMAP,6)*      T1 *(1+T3)/2+
     -           VMAP(IMAP,7)*      T2 *(1+T3)/2
            IF(MAPFLG(5))EX=
     -         -(VMAP(IMAP,1)*(DN1DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,2)*(DN2DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,3)*(DN3DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,5)*(DN4DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,6)*(DN5DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,1))+
     -           VMAP(IMAP,7)*(DN6DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,1)))/DET
            IF(MAPFLG(5))EY=
     -         -(VMAP(IMAP,1)*(DN1DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,2)*(DN2DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,3)*(DN3DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,5)*(DN4DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,6)*(DN5DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,2))+
     -           VMAP(IMAP,7)*(DN6DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,2)))/DET
            IF(MAPFLG(5))EZ=
     -         -(VMAP(IMAP,1)*(DN1DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,2)*(DN2DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,3)*(DN3DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,5)*(DN4DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,6)*(DN5DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,3))+
     -           VMAP(IMAP,7)*(DN6DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,3)))/DET
*** Or an unknown case.
       ELSE
            ILOC=-10
            RETURN
       ENDIF
*** Apply mirror imaging.
       IF(MIRRX)EX=-EX
       IF(MIRRY)EY=-EY
       IF(MIRRZ)EZ=-EZ
*** Rotate the field.
       IF(PERAX)THEN
            CALL CFMCTP(EY,EZ,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EY,EZ,1)
       ENDIF
       IF(PERAY)THEN
            CALL CFMCTP(EZ,EX,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EZ,EX,1)
       ENDIF
       IF(PERAZ)THEN
            CALL CFMCTP(EX,EY,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EX,EY,1)
       ENDIF
*** And take care of symmetry, x is radial component.
       ER=EX
*   The axial component is either in Ey or in Ez.
       IF(LSFDER)THEN
            EAXIS=EY
       ELSE
            EAXIS=EZ
       ENDIF
       IF(PERRX)THEN
            IF(RCOOR.LE.0)THEN
                 EX=EAXIS
                 EY=0
                 EZ=0
            ELSE
                 EX=EAXIS
                 EY=ER*YIN/RCOOR
                 EZ=ER*ZIN/RCOOR
            ENDIF
       ENDIF
       IF(PERRY)THEN
            IF(RCOOR.LE.0)THEN
                 EX=0
                 EY=EAXIS
                 EZ=0
            ELSE
                 EX=ER*XIN/RCOOR
                 EY=EAXIS
                 EZ=ER*ZIN/RCOOR
            ENDIF
       ENDIF
       IF(PERRZ)THEN
            IF(RCOOR.LE.0)THEN
                 EX=0
                 EY=0
                 EZ=EAXIS
            ELSE
                 EX=ER*XIN/RCOOR
                 EY=ER*YIN/RCOOR
                 EZ=EAXIS
            ENDIF
       ENDIF
*** And store material index.
       IF(MATMAP(IMAP).EQ.IDRMAT.OR..NOT.MAPFLG(9))THEN
            ILOC=0
       ELSE
            ILOC=-5
       ENDIF
       END
CDECK  ID>, DLCVAC.
       SUBROUTINE DLCVAC(X1,Y1,Z1,VX1,VY1,VZ1,Q,PMASS)
*-----------------------------------------------------------------------
*   DLCVAC - Subroutine doing the actual drift line calculations in
*            vacuo. It communicates with the outside through sequence 
*            DRIFTLINE. The calculations are based on a Runge Kutta
*            Nystroem method with step size control based on the
*            comparison of a 5th and a 2nd order estimate.
*
* NIST 1 eV = 1.782 661 845 x 10-36 kg 
* http://physics.nist.gov/cgi-bin/cuu/Value?evkg
*
*   VARIABLES : H          : Current stepsize (it is in fact a delta t).
*               HPREV      : Stores the previous value of H (comparison)
*               INITCH     : Used for checking initial stepsize (1 = ok)
*               X1,Y1,Z1   : Starting location [cm]
*               VX1,VY1,VZ1: Starting velocity [cm/microsec]
*               Q          : Charge, -1 for e-, +1 for proton
*               PMASS      : Mass in MeV
*   (Last changed on 12/ 7/13.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION TIME,VEL(3),POS(3),ACC(3),H,HPREV,
     -      WORK(18),OLDPOS(3),OLDVEL(3),OLDACC(3),TRAPEZ(3)
       INTEGER ILOC,INITCH,ILOCVF,I,IOUT
       REAL Q,PMASS,X1,Y1,Z1,VX1,VY1,VZ1,EX,EY,EZ,ETOT,VOLT,EOVERM
       COMMON /VFUCOM/ EOVERM,ILOCVF
       EXTERNAL DLCVFU
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE DLCVAC ///'
*** Ensure that v < c
       IF(VX1**2+VY1**2+VZ1**2.GT.CLIGHT**2)THEN
            PRINT *,' !!!!!! DLCVAC WARNING : Initial velocity'//
     -           ' exceeds the speed of light; not tracked.'
            ISTAT = -3
            RETURN
       ENDIF
*** Initialise the output position and time vectors.
       NU=1
       XU(1)=DBLE(X1)
       YU(1)=DBLE(Y1)
       ZU(1)=DBLE(Z1)
       TU(1)=0.0D0
       ISTAT=0
*** Set particle type according to mass and technique to vacuum.
       IF(ABS(PMASS*MEV2KG-EMASS).LT.
     -      1E-4*(ABS(EMASS)+ABS(PMASS*MEV2KG)))THEN
            IPTYPE=1
       ELSE
            IPTYPE=2
       ENDIF
       QPCHAR=Q
       IPTECH=3
*** Set the charge over mass ratio.
       EOVERM=ECHARG*Q/(PMASS*MEV2KG)
       print *,' Charge: ',q,echarg*q
       print *,' Mass:   ',pmass,PMASS*MEV2KG
       print *,' Gamma:  ',1/SQRT(1-(Vx1**2+Vy1**2+Vz1**2)/CLIGHT**2)
*** Check the initial position, setting a status code if appropriate.
       CALL EFIELD(X1,Y1,Z1,EX,EY,EZ,ETOT,VOLT,0,ILOC)
*   In a wire.
       IF(ILOC.GT.0.AND.ILOC.LE.MXWIRE)THEN
            IF((X(ILOC)-X1)**2+(Y(ILOC)-Y1)**2.LE.0.25*D(ILOC)**2)THEN
                 ISTAT=ILOC
            ELSE
                 ISTAT=ILOC+MXWIRE
            ENDIF
*   Outside the planes.
       ELSEIF(ILOC.EQ.-1.OR.ILOC.EQ.-4)THEN
            IF(YNPLAN(1).AND.X1.LE.COPLAN(1))THEN
                 ISTAT=-11
            ELSEIF(YNPLAN(2).AND.X1.GE.COPLAN(2))THEN
                 ISTAT=-12
            ELSEIF(YNPLAN(3).AND.Y1.LE.COPLAN(3))THEN
                 ISTAT=-13
            ELSEIF(YNPLAN(4).AND.Y1.GE.COPLAN(4))THEN
                 ISTAT=-14
            ELSEIF(TUBE)THEN
                 CALL INTUBE(X1,Y1,COTUBE,NTUBE,IOUT)
                 IF(IOUT.EQ.1)THEN
                      ISTAT=-15
                 ELSEIF(IOUT.NE.0)THEN
                      ISTAT=-3
                 ENDIF
            ENDIF
            IF(ISTAT.EQ.0)THEN
                 PRINT *,' !!!!!! DLCVAC WARNING : Field location'//
     -                ' code does not match geometry; please report.'
                 ISTAT=-4
            ENDIF
*   In a material.
       ELSEIF(ILOC.EQ.-5)THEN
            ISTAT=-5
*   Outside the mesh.
       ELSEIF(ILOC.EQ.-6)THEN
            ISTAT=-6
*   Other bizarre codes.
       ELSEIF(ILOC.NE.0)THEN
            PRINT *,' ###### DLCVAC ERROR   : Unexpected ILOC=',ILOC,
     -           ' received from EFIELD ; program bug, please report.'
            ISTAT=-3
       ENDIF
*   Always return if location code is non-zero.
       IF(ILOC.NE.0)RETURN
*** Check the initial status, establishing eg the target wire.
       CALL DLCSTA(Q,IPTYPE)
       IF(ISTAT.NE.0)RETURN
*** Set the initial step-size, ensure that the particle will move.
       POS(1)=DBLE(X1)
       POS(2)=DBLE(Y1)
       POS(3)=DBLE(Z1)
       VEL(1)=DBLE(VX1)
       VEL(2)=DBLE(VY1)
       VEL(3)=DBLE(VZ1)
       CALL DLCVFU(0.0D0,POS,VEL,ACC)
       IF(ACC(1)**2+ACC(2)**2+ACC(3)**2.GT.0)THEN
            H=100*(-SQRT(VEL(1)**2+VEL(2)**2+VEL(3)**2)+
     -           SQRT(VEL(1)**2+VEL(2)**2+VEL(3)**2+
     -           2*EPSDIF*SQRT(ACC(1)**2+ACC(2)**2+ACC(3)**2)))/
     -           SQRT(ACC(1)**2+ACC(2)**2+ACC(3)**2)
       ELSEIF(VEL(1)**2+VEL(2)**2+VEL(3)**2.GT.0)THEN
            H=100*EPSDIF/SQRT(VEL(1)**2+VEL(2)**2+VEL(3)**2)
       ELSE
            PRINT *,' !!!!!! DLCVAC WARNING : Drift line starts'//
     -           ' with zero velocity and zero acceleration;'//
     -           ' abandoned'
            ISTAT=-3
            RETURN
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   : Initial'',
     -      '' step size set to '',E10.3)') H
*** Allow INITCH cycles to adjust the initial step-size.
       INITCH=3
20     CONTINUE
       NU=1
*** Set the initial time, position, velocity and acceleration.
       TIME=0
       POS(1)=DBLE(X1)
       POS(2)=DBLE(Y1)
       POS(3)=DBLE(Z1)
       VEL(1)=DBLE(VX1)
       VEL(2)=DBLE(VY1)
       VEL(3)=DBLE(VZ1)
       CALL DLCVFU(0.0D0,POS,VEL,ACC)
*** Next step.
30     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   : Step '',
     -      I4/26X,''(x,y,z)='',3E12.5,'' t='',E12.5)') 
     -      NU,(POS(I),I=1,3),TIME
*   Reset location code.
       ILOCVF=0
*   Save old position.
       DO 40 I=1,3
       OLDPOS(I)=POS(I)
       OLDVEL(I)=VEL(I)
       OLDACC(I)=ACC(I)
40     CONTINUE
*** Take a Runge-Kutta-Nystroem step.
       CALL DRKNYS(3,H,TIME,POS,VEL,DLCVFU,WORK)
*** Make a trapezoid estimate of the same step.
       CALL DLCVFU(0.0D0,POS,VEL,ACC)
       DO 50 I=1,3
       TRAPEZ(I)=OLDPOS(I)+H*(VEL(I)+OLDVEL(I))/2+
     -      H**2*(ACC(I)+OLDACC(I))/8
50     CONTINUE
*** Check that the target wire is not crossed while exploring the field.
       IF(ITARG.GT.0.AND.ILOCVF.GT.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' DLCWIR entered from DLCVAC for ILOCVF='',I5)') 
     -           ILOCVF
            CALL DLCWIR(1,Q,IPTYPE)
            RETURN
       ENDIF
*** Check that no dielectric was entered nor that the mesh was left.
       IF(ICTYPE.EQ.0.AND.ILOCVF.NE.0)THEN
            CALL DLCFMP(OLDPOS(1),OLDPOS(2),OLDPOS(3),
     -           POS(1),POS(2),POS(3),H,ILOCVF,Q,IPTYPE)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Drift medium or mesh left at NU='',I4,
     -           '' ILOC='',I5)') NU,ILOCVF
            RETURN
*   Check for solids.
       ELSEIF(ICTYPE.EQ.-1.AND.ILOCVF.NE.0)THEN
            CALL DLCSOL(OLDPOS(1),OLDPOS(2),OLDPOS(3),
     -           POS(1),POS(2),POS(3),H,ILOCVF,Q,IPTYPE)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Drift medium or mesh left at NU='',I4,
     -           '' ILOC='',I5)') NU,ILOCVF
            RETURN
       ENDIF
*** Check particle position for other termination conditions.
       CALL DLCSTA(Q,IPTYPE)
       IF(ISTAT.NE.0)RETURN
*** Check bending angle.
       IF(LKINK.AND.NU.GT.1)THEN
            IF(VEL(1)*(XU(NU)-XU(NU-1))+VEL(2)*(YU(NU)-YU(NU-1))+
     -           VEL(3)*(ZU(NU)-ZU(NU-1)).LT.0)THEN
                 ISTAT=-8
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -                '' Step '',I3,'': bending angle exceeds pi/2.''/
     -                26X,''Velocity vector: '',3E15.8/
     -                26X,''Previous step:   '',3E15.8/
     -                26X,''Inner product:   '',E15.8)')
     -                NU+1,VEL(1),VEL(2),VEL(3),XU(NU)-XU(NU-1),
     -                YU(NU)-YU(NU-1),ZU(NU)-ZU(NU-1),
     -                VEL(1)*(XU(NU)-XU(NU-1))+
     -                VEL(2)*(YU(NU)-YU(NU-1))+
     -                VEL(3)*(ZU(NU)-ZU(NU-1))
                 RETURN
            ENDIF
       ENDIF
*** Copy new X0 and Y0 to XU and YU, add new TU.
       NU=NU+1
       XU(NU)=POS(1)
       YU(NU)=POS(2)
       ZU(NU)=POS(3)
       TU(NU)=TIME
*** Adjust step size by comparing trapezoid rule and RKN estimates.
       HPREV=H
       IF(POS(1).NE.TRAPEZ(1).OR.POS(2).NE.TRAPEZ(2).OR.
     -      POS(3).NE.TRAPEZ(3))THEN
            H=H*SQRT(EPSDIF/(ABS(POS(1)-TRAPEZ(1))+
     -           ABS(POS(2)-TRAPEZ(2))+ABS(POS(3)-TRAPEZ(3))))
       ELSE
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Step size increased by a factor 2 in step '',I4,
     -           '' (1st order = RKN).'')') NU
            H=H*2.0D0
       ENDIF
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -      '' 1st order: '',3E12.5/26X,''RKN:       '',3E12.5/26X,
     -      ''Step size changed by a factor '',E12.5,'' to '',E12.5)')
     -      (TRAPEZ(I),I=1,3),(POS(I),I=1,3),H/HPREV,H
*** Don't allow H to become too large in view of the time resolution.
       IF(H*ABS(VEL(1)).GT.(DXMAX-DXMIN)/10.0.OR.
     -      H*ABS(VEL(2)).GT.(DYMAX-DYMIN)/10.0.OR.
     -      H*ABS(VEL(3)).GT.(DZMAX-DZMIN)/10.0)THEN
            H=H/2
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Step size reduced by a factor 2 in step '',I4,
     -           '' (step too long).'')') NU
       ENDIF
*** Make sure that H is different from zero; this should always be ok.
       IF(H.EQ.0.0D0)THEN
            PRINT *,' ###### DLCVAC ERROR   : Step ',NU,' step size is',
     -           ' zero (program bug) ; the calculation is abandoned.'
            ISTAT=-3
            RETURN
       ENDIF
*** Check the initial step size.
       IF(INITCH.GT.0.AND.(H.LT.HPREV/5.0))THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Step size reinitialised, current value is '',
     -           E12.5)') H
            INITCH=INITCH-1
            GOTO 20
       ENDIF
       INITCH=0
*** Don't allow H to grow too quickly.
       IF(H.GT.10.0*HPREV)THEN
            H=10.0*HPREV
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Step size restricted to 10 x previous in step '',
     -           I4,''.'')') NU
       ENDIF
*** Make sure we haven't got more than MXLIST points already.
       IF(NU.EQ.MXLIST)THEN
            ISTAT=-2
            RETURN
       ENDIF
*** Stop in case H tends to become too small.
       IF(H*(ABS(VEL(1))+ABS(VEL(2))+ABS(VEL(3))).LT.EPSDIF)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVAC DEBUG   :'',
     -           '' Step size smaller than EPSDIF in step '',I4,
     -           '' ; line abandoned.'')') NU
            ISTAT=-3
            RETURN
       ENDIF
       GOTO 30
       END
CDECK  ID>, DLCVFU.
       SUBROUTINE DLCVFU(TIME,POS,VEL,ACC)
*-----------------------------------------------------------------------
*   DLCVFU - Computes the acceleration of a particle at time TIME,
*            location POS and initial velocity VEL.
*   (Last changed on 11/ 7/13.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL MAGOK
       REAL ALFA,B0X,B0Y,B0Z,SUSWIR,SUSGAS,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX
       INTEGER MAGSRC,
     -      IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z
       CHARACTER*(MXCHAR) FUNB0X,FUNB0Y,FUNB0Z
       COMMON /MAGDAT/ ALFA,SUSWIR,SUSGAS,
     -      B0X,B0Y,B0Z,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX,
     -      MAGSRC,IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z,
     -      MAGOK
       COMMON /MAGCHR/ FUNB0X,FUNB0Y,FUNB0Z
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION TIME,POS(3),VEL(3),ACC(3),FACTOR
       REAL EX,EY,EZ,ETOT,VOLT,BX,BY,BZ,BTOT,EOVERM
       INTEGER ILOCVF,ILOC
C       INTEGER I
       COMMON /VFUCOM/ EOVERM,ILOCVF
*** Compute the E and B fields.
       CALL EFIELD(REAL(POS(1)),REAL(POS(2)),REAL(POS(3)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       CALL BFIELD(REAL(POS(1)),REAL(POS(2)),REAL(POS(3)),
     -      BX,BY,BZ,BTOT)
*   If the point is located outside the drift area, set a flag.
       IF(ILOC.NE.0)THEN
            ILOCVF=ILOC
            ACC(1)=0
            ACC(2)=0
            ACC(3)=0
            RETURN
       ENDIF
* Units:
* mass - kg
* charge - C
* E - V/cm
* B - 0.01 T
*** Compute the relativistic correction and other common factors.
       FACTOR=1E-8*EOVERM*
     -      SQRT(1-(VEL(1)**2+VEL(2)**2+VEL(3)**2)/CLIGHT**2)
*** Compute the force/mass acting on the particle.
       ACC(1)=FACTOR*(EX + VEL(2)*BZ-VEL(3)*BY - 
     -      VEL(1)*(VEL(1)*EX + VEL(2)*EY + VEL(3)*EZ)/CLIGHT**2)
       ACC(2)=FACTOR*(EY + VEL(3)*BX-VEL(1)*BZ - 
     -      VEL(2)*(VEL(1)*EX + VEL(2)*EY + VEL(3)*EZ)/CLIGHT**2)
       ACC(3)=FACTOR*(EZ + VEL(1)*BY-VEL(2)*BX - 
     -      VEL(3)*(VEL(1)*EX + VEL(2)*EY + VEL(3)*EZ)/CLIGHT**2)
C       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCVFU DEBUG   : (x,y,z)='',
C     -      3E12.5/26X,''v      ='',3E12.5/26X,''a      ='',3E12.5)')
C     -      (POS(I),I=1,3),(VEL(I),I=1,3),(ACC(I),I=1,3)
       END
CDECK  ID>, DLCCAL.
       SUBROUTINE DLCCAL(INSTR,IFAIL)
*-----------------------------------------------------------------------
*   DLCCAL - Processes drift line related procedure calls.
*   (Last changed on 15/12/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       REAL XLIST(MXMCA),YLIST(MXMCA),ZLIST(MXMCA),TLIST(MXMCA),
     -      ELIST(MXMCA),
     -      XELIST(MXMCA),YELIST(MXMCA),ZELIST(MXMCA),TELIST(MXMCA)
       INTEGER NLIST(MXMCA),ISLIST(MXMCA),NMCA
       COMMON /MCAMAT/ XLIST,YLIST,ZLIST,TLIST,ELIST,
     -      XELIST,YELIST,ZELIST,TELIST,NLIST,ISLIST,NMCA
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       INTEGER INS(MXINS,4),ALGENT(MXALGE,10),MODREG(MXCONS:MXREG),
     -      ISYNCH,IINS0,ICONS0,ARGREF(MXARG,2),MODARG(MXARG),
     -      NREG,NCONS,NINS,NERR,NRES,NALGE,IENTRL,NAERR(100)
       REAL REG(MXCONS:MXREG),ARG(MXARG),EXPMAX
       PARAMETER(EXPMAX=40.0)
       LOGICAL EXEC(MXINS),LIGUND,LINUND
       COMMON /ALGDAT/ REG,ARG,MODARG,ARGREF,INS,MODREG,ALGENT,
     -      NREG,NCONS,NINS,NERR,NAERR,
     -      NRES,NALGE,IENTRL,ISYNCH,IINS0,ICONS0,EXEC,LIGUND,LINUND
       REAL MVEC(MXEMAT)
       INTEGER MSIZ(MXMAT,MXMDIM),MDIM(MXMAT),MREF(MXMAT+1),MMOD(MXMAT),
     -      MORG(MXMAT+1),MLEN(MXMAT+1),NREFL
       COMMON /MATDAT/ MVEC,MSIZ,MDIM,MMOD,MORG,MLEN,MREF,NREFL
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER MXAHIS
       PARAMETER(MXAHIS=20)
       INTEGER INPCMX,ISIZ(MXMDIM),IRX,IRY,IRZ,IRT,ISX,ISY,ISZ,IST,
     -      NCOPT,ISTR,NARG,IPROC,INSTR,IFAIL,IFAIL1,IFAIL2,IFAIL3,
     -      IFAIL4,NPAIR,I,J,MATSLT,IAUX,NC,NREXP,ITYPE(2,MXAHIS),NHIST,
     -      NETOT,NITOT,IENTRY(MXAHIS),IHIST(MXAHIS),ISW,ICL,ILOC,NC1,
     -      NC2,NC3,NC4,IPART,IRRVC,IRRMC,IRRVM,IREXC,ISEXC,IRION,ISION,
     -      IRCS,IHDIST,INEXT
       REAL XCLS,YCLS,ZCLS,ECLS,VXMIN,VYMIN,VXMAX,VYMAX,X0,Y0,Z0,Q,
     -      FDIV1,FDIV2,FDIV3,EXTRA1,EXRATE(MXEXG),IORATE(MXEXG),
     -      ESTART,EFINAL,DIRX,DIRY,DIRZ,RNDUNI,THETA0,THETA1,DELAY
       DOUBLE PRECISION XPOS1,YPOS1,XPOS2,YPOS2,F0(3)
       LOGICAL DONE,USE(MXVAR),STAT(4)
       EXTERNAL INPCMX,MATSLT,RNDUNI
       CHARACTER*(MXINCH) TITLE,OPT
       CHARACTER*15 AUX1,AUX2,AUX3,AUX4
       CHARACTER*10 VARLIS(16)
*** Assume the CALL will fail.
       IFAIL=1
*** Verify that we really have a cell and a gas.
       IF(.NOT.CELSET)THEN
            PRINT *,' !!!!!! DLCCAL WARNING : Cell data not available'//
     -           ' ; call not executed.'
            RETURN
       ELSEIF(.NOT.GASSET)THEN
            PRINT *,' !!!!!! DLCCAL WARNING : Gas data not available'//
     -           ' ; call not executed.'
            RETURN
       ENDIF
*** Some easy reference variables.
       NARG=INS(INSTR,3)
       IPROC=INS(INSTR,1)
*** Start a new track.
       IF(IPROC.EQ.-501)THEN
*   Warn if there are arguments.
            IF(NARG.NE.0)PRINT *,' !!!!!! DLCCAL WARNING : The'//
     -           ' NEW_TRACK procedure has no arguments; ignored.'
*   Reinitialise the track.
            CALL TRACLI
*** Get a new cluster.
       ELSEIF(IPROC.EQ.-502)THEN
*   Check the arguments.
            IF(NARG.LT.6.OR.NARG.GT.7.OR.
     -           ARGREF(1,1).GE.2.OR.ARGREF(2,1).GE.2.OR.
     -           ARGREF(3,1).GE.2.OR.ARGREF(4,1).GE.2.OR.
     -           ARGREF(5,1).GE.2.OR.
     -           (NARG.GE.7.AND.ARGREF(6,1).GE.2).OR.
     -           ARGREF(NARG,1).GE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for GET_CLUSTER; no cluster.'
                 RETURN
            ENDIF
*   Clean up space associated with the arguments.
            DO 40 ISTR=1,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
40          CONTINUE
*   Ask for a new cluster.
            CALL TRACLS(XCLS,YCLS,ZCLS,ECLS,NPAIR,EXTRA1,DONE,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Error ocurred'//
     -                ' during cluster generation; no data returned.'
                 RETURN
            ENDIF
*   Return the cluster position.
            ARG(1)=XCLS
            ARG(2)=YCLS
            ARG(3)=ZCLS
            MODARG(1)=2
            MODARG(2)=2
            MODARG(3)=2
*   Return the cluster size.
            ARG(4)=REAL(NPAIR)
            MODARG(4)=2
*   Return the cluster energy.
            ARG(5)=ECLS
            MODARG(5)=2
*   If there are extra fields, return them as 6th field.
            IF(NARG.GE.7)THEN
                 ARG(6)=EXTRA1
                 MODARG(6)=2
            ENDIF
*   Set the flag whether to continue or not.
            IF(DONE)THEN
                 ARG(NARG)=1
            ELSE
                 ARG(NARG)=0
            ENDIF
            MODARG(NARG)=3
*** Drift line calculation for electrons.
       ELSEIF(IPROC.EQ.-503)THEN
*   Check number of arguments.
            IF(NARG.LT.2.OR.NARG.GT.7)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ELECTRON.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ELECTRON are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.3.AND.ARGREF(3,1).GE.2).OR.
     -           (NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ELECTRON can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 270 ISTR=3,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
270         CONTINUE
*   Carry out the calculation.
            CALL DLCALC(ARG(1),ARG(2),0.0,-1.0,1)
*   Return status code.
            IF(NARG.GE.3)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(3)=REAL(IAUX)
                 MODARG(3)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ELECTRON.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(4)=TU(NU)
            ELSE
                 ARG(4)=0.0
            ENDIF
            IF(NARG.GE.5)CALL DLCDIF(ARG(5))
            IF(NARG.GE.6)CALL DLCTWN(ARG(6))
            IF(NARG.GE.7)CALL DLCATT(ARG(7))
            MODARG(4)=2
            MODARG(5)=2
            MODARG(6)=2
            MODARG(7)=2
*** Drift line calculation for positrons.
       ELSEIF(IPROC.EQ.-521)THEN
*   Check number of arguments.
            IF(NARG.LT.2.OR.NARG.GT.4)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_POSITRON.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_POSITRON are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.3.AND.ARGREF(3,1).GE.2).OR.
     -           (NARG.GE.4.AND.ARGREF(4,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_POSITRON can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 300 ISTR=3,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
300         CONTINUE
*   Carry out the calculation.
            CALL DLCALC(ARG(1),ARG(2),0.0,+1.0,1)
*   Return status code.
            IF(NARG.GE.3)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(3)=REAL(IAUX)
                 MODARG(3)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_POSITRON.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(4)=TU(NU)
            ELSE
                 ARG(4)=0.0
            ENDIF
            MODARG(4)=2
*** Drift line calculation for ions.
       ELSEIF(IPROC.EQ.-504.OR.IPROC.EQ.-514)THEN
*   Check number of arguments.
            IF(NARG.LT.2.OR.NARG.GT.4)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ION.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ION are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.3.AND.ARGREF(3,1).GE.2).OR.
     -           (NARG.GE.4.AND.ARGREF(4,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ION can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The mobility'//
     -                ' for ions is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            IF(NARG.GE.3)CALL ALGREU(NINT(ARG(3)),MODARG(3),ARGREF(3,1))
            IF(NARG.GE.4)CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
*   Carry out the calculation.
            IF(IPROC.EQ.-504)THEN
                 CALL DLCALC(ARG(1),ARG(2),0.0,+1.0,2)
            ELSE
                 CALL DLCALC(ARG(1),ARG(2),0.0,-1.0,2)
            ENDIF
*   Return status code.
            IF(NARG.GE.3)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(3)=REAL(IAUX)
                 MODARG(3)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ION.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(4)=TU(NU)
            ELSE
                 ARG(4)=0.0
            ENDIF
            MODARG(4)=2
*** 3D Drift line calculation for electrons.
       ELSEIF(IPROC.EQ.-505)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.8)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ELECTRON_3.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ELECTRON_3 are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2).OR.
     -           (NARG.GE.8.AND.ARGREF(8,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ELECTRON_3 can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 280 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
280         CONTINUE
*   Carry out the calculation.
            CALL DLCALC(ARG(1),ARG(2),ARG(3),-1.0,1)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ELECTRON_3.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            IF(NARG.GE.6)CALL DLCDIF(ARG(6))
            IF(NARG.GE.7)CALL DLCTWN(ARG(7))
            IF(NARG.GE.8)CALL DLCATT(ARG(8))
            MODARG(5)=2
            MODARG(6)=2
            MODARG(7)=2
            MODARG(8)=2
*** 3D Drift line calculation for positrons.
       ELSEIF(IPROC.EQ.-522)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.5)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_POSITRON_3.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_POSITRON_3 are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_POSITRON_3 can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 310 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
310         CONTINUE
*   Carry out the calculation.
            CALL DLCALC(ARG(1),ARG(2),ARG(3),+1.0,1)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_POSITRON_3.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            MODARG(5)=2
*** 3D Drift line calculation for ions.
       ELSEIF(IPROC.EQ.-506.OR.IPROC.EQ.-515)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.5)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ION_3.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ION_3 are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ION_3 can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The mobility'//
     -                ' for ions is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            IF(NARG.GE.4)CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            IF(NARG.GE.5)CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
*   Carry out the calculation.
            IF(IPROC.EQ.-506)THEN
                 CALL DLCALC(ARG(1),ARG(2),ARG(3),+1.0,2)
            ELSE
                 CALL DLCALC(ARG(1),ARG(2),ARG(3),-1.0,2)
            ENDIF
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ION_3.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            MODARG(5)=2
*** Get the drift line.
       ELSEIF(IPROC.EQ.-507)THEN
*   Check the arguments.
            IF(NARG.LT.1.OR.NARG.GT.4.OR.
     -           (NARG.GE.1.AND.ARGREF(1,1).GE.2).OR.
     -           (NARG.GE.2.AND.ARGREF(2,1).GE.2).OR.
     -           (NARG.GE.3.AND.ARGREF(3,1).GE.2).OR.
     -           (NARG.GE.4.AND.ARGREF(4,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect argument'//
     -                ' list for GET_DRIFT_LINE.'
                 RETURN
            ELSEIF(ISTAT.EQ.0.OR.NU.LT.1)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : No drift line in'//
     -                ' memory currently.'
                 RETURN
            ENDIF
*   Clear the arguments.
            IF(NARG.GE.1)CALL ALGREU(NINT(ARG(1)),MODARG(1),ARGREF(1,1))
            IF(NARG.GE.2)CALL ALGREU(NINT(ARG(2)),MODARG(2),ARGREF(2,1))
            IF(NARG.GE.3)CALL ALGREU(NINT(ARG(3)),MODARG(3),ARGREF(3,1))
            IF(NARG.GE.4)CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
*   Allocate matrices.
            ISIZ(1)=NU
            IF(NARG.GE.1)THEN
                 CALL MATADM('ALLOCATE',IRX,1,ISIZ,2,IFAIL1)
            ELSE
                 IFAIL1=0
            ENDIF
            IF(NARG.GE.2)THEN
                 CALL MATADM('ALLOCATE',IRY,1,ISIZ,2,IFAIL2)
            ELSE
                 IFAIL2=0
            ENDIF
            IF(NARG.GE.3)THEN
                 CALL MATADM('ALLOCATE',IRZ,1,ISIZ,2,IFAIL3)
            ELSE
                 IFAIL3=0
            ENDIF
            IF(NARG.GE.4)THEN
                 CALL MATADM('ALLOCATE',IRT,1,ISIZ,2,IFAIL4)
            ELSE
                 IFAIL4=0
            ENDIF
            IF(NARG.GE.1)THEN
                 ISX=MATSLT(IRX)
            ELSE
                 ISX=1
            ENDIF
            IF(NARG.GE.2)THEN
                 ISY=MATSLT(IRY)
            ELSE
                 ISY=1
            ENDIF
            IF(NARG.GE.3)THEN
                 ISZ=MATSLT(IRZ)
            ELSE
                 ISZ=1
            ENDIF
            IF(NARG.GE.4)THEN
                 IST=MATSLT(IRT)
            ELSE
                 IST=1
            ENDIF
            IF(IFAIL1.NE.0.OR.ISX.LE.0.OR.IFAIL2.NE.0.OR.ISY.LE.0.OR.
     -           IFAIL3.NE.0.OR.ISZ.LE.0.OR.IFAIL4.NE.0.OR.IST.LE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to allocate'//
     -                ' output matrices for GET_DRIFT_LINE.'
                 RETURN
            ENDIF
*   Copy the vectors.
            DO 10 I=1,NU
            IF(NARG.GE.1)MVEC(MORG(ISX)+I)=REAL(XU(I))
            IF(NARG.GE.2)MVEC(MORG(ISY)+I)=REAL(YU(I))
            IF(NARG.GE.3)MVEC(MORG(ISZ)+I)=REAL(ZU(I))
            IF(NARG.GE.4)MVEC(MORG(IST)+I)=REAL(TU(I))
10          CONTINUE
*   Save the vectors.
            IF(NARG.GE.1)THEN
                 ARG(1)=IRX
                 MODARG(1)=5
            ENDIF
            IF(NARG.GE.2)THEN
                 ARG(2)=IRY
                 MODARG(2)=5
            ENDIF
            IF(NARG.GE.3)THEN
                 ARG(3)=IRZ
                 MODARG(3)=5
            ENDIF
            IF(NARG.GE.4)THEN
                 ARG(4)=IRT
                 MODARG(4)=5
            ENDIF
*** 3D MC drift line calculation for electrons.
       ELSEIF(IPROC.EQ.-508)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.7)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ELECTRON_MC.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ELECTRON_MC are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ELECTRON_MC can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 20 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
20          CONTINUE
*   Carry out the calculation.
            CALL DLCMC(ARG(1),ARG(2),ARG(3),-1.0,1)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ELECTRON_MC.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            IF(NARG.GE.6)CALL DLCTWN(ARG(6))
            IF(NARG.GE.7)CALL DLCATT(ARG(7))
            MODARG(5)=2
            MODARG(6)=2
            MODARG(7)=2
*** 3D MC test drift line calculation for electrons.
       ELSEIF(IPROC.EQ.-519)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.7)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_MC_TEST.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_MC_TEST are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_MC_TEST can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 21 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
21          CONTINUE
*   Carry out the calculation.
            CALL DLCMC3(ARG(1),ARG(2),ARG(3),-1.0,1)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_MC_TEST.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            IF(NARG.GE.6)CALL DLCTWN(ARG(6))
            IF(NARG.GE.7)CALL DLCATT(ARG(7))
            MODARG(5)=2
            MODARG(6)=2
            MODARG(7)=2
*** 3D MC drift line calculation for electrons.
       ELSEIF(IPROC.EQ.-523)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.5)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_MC_POSITRON.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_MC_POSITRON are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_MC_POSITRON can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 320 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
320         CONTINUE
*   Carry out the calculation.
            CALL DLCMC(ARG(1),ARG(2),ARG(3),+1.0,1)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_MC_POSITRON.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            MODARG(5)=2
*** 3D MC drift line calculation for ions.
       ELSEIF(IPROC.EQ.-509.OR.IPROC.EQ.-516)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.GT.5)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_ION_MC.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_ION_MC are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_ION_MC can not be modified.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The mobility'//
     -                ' for ions is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
*   Carry out the calculation.
            IF(IPROC.EQ.-509)THEN
                 CALL DLCMC(ARG(1),ARG(2),ARG(3),+1.0,2)
            ELSE
                 CALL DLCMC(ARG(1),ARG(2),ARG(3),-1.0,2)
            ENDIF
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_ION_MC.'
            ENDIF
*   Compute and return requested numerical data.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            MODARG(5)=2
*** Drift line calculation in vacuum for electrons.
       ELSEIF(IPROC.EQ.-517)THEN
*   Check number of arguments.
            IF(NARG.LT.6.OR.NARG.GT.8)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_VACUUM_ELECTRON.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2.OR.MODARG(4).NE.2.OR.
     -           MODARG(5).NE.2.OR.MODARG(6).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_VACUUM_ELECTRON are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.7.AND.ARGREF(7,1).GE.2).OR.
     -           (NARG.GE.8.AND.ARGREF(8,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_VACUUM_ELECTRON can not be modified.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 290 ISTR=7,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
290         CONTINUE
*   Carry out the calculation.
            CALL DLCVAC(ARG(1),ARG(2),ARG(3),ARG(4),ARG(5),ARG(6),
     -           -1.0,EMASS/MEV2KG)
*   Return status code.
            IF(NARG.GE.7)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(7)=REAL(IAUX)
                 MODARG(7)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing a string for'//
     -                ' DRIFT_VACUUM_ELECTRON.'
            ENDIF
*   Return drift time.
            IF(NARG.GE.8)THEN
                 IF(NU.GE.1)THEN
                      ARG(8)=TU(NU)
                 ELSE
                      ARG(8)=0.0
                 ENDIF
                 MODARG(8)=2
            ENDIF
*** Drift line calculation in vacuum for ions.
       ELSEIF(IPROC.EQ.-518)THEN
*   Check number of arguments.
            IF(NARG.LT.8.OR.NARG.GT.10)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_VACUUM_ION.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -           MODARG(3).NE.2.OR.MODARG(4).NE.2.OR.
     -           MODARG(5).NE.2.OR.MODARG(6).NE.2.OR.
     -           MODARG(7).NE.2.OR.MODARG(8).NE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_VACUUM_ION are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.9.AND.ARGREF(9,1).GE.2).OR.
     -           (NARG.GE.10.AND.ARGREF(10,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_VACUUM_ION can not be modified.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 291 ISTR=9,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
291         CONTINUE
*   Carry out the calculation.
            CALL DLCVAC(ARG(1),ARG(2),ARG(3),ARG(4),ARG(5),ARG(6),
     -           ARG(7),ARG(8))
*   Return status code.
            IF(NARG.GE.9)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(9)=REAL(IAUX)
                 MODARG(9)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing a string for'//
     -                ' DRIFT_VACUUM_ION.'
            ENDIF
*   Return drift time.
            IF(NARG.GE.10)THEN
                 IF(NU.GE.1)THEN
                      ARG(10)=TU(NU)
                 ELSE
                      ARG(10)=0.0
                 ENDIF
                 MODARG(10)=2
            ENDIF
*** Plot the drift line.
       ELSEIF(IPROC.EQ.-510)THEN
*   There are no arguments for this procedure.
            IF(NARG.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -           ' PLOT_DRIFT_LINE has no arguments; ignored.'
*   Save the drift line.
            CALL DLCBCK('SAVE')
*   Plot the requested projection.
            CALL DLCPLT
*   Restore the drift line.
            CALL DLCBCK('RESTORE')
*** Plot the track.
       ELSEIF(IPROC.EQ.-511)THEN
*   Warn if there are arguments.
            IF(NARG.NE.0)PRINT *,' !!!!!! DLCCAL WARNING : The'//
     -           '  PLOT_TRACK procedure has no arguments; ignored.'
*   Plot the track.
            CALL TRAPLT
*** 3D MC drift line calculation for electrons with avalanche.
       ELSEIF(IPROC.EQ.-512)THEN
**  Check number of arguments.
            IF(NARG.LT.3.OR.
     -           (NARG.GE.4.AND.MODARG(4).NE.1).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.NARG.NE.2*(NARG/2)).OR.
     -           NARG.GT.6+2*MXAHIS)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect list of'//
     -                ' arguments for AVALANCHE; not executed'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
*   Make sure there are Townsend coefficients.
            ELSEIF(.NOT.GASOK(4))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The Townsend'//
     -                ' coefficient is not defined ; not executed.'
                 RETURN
            ENDIF
**  Fetch the option string.
            IF(NARG.GE.4)THEN
                 CALL STRBUF('READ',NINT(ARG(4)),OPT,NCOPT,IFAIL1)
                 CALL CLTOU(OPT(1:NCOPT))
            ELSE
                 OPT=' '
                 NCOPT=1
            ENDIF
**  Liberate storage associated with the electron and ion count.
            IF(NARG.GE.5)CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
            IF(NARG.GE.6)CALL ALGREU(NINT(ARG(6)),MODARG(6),ARGREF(6,1))
**  Create the entry point for the histogram formulae.
            IF(NARG.GE.7)THEN
*   Initialise the usage list.
                 STAT(1)=.FALSE.
                 STAT(2)=.FALSE.
                 STAT(3)=.FALSE.
                 STAT(4)=.FALSE.
*   Establish the variable list.
                 IF(POLAR)THEN
                      VARLIS(1)= 'R_CREATED'
                      VARLIS(5)= 'R_LOST'
                      VARLIS(9)= 'R_E'
                      VARLIS(13)='R_ION'
                      VARLIS(2)= 'PHI_CREATED'
                      VARLIS(6)= 'PHI_LOST'
                      VARLIS(10)='PHI_E'
                      VARLIS(14)='PHI_ION'
                 ELSE
                      VARLIS(1)= 'X_CREATED'
                      VARLIS(5)= 'X_LOST'
                      VARLIS(9)= 'X_E'
                      VARLIS(13)='X_ION'
                      VARLIS(2)= 'Y_CREATED'
                      VARLIS(6)= 'Y_LOST'
                      VARLIS(10)='Y_E'
                      VARLIS(14)='Y_ION'
                 ENDIF
                 VARLIS(3)= 'Z_CREATED'
                 VARLIS(7)= 'Z_LOST'
                 VARLIS(11)='Z_E'
                 VARLIS(15)='Z_ION'
                 VARLIS(4)= 'T_CREATED'
                 VARLIS(8)= 'T_LOST'
                 VARLIS(12)='T_E'
                 VARLIS(16)='T_ION'
*   Number of histograms.
                 NHIST=NARG/2-3
*   Loop over the histograms.
                 DO 30 I=1,NHIST
*   Fetch the histogram string.
                 CALL STRBUF('READ',NINT(ARG(5+2*I)),TITLE,NC,IFAIL1)
                 IF(IFAIL1.NE.0.OR.NC.LT.1)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Unable to get'//
     -                     ' an histogram formula; no avalanche.'
                      RETURN
                 ENDIF
                 CALL CLTOU(TITLE(1:NC))
*   Translate the formula.
                 CALL ALGPRE(TITLE(1:NC),NC,VARLIS,16,NREXP,USE,
     -                IENTRY(I),IFAIL1)
                 IF(IFAIL1.NE.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : The histogram'//
     -                     ' function '//TITLE(1:NC)//' can not be'//
     -                     ' translated; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(NREXP.LT.1.OR.NREXP.GT.2)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : The histogram'//
     -                     ' function '//TITLE(1:NC)//' does not'//
     -                     ' return 1 or 2 results; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ENDIF
                 ITYPE(2,I)=NREXP
*   Work out which quantities are to be computed.
                 ITYPE(1,I)=0
                 IF((USE( 1).OR.USE( 2).OR.USE( 3).OR.USE( 4)).AND.
     -                ITYPE(1,I).NE.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' function '//TITLE(1:NC)//' uses an'//
     -                     ' invalid mix of parameters; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(USE( 1).OR.USE( 2).OR.USE( 3).OR.USE( 4))THEN
                      ITYPE(1,I)=1
                 ENDIF
                 IF((USE( 5).OR.USE( 6).OR.USE( 7).OR.USE( 8)).AND.
     -                ITYPE(1,I).NE.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' function '//TITLE(1:NC)//' uses an'//
     -                     ' invalid mix of parameters; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(USE( 5).OR.USE( 6).OR.USE( 7).OR.USE( 8))THEN
                      ITYPE(1,I)=2
                 ENDIF
                 IF((USE( 9).OR.USE(10).OR.USE(11).OR.USE(12)).AND.
     -                ITYPE(1,I).NE.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' function '//TITLE(1:NC)//' uses an'//
     -                     ' invalid mix of parameters; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(USE( 9).OR.USE(10).OR.USE(11).OR.USE(12))THEN
                      ITYPE(1,I)=3
                 ENDIF
                 IF((USE(13).OR.USE(14).OR.USE(15).OR.USE(16)).AND.
     -                ITYPE(1,I).NE.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' function '//TITLE(1:NC)//' uses an'//
     -                     ' invalid mix of parameters; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(USE(13).OR.USE(14).OR.USE(15).OR.USE(16))THEN
                      ITYPE(1,I)=4
                 ENDIF
                 IF(ITYPE(1,I).EQ.0)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' function '//TITLE(1:NC)//' uses no'//
     -                     ' variables; no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ENDIF
                 STAT(1)=STAT(1).OR.(ITYPE(1,I).EQ.1)
                 STAT(2)=STAT(2).OR.(ITYPE(1,I).EQ.2)
                 STAT(3)=STAT(3).OR.(ITYPE(1,I).EQ.3)
                 STAT(4)=STAT(4).OR.(ITYPE(1,I).EQ.4)
*   Generate the histogram index list and check the number.
                 IF(ARGREF(6+2*I,1).GE.2)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Histogram'//
     -                     ' argument ',I,' can not be modified;'//
     -                     ' no avalanche.'
                      CALL ALGCLR(IENTRY(I))
                      RETURN
                 ELSEIF(MODARG(6+2*I).EQ.4)THEN
                      IHIST(I)=NINT(ARG(6+2*I))
                 ELSE
                      CALL ALGREU(NINT(ARG(6+2*I)),MODARG(6+2*I),
     -                     ARGREF(6+2*I,1))
                      CALL HISADM('ALLOCATE',IHIST(I),100,0.0,0.0,
     -                     .TRUE.,IFAIL1)
                 ENDIF
30               CONTINUE
*   No histograms to be made.
            ELSE
                 STAT(1)=.FALSE.
                 STAT(2)=.FALSE.
                 STAT(3)=.FALSE.
                 STAT(4)=.FALSE.
                 NHIST=0
            ENDIF
**  Carry out the calculation.
            CALL DLCMCA(ARG(1),ARG(2),ARG(3),NETOT,NITOT,
     -           STAT,NHIST,IHIST,ITYPE,IENTRY,OPT(1:NCOPT))
*   Print algebra errors if there were any.
            CALL ALGERR
**  Return the arguments and delete the instruction lists.
            IF(NARG.GE.5)THEN
                 ARG(5)=REAL(NETOT)
                 MODARG(5)=2
            ENDIF
            IF(NARG.GE.6)THEN
                 ARG(6)=REAL(NITOT)
                 MODARG(6)=2
            ENDIF
            DO 50 I=1,NHIST
            ARG(6+2*I)=REAL(IHIST(I))
            MODARG(6+2*I)=4
            CALL ALGCLR(IENTRY(I))
50          CONTINUE
*** Plot the drift area.
       ELSEIF(IPROC.EQ.-513)THEN
*   Check arguments.
            IF((NARG.NE.0.AND.NARG.NE.1).OR.
     -           (NARG.EQ.1.AND.MODARG(1).NE.1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect list'//
     -                ' of arguments for PLOT_DRIFT_AREA; no plot.'
                 RETURN
            ENDIF
*   See whether there is a title.
            IF(NARG.EQ.1)THEN
                 CALL STRBUF('READ',NINT(ARG(1)),TITLE,NC,IFAIL1)
            ELSEIF(CELLID.EQ.' ')THEN
                 TITLE='Layout of the cell'
                 NC=18
            ELSE
                 TITLE=CELLID
                 NC=LEN(CELLID)
            ENDIF
*   Plot the frame.
            CALL GRASET(DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX)
            CALL GRCELL(VXMIN,VYMIN,VXMAX,VYMAX,TITLE(1:NC))
            IF(GASID.NE.' ')CALL GRCOMM(2,'Gas: '//GASID)
*** Return the status code and other pieces of information.
       ELSEIF(IPROC.EQ.-520)THEN
            IF(NARG.LT.2.OR.2*(NARG/2).NE.NARG)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : DRIFT_INFORMATION'//
     -                ' received an odd number of arguments;'//
     -                ' procedure not called.'
                 RETURN
            ELSEIF(NU.LT.1)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The current'//
     -                ' drift line has no steps; DRIFT_INFORMATION'//
     -                ' not executed.'
                 RETURN
            ENDIF
*   Loop over the options.
            DO 80 I=1,NARG-1,2
*   Check the argument type.
            IF(MODARG(I).NE.1)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Argument ',I,' of',
     -                ' DRIFT_INFORMATION is not of type String; no',
     -                ' value returned.'
                 GOTO 80
            ENDIF
*   Fetch option.
            CALL STRBUF('READ',NINT(ARG(I)),TITLE,NC,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Error retrieving'//
     -                ' the DRIFT_INFORMATION option.'
                 GOTO 80
            ENDIF
            IF(NC.GE.1)CALL CLTOU(TITLE(1:NC))
*   Check we can return a value.
            IF(ARGREF(I+1,1).GE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Can not return'//
     -                ' a value for '//TITLE(1:NC)//' because the'//
     -                ' following argument is not modifiable.'
                 GOTO 80
            ENDIF
*   Delete old contents of return variable.
            CALL ALGREU(NINT(ARG(I+1)),MODARG(I+1),ARGREF(I+1,1))
*   Total drift time.
            IF(INPCMX(TITLE(1:NC),'DR#IFT-T#IME')+
     -           INPCMX(TITLE(1:NC),'TIME').NE.0)THEN
                 IF(NU.GE.1)THEN
                      ARG(I+1)=TU(NU)
                 ELSE
                      ARG(I+1)=0.0
                 ENDIF
                 MODARG(I+1)=2
*   Charge of the particle.
            ELSEIF(INPCMX(TITLE(1:NC),'CHA#RGE').NE.0)THEN
                 ARG(I+1)=QPCHAR
                 MODARG(I+1)=2
*   Particle being drifted.
            ELSEIF(INPCMX(TITLE(1:NC),'PART#ICLE').NE.0)THEN
                 IF(IPTYPE.EQ.1)THEN
                      CALL STRBUF('STORE',IAUX,'electron',8,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSEIF(IPTYPE.EQ.2)THEN
                      CALL STRBUF('STORE',IAUX,'ion',3,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSE
                      CALL STRBUF('STORE',IAUX,'unknown',7,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ENDIF
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the DRIFT_INFORMATION result.'
*   Integration technique used.
            ELSEIF(INPCMX(TITLE(1:NC),'TECH#NIQUE').NE.0)THEN
                 IF(IPTECH.EQ.1)THEN
                      CALL STRBUF('STORE',IAUX,'Runge-Kutta-Fehlberg',
     -                     20,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSEIF(IPTECH.EQ.2)THEN
                      CALL STRBUF('STORE',IAUX,'Monte-Carlo',11,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSEIF(IPTECH.EQ.3)THEN
                      CALL STRBUF('STORE',IAUX,'vacuum',6,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSEIF(IPTECH.EQ.4)THEN
                      CALL STRBUF('STORE',IAUX,'microscopic',11,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ELSE
                      CALL STRBUF('STORE',IAUX,'unknown',7,IFAIL1)
                      ARG(I+1)=REAL(IAUX)
                      MODARG(I+1)=1
                 ENDIF
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the DRIFT_INFORMATION result.'
*   Numeric status code.
            ELSEIF(INPCMX(TITLE(1:NC),'STAT#US-#CODE').NE.0)THEN
                 ARG(I+1)=REAL(ISTAT)
                 MODARG(I+1)=2
*   Electrode group.
            ELSEIF(INPCMX(TITLE(1:NC),'ELEC#TRODE').NE.0)THEN
                 CALL DLCISW(ISTAT,ISW)
                 ARG(I+1)=REAL(ISW)
                 MODARG(I+1)=2
*   String status code.
            ELSEIF(INPCMX(TITLE(1:NC),'STAT#US-#STRING').NE.0)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(I+1)=REAL(IAUX)
                 MODARG(I+1)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the DRIFT_INFORMATION result.'
*   Number of steps.
            ELSEIF(INPCMX(TITLE(1:NC),'STEP#S').NE.0)THEN
                 ARG(I+1)=REAL(NU)
                 MODARG(I+1)=2
*   Path length.
            ELSEIF(INPCMX(TITLE(1:NC),'PATH-#LENGTH')+
     -           INPCMX(TITLE(1:NC),'LENGTH').NE.0)THEN
                 ARG(I+1)=0.0
                 DO 70 J=2,NU
                 IF(POLAR)THEN
                      CALL CF2RTC(XU(J-1),YU(J-1),XPOS1,YPOS1,1)
                      CALL CF2RTC(XU(J)  ,YU(J)  ,XPOS2,YPOS2,1)
                      ARG(I+1)=ARG(I+1)+SQRT((XPOS2-XPOS1)**2+
     -                     (YPOS2-YPOS1)**2+(ZU(J)-ZU(J-1))**2)
                 ELSE
                      ARG(I+1)=ARG(I+1)+SQRT((XU(J)-XU(J-1))**2+
     -                     (YU(J)-YU(J-1))**2+(ZU(J)-ZU(J-1))**2)
                 ENDIF
70               CONTINUE
                 MODARG(I+1)=2
*   Start/end points.
            ELSEIF(INPCMX(TITLE(1:NC),'X-ST#ART')+
     -           INPCMX(TITLE(1:NC),'X_ST#ART')+
     -           INPCMX(TITLE(1:NC),'XST#ART').NE.0)THEN
                 ARG(I+1)=XU(1)
                 MODARG(I+1)=2
            ELSEIF(INPCMX(TITLE(1:NC),'X-END')+
     -           INPCMX(TITLE(1:NC),'X_END')+
     -           INPCMX(TITLE(1:NC),'XEND').NE.0)THEN
                 IF(NU.GE.1)THEN
                      ARG(I+1)=XU(NU)
                 ELSE
                      ARG(I+1)=0.0
                 ENDIF
                 MODARG(I+1)=2
            ELSEIF(INPCMX(TITLE(1:NC),'Y-START')+
     -           INPCMX(TITLE(1:NC),'Y_ST#ART')+
     -           INPCMX(TITLE(1:NC),'YST#ART').NE.0)THEN
                 ARG(I+1)=YU(1)
                 MODARG(I+1)=2
            ELSEIF(INPCMX(TITLE(1:NC),'Y-END')+
     -           INPCMX(TITLE(1:NC),'Y_END')+
     -           INPCMX(TITLE(1:NC),'YEND').NE.0)THEN
                 IF(NU.GE.1)THEN
                      ARG(I+1)=YU(NU)
                 ELSE
                      ARG(I+1)=0.0
                 ENDIF
                 MODARG(I+1)=2
            ELSEIF(INPCMX(TITLE(1:NC),'Z-START')+
     -           INPCMX(TITLE(1:NC),'Z_ST#ART')+
     -           INPCMX(TITLE(1:NC),'ZST#ART').NE.0)THEN
                 ARG(I+1)=ZU(1)
                 MODARG(I+1)=2
            ELSEIF(INPCMX(TITLE(1:NC),'Z-END')+
     -           INPCMX(TITLE(1:NC),'Z_END')+
     -           INPCMX(TITLE(1:NC),'ZEND').NE.0)THEN
                 IF(NU.GE.1)THEN
                      ARG(I+1)=ZU(NU)
                 ELSE
                      ARG(I+1)=0.0
                 ENDIF
                 MODARG(I+1)=2
*   Unknown things.
            ELSE
                 PRINT *,' !!!!!! DLCCAL WARNING : Unknown item "'//
     -                TITLE(1:NC)//'" received ; no return value.'
            ENDIF
80          CONTINUE
*** Return the status code and other pieces of information.
       ELSEIF(IPROC.EQ.-535)THEN
            IF(NMCA.LT.1)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The current'//
     -                ' avalanche is empty; AVALANCHE_INFORMATION'//
     -                ' not executed.'
                 RETURN
            ENDIF
**  Loop over the options.
            INEXT=1
            DO 90 I=1,NARG
            IF(I.LT.INEXT)GOTO 90
*   Check the argument type.
            IF(MODARG(I).NE.1)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Argument ',I,' of'//
     -                ' AVALANCHE_INFORMATION is not of type String;'//
     -                ' no value returned.'
                 GOTO 90
            ENDIF
*   Fetch the option.
            CALL STRBUF('READ',NINT(ARG(I)),TITLE,NC,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Error retrieving'//
     -                ' the AVALANCHE_INFORMATION option.'
                 GOTO 90
            ENDIF
            IF(NC.GE.1)THEN
                 CALL CLTOU(TITLE(1:NC))
            ELSE
                 PRINT *,' !!!!!! DLCCAL WARNING : Retrieving empty'//
     -                ' AVALANCHE_INFORMATION option; ignored.'
                 GOTO 90
            ENDIF
**  Number of electrons
            IF(INPCMX(TITLE(1:NC),'ELEC#TRONS').NE.0)THEN
                 IF(I+1.GT.NARG)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Not enough'//
     -                     ' arguments for AVALANCHE_INFORMATION;'//
     -                     ' data not returned.'
                      GOTO 90
                 ELSEIF(ARGREF(I+1,1).GE.2)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Can not'//
     -                     ' return a value for '//TITLE(1:NC)//
     -                     ' because the following argument is not'//
     -                     ' modifiable.'
                      GOTO 90
                 ENDIF
*   Delete old contents of return variable.
                 CALL ALGREU(NINT(ARG(I+1)),MODARG(I+1),ARGREF(I+1,1))
*   Store the value
                 ARG(I+1)=REAL(NMCA)
                 MODARG(I+1)=2
*   Next field
                 INEXT=I+2
**  Starting and end points: get the electron number
            ELSEIF(INPCMX(TITLE(1:NC),'X-ST#ART')+
     -           INPCMX(TITLE(1:NC),'Y-ST#ART')+
     -           INPCMX(TITLE(1:NC),'Z-ST#ART')+
     -           INPCMX(TITLE(1:NC),'T-ST#ART')+
     -           INPCMX(TITLE(1:NC),'X-END')+
     -           INPCMX(TITLE(1:NC),'Y-END')+
     -           INPCMX(TITLE(1:NC),'Z-END')+
     -           INPCMX(TITLE(1:NC),'T-END')+
     -           INPCMX(TITLE(1:NC),'ST#ATUS-#CODE')+
     -           INPCMX(TITLE(1:NC),'ST#ATUS-#STRING').NE.0)THEN
                 IF(I+2.GT.NARG)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Not enough'//
     -                     ' arguments for AVALANCHE_INFORMATION;'//
     -                     ' data not returned.'
                      GOTO 90
                 ELSEIF(MODARG(I+1).NE.2)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Argument ',I+1,
     -                     ' of AVALANCHE_INFORMATION not a number;'//
     -                     ' data not returned.'
                      GOTO 90
                 ELSEIF(NINT(ARG(I+1)).LT.1.OR.
     -                NINT(ARG(I+1)).GT.NMCA)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Argument ',I+1,
     -                     ' of AVALANCHE_INFORMATION is out of'//
     -                     ' range; data not returned.'
                      GOTO 90
                 ELSEIF(ARGREF(I+2,1).GE.2)THEN
                      PRINT *,' !!!!!! DLCCAL WARNING : Can not'//
     -                     ' return a value for '//TITLE(1:NC)//
     -                     ' because the following argument is not'//
     -                     ' modifiable.'
                      GOTO 90
                 ENDIF
*   Delete old contents of return variable.
                 CALL ALGREU(NINT(ARG(I+2)),MODARG(I+2),ARGREF(I+2,1))
*   Return the desired value.
                 IF(INPCMX(TITLE(1:NC),'X-ST#ART').NE.0)THEN
                      ARG(I+2)=100.0*XLIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'Y-ST#ART').NE.0)THEN
                      ARG(I+2)=100.0*YLIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'Z-ST#ART').NE.0)THEN
                      ARG(I+2)=100.0*ZLIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'T-ST#ART').NE.0)THEN
                      ARG(I+2)=1.0E-6*TLIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'X-END').NE.0)THEN
                      ARG(I+2)=100.0*XELIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'Y-END').NE.0)THEN
                      ARG(I+2)=100.0*YELIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'Z-END').NE.0)THEN
                      ARG(I+2)=100.0*ZELIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'T-END').NE.0)THEN
                      ARG(I+2)=1.0E-6*TELIST(NINT(ARG(I+1)))
                      MODARG(I+2)=2
                 ELSEIF(INPCMX(TITLE(1:NC),'ST#ATUS-#STRING').NE.0)THEN
                      CALL DLCSTF(ISLIST(NINT(ARG(I+1))),OPT,NCOPT)
                      CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                      ARG(I+2)=REAL(IAUX)
                      MODARG(I+2)=1
                      IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING'//
     -                     ' : Error storing the'//
     -                     ' AVALANCHE_INFORMATION result.'
                 ELSEIF(INPCMX(TITLE(1:NC),'ST#ATUS-#CODE').NE.0)THEN
                      ARG(I+2)=REAL(ISLIST(NINT(ARG(I+1))))
                      MODARG(I+2)=2
                 ENDIF
*   Set next I value
                 INEXT=I+3
            ELSE
                 PRINT *,' !!!!!! DLCCAL WARNING : Unknown option '//
     -                TITLE(1:NC)//' for AVALANCHE_INFORMATION;'//
     -                ' data not returned.'
                 GOTO 90
            ENDIF
90          CONTINUE
*** Interpolate in a track.
       ELSEIF(IPROC.EQ.-524)THEN
*   Check the arguments.
            IF(NARG.LT.4.OR.NARG.GT.9.OR.
     -           MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.MODARG(3).NE.2.OR.
     -           (NARG.GE.4.AND.ARGREF(4,1).GE.2).OR.
     -           (NARG.GE.5.AND.ARGREF(5,1).GE.2).OR.
     -           (NARG.GE.6.AND.ARGREF(6,1).GE.2).OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2).OR.
     -           (NARG.GE.8.AND.ARGREF(8,1).GE.2).OR.
     -           (NARG.GE.9.AND.ARGREF(9,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' INTERPOLATE_TRACK of wrong type or not'//
     -                ' modifiable; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 330 ISTR=4,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
330         CONTINUE
*   Perform the interpolation.
            CALL DLCTRI(ARG(1),ARG(2),ARG(3),
     -           ARG(5),ICL,ARG(6),ARG(7),ARG(8),ARG(9),
     -           NARG.GE.6,NARG.GE.7,NARG.GE.8,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Interpolating the'//
     -                ' track failed; no values returned.'
                 DO 340 ISTR=4,NARG
                 MODARG(ISTR)=0
340              CONTINUE
                 RETURN
            ENDIF
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ICL,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for INTERPOLATE_TRACK.'
            ENDIF
*   Set the modes of the arguments.
            MODARG(5)=2
            MODARG(6)=2
            MODARG(7)=2
            MODARG(8)=2
            MODARG(9)=2
*** Avalanche.
       ELSEIF(IPROC.EQ.-525)THEN
            IF(NARG.LT.1.OR.NARG.GT.2.OR.
     -           (NARG.GE.1.AND.ARGREF(1,1).GE.2).OR.
     -           (NARG.GE.2.AND.ARGREF(2,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for RND_MULTIPLICATION; not executed.'
                 RETURN
            ENDIF
*   Call the routine.
            CALL DLCMCT(NETOT,NITOT)
*   Clear the return space.
            DO 60 I=1,NARG
            CALL ALGREU(NINT(ARG(I)),MODARG(I),ARGREF(I,1))
60          CONTINUE
*   Return the results.
            IF(NARG.GE.1)THEN
                 ARG(1)=REAL(NETOT)
                 MODARG(1)=2
            ENDIF
            IF(NARG.GE.2)THEN
                 ARG(2)=REAL(NITOT)
                 MODARG(2)=2
            ENDIF
*** Velocity vector for electrons.
       ELSEIF(IPROC.EQ.-526)THEN
            IF(NARG.LT.6.OR.NARG.GT.7.OR.
     -           MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.MODARG(3).NE.2.OR.
     -           ARGREF(4,1).GE.2.OR.ARGREF(5,1).GE.2.OR.
     -           ARGREF(6,1).GE.2.OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for ELECTRON_VELOCITY; not executed.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Clear the return space.
            CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
            CALL ALGREU(NINT(ARG(6)),MODARG(6),ARGREF(6,1))
            IF(NARG.GE.7)CALL ALGREU(NINT(ARG(7)),MODARG(7),ARGREF(7,1))
*   Evaluate the velocity.
            CALL DLCVEL(DBLE(ARG(1)),DBLE(ARG(2)),DBLE(ARG(3)),
     -           F0,-1.0,1,ILOC)
*   Return the arguments.
            ARG(4)=REAL(F0(1))
            ARG(5)=REAL(F0(2))
            ARG(6)=REAL(F0(3))
            MODARG(4)=2
            MODARG(5)=2
            MODARG(6)=2
            IF(NARG.GE.7)THEN
                 IF(ILOC.EQ.-10)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Unknown potential',17,IFAIL1)
                 ELSEIF(ILOC.EQ.-5)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'In a material',13,IFAIL1)
                 ELSEIF(ILOC.EQ.-6)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Outside mesh',12,IFAIL1)
                 ELSEIF(ILOC.LT.0)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Outside plane',13,IFAIL1)
                 ELSEIF(ILOC.EQ.0)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Normal',6,IFAIL1)
                 ELSEIF(ILOC.LE.NWIRE)THEN
                      CALL OUTFMT(REAL(ILOC),2,AUX1,NC1,'LEFT')
                      CALL STRBUF('STORE',IAUX,'In '//WIRTYP(ILOC)//
     -                     '-wire '//AUX1(1:NC1),10+NC1,IFAIL1)
                 ELSEIF(ILOC.GT.2*MXWIRE.AND.
     -                ILOC.LE.2*MXWIRE+NSOLID)THEN
                      CALL OUTFMT(REAL(ILOC-2*MXWIRE),2,AUX1,NC1,'LEFT')
                      CALL STRBUF('STORE',IAUX,'In '//
     -                     SOLTYP(ILOC-2*MXWIRE)//'-solid '//
     -                     AUX1(1:NC1),11+NC1,IFAIL1)
                 ELSE
                      CALL STRBUF('STORE',IAUX,'Unknown',7,IFAIL1)
                 ENDIF
                 ARG(7)=REAL(IAUX)
                 MODARG(7)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING : '//
     -                'Error storing a string for ELECTRON_VELOCITY.'
            ENDIF
*** Velocity vector for ions.
       ELSEIF(IPROC.EQ.-527)THEN
            IF(NARG.LT.6.OR.NARG.GT.7.OR.
     -           MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.MODARG(3).NE.2.OR.
     -           ARGREF(4,1).GE.2.OR.ARGREF(5,1).GE.2.OR.
     -           ARGREF(6,1).GE.2.OR.
     -           (NARG.GE.7.AND.ARGREF(7,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for ION_VELOCITY; not executed.'
                 RETURN
*   Make sure there are drift velocities.
            ELSEIF(.NOT.GASOK(2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for ions is not defined ; not executed.'
                 RETURN
            ENDIF
*   Clear the return space.
            CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
            CALL ALGREU(NINT(ARG(6)),MODARG(6),ARGREF(6,1))
            IF(NARG.GE.7)CALL ALGREU(NINT(ARG(7)),MODARG(7),ARGREF(7,1))
*   Evaluate the velocity.
            CALL DLCVEL(DBLE(ARG(1)),DBLE(ARG(2)),DBLE(ARG(3)),
     -           F0,+1.0,2,ILOC)
*   Return the arguments.
            ARG(4)=REAL(F0(1))
            ARG(5)=REAL(F0(2))
            ARG(6)=REAL(F0(3))
            MODARG(4)=2
            MODARG(5)=2
            MODARG(6)=2
            IF(NARG.GE.7)THEN
                 IF(ILOC.EQ.-10)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Unknown potential',17,IFAIL1)
                 ELSEIF(ILOC.EQ.-5)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'In a material',13,IFAIL1)
                 ELSEIF(ILOC.EQ.-6)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Outside mesh',12,IFAIL1)
                 ELSEIF(ILOC.LT.0)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Outside plane',13,IFAIL1)
                 ELSEIF(ILOC.EQ.0)THEN
                      CALL STRBUF('STORE',IAUX,
     -                     'Normal',6,IFAIL1)
                 ELSEIF(ILOC.LE.NWIRE)THEN
                      CALL OUTFMT(REAL(ILOC),2,AUX1,NC1,'LEFT')
                      CALL STRBUF('STORE',IAUX,'In '//WIRTYP(ILOC)//
     -                     '-wire '//AUX1(1:NC1),10+NC1,IFAIL1)
                 ELSEIF(ILOC.GT.2*MXWIRE.AND.
     -                ILOC.LE.2*MXWIRE+NSOLID)THEN
                      CALL OUTFMT(REAL(ILOC-2*MXWIRE),2,AUX1,NC1,'LEFT')
                      CALL STRBUF('STORE',IAUX,'In '//
     -                     SOLTYP(ILOC-2*MXWIRE)//'-solid '//
     -                     AUX1(1:NC1),11+NC1,IFAIL1)
                 ELSE
                      CALL STRBUF('STORE',IAUX,'Unknown',7,IFAIL1)
                 ENDIF
                 ARG(7)=REAL(IAUX)
                 MODARG(7)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING : '//
     -                'Error storing a string for ION_VELOCITY.'
            ENDIF
*** Print the current drift line.
       ELSEIF(IPROC.EQ.-528)THEN
*   Check arguments.
            IF(NARG.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -           ' PRINT_DRIFT_LINE takes no arguments ; arguments'//
     -           ' ignored.'
*   Print a header.
            WRITE(LUNOUT,'(''  CURRENT DRIFT LINE: ''/)')
            IF(IPTYPE.EQ.1)THEN
                 WRITE(LUNOUT,'(''  Particle:  electron'')')
            ELSEIF(IPTYPE.EQ.2)THEN
                 WRITE(LUNOUT,'(''  Particle:  ion'')')
            ELSE
                 WRITE(LUNOUT,'(''  Particle:  not set'')')
            ENDIF
            CALL OUTFMT(QPCHAR,2,AUX1,NC1,'LEFT')
            WRITE(LUNOUT,'(''  Charge:    '',A)') AUX1(1:NC1)
            IF(IPTECH.EQ.1)THEN
                 WRITE(LUNOUT,'(''  Technique: Runge Kutta Fehlberg'')')
            ELSEIF(IPTECH.EQ.2)THEN
                 WRITE(LUNOUT,'(''  Technique: Monte Carlo'')')
            ELSEIF(IPTECH.EQ.3)THEN
                 WRITE(LUNOUT,'(''  Technique: vacuum drift'')')
            ELSE
                 WRITE(LUNOUT,'(''  Technique: not set'')')
            ENDIF
            CALL DLCSTF(ISTAT,OPT,NCOPT)
            WRITE(LUNOUT,'(''  Status:    '',A)') OPT(1:NCOPT)
            CALL OUTFMT(REAL(NU),2,AUX1,NC1,'LEFT')
            WRITE(LUNOUT,'(''  Steps:     '',A)') AUX1(1:NC1)
*   Print also the path, if non-zero.
            IF(NU.GT.0.AND.POLAR)THEN
                 WRITE(LUNOUT,'(/''  Path:''/
     -                16X,''r'',14X,''phi'',16X,''z'',13X,''time''/
     -                13X,''[cm]'',8X,''[degrees]'',
     -                13X,''[cm]'',7X,''[microsec]''/)')
            ELSEIF(NU.GT.0)THEN
                 WRITE(LUNOUT,'(/''  Path:''/
     -                16X,''x'',16X,''y'',16X,''z'',13X,''time''/
     -                13X,''[cm]'',13X,''[cm]'',
     -                13X,''[cm]'',7X,''[microsec]''/)')
            ENDIF
            DO 100 I=1,NU
            IF(POLAR)THEN
                 CALL CF2RTP(XU(I),YU(I),XPOS1,YPOS1,1)
            ELSE
                 XPOS1=XU(I)
                 YPOS1=YU(I)
            ENDIF
            CALL OUTFMT(REAL(XPOS1),2,AUX1,NC1,'RIGHT')
            CALL OUTFMT(REAL(YPOS1),2,AUX2,NC2,'RIGHT')
            CALL OUTFMT(REAL(ZU(I)),2,AUX3,NC3,'RIGHT')
            CALL OUTFMT(REAL(TU(I)),2,AUX4,NC4,'RIGHT')
            WRITE(LUNOUT,'(4(2X,A15))') AUX1,AUX2,AUX3,AUX4
100         CONTINUE
*** Drift field divergence.
       ELSEIF(IPROC.EQ.-529)THEN
*   Check the arguments.
            IF(NARG.LT.2.OR.NARG.GT.7.OR.
     -           MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.MODARG(3).NE.2.OR.
     -           ARGREF(4,1).GE.2.OR.ARGREF(5,1).GE.2.OR.
     -           ARGREF(6,1).GE.2.OR.
     -           (NARG.GE.7.AND.MODARG(7).NE.1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for DRIFT_DIVERGENCE; not executed.'
                 RETURN
            ENDIF
*   Get the location.
            X0=ARG(1)
            Y0=ARG(2)
            Z0=ARG(3)
*   Retrieve the options.
            IF(NARG.GE.7)THEN
                 CALL STRBUF('READ',NINT(ARG(7)),OPT,NC,IFAIL1)
            ELSE
                 OPT='electron,negative'
                 NC=17
            ENDIF
            CALL CLTOU(OPT(1:NC))
            Q=-1
            IPART=1
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to retrieve'//
     -                ' the options of  DRIFT_DIVERGENCE; assuming e-.'
            ELSE
                 IF(INDEX(OPT(1:NC),'ELEC').NE.0)IPART=1
                 IF(INDEX(OPT(1:NC),'ION').NE.0)IPART=2
                 IF(INDEX(OPT(1:NC),'POS').NE.0)Q=+1.0
                 IF(INDEX(OPT(1:NC),'NEG').NE.0)Q=-1.0
            ENDIF
*   Clear the return space.
            CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
            CALL ALGREU(NINT(ARG(6)),MODARG(6),ARGREF(6,1))
*   Call the procedure interface.
            CALL DLCDIC(X0,Y0,Z0,FDIV1,FDIV2,FDIV3,Q,IPART,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Error computing'//
     -                ' the divergence; set to 1.'
                 ARG(4)=1
                 ARG(5)=1
                 ARG(6)=1
                 MODARG(4)=2
                 MODARG(5)=2
                 MODARG(6)=2
            ELSE
                 ARG(4)=FDIV1
                 ARG(5)=FDIV2
                 ARG(6)=FDIV3
                 MODARG(4)=2
                 MODARG(5)=2
                 MODARG(6)=2
            ENDIF
*** Drift field rotation matrices.
       ELSEIF(IPROC.EQ.-530)THEN
*   Check the arguments.
            IF(NARG.LT.2.OR.NARG.GT.7.OR.
     -           MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.MODARG(3).NE.2.OR.
     -           ARGREF(4,1).GE.2.OR.ARGREF(5,1).GE.2.OR.
     -           ARGREF(6,1).GE.2.OR.
     -           (NARG.GE.7.AND.MODARG(7).NE.1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for DRIFT_ROTATION; not executed.'
                 RETURN
            ENDIF
*   Get the location.
            X0=ARG(1)
            Y0=ARG(2)
            Z0=ARG(3)
*   Retrieve the options.
            IF(NARG.GE.7)THEN
                 CALL STRBUF('READ',NINT(ARG(7)),OPT,NC,IFAIL1)
            ELSE
                 OPT='electron,negative'
                 NC=17
            ENDIF
            CALL CLTOU(OPT(1:NC))
            Q=-1
            IPART=1
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to retrieve'//
     -                ' the options of  DRIFT_ROTATION; assuming e-.'
            ELSE
                 IF(INDEX(OPT(1:NC),'ELEC').NE.0)IPART=1
                 IF(INDEX(OPT(1:NC),'ION').NE.0)IPART=2
                 IF(INDEX(OPT(1:NC),'POS').NE.0)Q=+1.0
                 IF(INDEX(OPT(1:NC),'NEG').NE.0)Q=-1.0
            ENDIF
*   Clear the return space.
            CALL ALGREU(NINT(ARG(4)),MODARG(4),ARGREF(4,1))
            CALL ALGREU(NINT(ARG(5)),MODARG(5),ARGREF(5,1))
            CALL ALGREU(NINT(ARG(6)),MODARG(6),ARGREF(6,1))
*   Call the procedure interface.
            CALL DLCROC(X0,Y0,Z0,Q,IPART,IRRVC,IRRMC,IRRVM,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Error computing'//
     -                ' the rotation matrices; set to Nill.'
                 ARG(4)=0
                 ARG(5)=0
                 ARG(6)=0
                 MODARG(4)=0
                 MODARG(5)=0
                 MODARG(6)=0
            ELSE
                 ARG(4)=REAL(IRRVC)
                 ARG(5)=REAL(IRRMC)
                 ARG(6)=REAL(IRRVM)
                 MODARG(4)=5
                 MODARG(5)=5
                 MODARG(6)=5
            ENDIF
*** Integrate excitations.
       ELSEIF(IPROC.EQ.-531)THEN
*   Check the arguments.
            IF(NARG.NE.1.OR.ARGREF(1,1).GE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for INTEGRATE_EXCITATIONS;'//
     -                ' not executed.'
                 RETURN
            ENDIF
*   Clear up old storage.
            CALL ALGREU(NINT(ARG(1)),MODARG(1),ARGREF(1,1))
*   Call the procedure
            CALL DLCEX1(EXRATE)
            ISIZ(1)=NEXGAS
            CALL MATADM('ALLOCATE',IREXC,1,ISIZ,2,IFAIL1)
            ISEXC=MATSLT(IREXC)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to obtain'//
     -                ' matrix storage for excitation rates.'
                 RETURN
            ELSEIF(ISEXC.LE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to locate'//
     -                ' matrix storage for excitation rates.'
                 RETURN
            ELSE
                 DO 110 I=1,NEXGAS
                 MVEC(MORG(ISEXC)+I)=EXRATE(I)
110              CONTINUE
                 ARG(1)=IREXC
                 MODARG(1)=5
            ENDIF
*** Integrate ionisations.
       ELSEIF(IPROC.EQ.-532)THEN
*   Check the arguments.
            IF(NARG.NE.1.OR.ARGREF(1,1).GE.2)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect set of'//
     -                ' arguments for INTEGRATE_IONISATIONS;'//
     -                ' not executed.'
                 RETURN
            ENDIF
*   Clear up old storage.
            CALL ALGREU(NINT(ARG(1)),MODARG(1),ARGREF(1,1))
*   Call the procedure
            CALL DLCIO1(IORATE)
            ISIZ(1)=NIOGAS
            CALL MATADM('ALLOCATE',IRION,1,ISIZ,2,IFAIL1)
            ISION=MATSLT(IRION)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to obtain'//
     -                ' matrix storage for ionisation rates.'
                 RETURN
            ELSEIF(ISION.LE.0)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Unable to locate'//
     -                ' matrix storage for ionisation rates.'
                 RETURN
            ELSE
                 DO 120 I=1,NIOGAS
                 MVEC(MORG(ISION)+I)=IORATE(I)
120              CONTINUE
                 ARG(1)=IRION
                 MODARG(1)=5
            ENDIF
*** Mean free path microscopic tracking
       ELSEIF(IPROC.EQ.-533)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.EQ.10.OR.NARG.EQ.11.OR.
     -           NARG.GT.13)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for DRIFT_MICROSCOPIC.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -             MODARG(3).NE.2.OR.
     -           (NARG.GE. 6.AND.MODARG( 6).NE.1).OR.
     -           (NARG.GE. 7.AND.MODARG( 7).NE.2).OR.
     -           (NARG.GE. 8.AND.MODARG( 8).NE.2).OR.
     -           (NARG.GE. 9.AND.MODARG( 9).NE.2).OR.
     -           (NARG.GE.10.AND.MODARG(10).NE.2).OR.
     -           (NARG.GE.11.AND.MODARG(11).NE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' DRIFT_MICROSCOPIC are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE. 4.AND.ARGREF( 4,1).GE.2).OR.
     -             (NARG.GE. 5.AND.ARGREF( 5,1).GE.2).OR.
     -             (NARG.GE.12.AND.ARGREF(12,1).GE.2).OR.
     -             (NARG.GE.13.AND.ARGREF(13,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of DRIFT_MICROSCOPIC can not be modified.'
                 RETURN
*   Make sure there are drift velocities (for termination).
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 22 ISTR=4,NARG
            IF((ISTR.GE.6.AND.ISTR.LE.11).OR.ISTR.EQ.12)GOTO 22
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
22          CONTINUE
*   Fetch the option string.
            IF(NARG.GE.6)THEN
                 CALL STRBUF('READ',NINT(ARG(6)),OPT,NCOPT,IFAIL1)
                 CALL CLTOU(OPT(1:NCOPT))
            ELSE
                 OPT=' '
                 NCOPT=1
            ENDIF
*   Get hold of the energies and direction
            IF(NARG.GE.7)THEN
                 EFINAL=ARG(7)
            ELSE
                 EFINAL=5.0
            ENDIF
            IF(NARG.GE.8)THEN
                 ESTART=ARG(8)
            ELSE
                 ESTART=EFINAL/50.0
            ENDIF
            DIRX=0
            DIRY=0
            DIRZ=0
            IF(NARG.GE.9)THEN
                 DIRX=ARG(9)
                 DIRY=ARG(10)
                 DIRZ=ARG(11)
            ENDIF
            IF(NARG.LT.9.OR.DIRX**2+DIRY**2+DIRZ**2.LE.0)THEN
                 THETA0=2*PI*RNDUNI(1.0)
                 THETA1=ACOS(MIN(1.0,MAX(-1.0,1.0-2.0*RNDUNI(1.0))))
                 DIRX=COS(THETA1)
                 DIRY=SIN(THETA1)*COS(THETA0)
                 DIRZ=SIN(THETA1)*SIN(THETA0)
            ENDIF
*   Clear the histogram only if it isn't already an histogram.
            IF(NARG.GE.12.AND.MODARG(12).NE.4)THEN
                 CALL ALGREU(NINT(ARG(12)),MODARG(12),ARGREF(12,1))
                 IHDIST=-1
            ELSEIF(NARG.GE.12)THEN
                 IHDIST=NINT(ARG(12))
            ELSE
                 IHDIST=0
            ENDIF
*   Rate references.
            IF(NARG.GE.13)THEN
                 IRCS=1
            ELSE
                 IRCS=-1
            ENDIF
*   Carry out the calculation.
            CALL DLCMIC(ARG(1),ARG(2),ARG(3),OPT(1:NCOPT),NCOPT,
     -           EFINAL,ESTART,DIRX,DIRY,DIRZ,IRCS,IHDIST)
*   Return status code.
            IF(NARG.GE.4)THEN
                 CALL DLCSTF(ISTAT,OPT,NCOPT)
                 CALL STRBUF('STORE',IAUX,OPT,NCOPT,IFAIL1)
                 ARG(4)=REAL(IAUX)
                 MODARG(4)=1
                 IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCCAL WARNING :'//
     -                ' Error storing the status for DRIFT_MICROSCOPIC.'
            ENDIF
*   Return the time.
            IF(NU.GE.1)THEN
                 ARG(5)=TU(NU)
            ELSE
                 ARG(5)=0.0
            ENDIF
            MODARG(5)=2
*   Return the histogram.
            IF(NARG.GE.12)THEN
                 ARG(12)=IHDIST
                 MODARG(12)=4
            ENDIF
*   Return the rate vectors.
            IF(NARG.GE.13)THEN
                 ARG(13)=IRCS
                 MODARG(13)=5
            ENDIF
*** Mean free path microscopic avalanche.
       ELSEIF(IPROC.EQ.-534)THEN
*   Check number of arguments.
            IF(NARG.LT.3.OR.NARG.EQ.8.OR.NARG.EQ.9.OR.
     -           NARG.GT.14)THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Incorrect number'//
     -                ' of arguments for AVALANCHE_MICROSCOPIC.'
                 RETURN
*   Check argument mode.
            ELSEIF(MODARG(1).NE.2.OR.MODARG(2).NE.2.OR.
     -             MODARG(3).NE.2.OR.
     -           (NARG.GE. 4.AND.MODARG( 4).NE.1).OR.
     -           (NARG.GE. 5.AND.MODARG( 5).NE.2).OR.
     -           (NARG.GE. 6.AND.MODARG( 6).NE.2).OR.
     -           (NARG.GE. 7.AND.MODARG( 7).NE.2).OR.
     -           (NARG.GE. 8.AND.MODARG( 8).NE.2).OR.
     -           (NARG.GE. 9.AND.MODARG( 9).NE.2).OR.
     -           (NARG.GE.14.AND.MODARG(14).NE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments of'//
     -                ' AVALANCHE_MICROSCOPIC are of incorrect type.'
                 RETURN
*   Check the the results can be transferred back.
            ELSEIF((NARG.GE.10.AND.ARGREF(10,1).GE.2).OR.
     -             (NARG.GE.11.AND.ARGREF(11,1).GE.2).OR.
     -             (NARG.GE.12.AND.ARGREF(12,1).GE.2).OR.
     -             (NARG.GE.13.AND.ARGREF(13,1).GE.2))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : Some arguments'//
     -                ' of AVALANCHE_MICROSCOPIC can not be modified.'
                 RETURN
*   Make sure there are drift velocities (for termination).
            ELSEIF(.NOT.GASOK(1))THEN
                 PRINT *,' !!!!!! DLCCAL WARNING : The drift velocity'//
     -                ' for electrons is not defined ; not executed.'
                 RETURN
            ENDIF
*   Variables already in use ?
            DO 23 ISTR=11,NARG
            CALL ALGREU(NINT(ARG(ISTR)),MODARG(ISTR),ARGREF(ISTR,1))
23          CONTINUE
*   Fetch the option string.
            IF(NARG.GE.4)THEN
                 CALL STRBUF('READ',NINT(ARG(4)),OPT,NCOPT,IFAIL1)
                 CALL CLTOU(OPT(1:NCOPT))
            ELSE
                 OPT=' '
                 NCOPT=1
            ENDIF
*   Get hold of the energies and direction
            IF(NARG.GE.5)THEN
                 EFINAL=ARG(5)
            ELSE
                 EFINAL=200.0
            ENDIF
            IF(NARG.GE.6)THEN
                 ESTART=ARG(6)
            ELSE
                 ESTART=EFINAL/50.0
            ENDIF
            DIRX=0
            DIRY=0
            DIRZ=0
            IF(NARG.GE.7)THEN
                 DIRX=ARG(7)
                 DIRY=ARG(8)
                 DIRZ=ARG(9)
            ENDIF
            IF(NARG.LT.7.OR.DIRX**2+DIRY**2+DIRZ**2.LE.0)THEN
                 THETA0=2*PI*RNDUNI(1.0)
                 THETA1=ACOS(MIN(1.0,MAX(-1.0,1.0-2.0*RNDUNI(1.0))))
                 DIRX=COS(THETA1)
                 DIRY=SIN(THETA1)*COS(THETA0)
                 DIRZ=SIN(THETA1)*SIN(THETA0)
            ENDIF
*   Clear the histogram only if it isn't already an histogram.
            IF(NARG.GE.10.AND.MODARG(10).NE.4)THEN
                 CALL ALGREU(NINT(ARG(10)),MODARG(10),ARGREF(10,1))
                 IHDIST=-1
            ELSEIF(NARG.GE.10)THEN
                 IHDIST=NINT(ARG(10))
            ELSE
                 IHDIST=0
            ENDIF
*   Rate references.
            IF(NARG.GE.11)THEN
                 IRCS=1
            ELSE
                 IRCS=-1
            ENDIF
*   Delay
            IF(NARG.GE.14)THEN
                 DELAY=ARG(14)
            ELSE
                 DELAY=0
            ENDIF
*   Carry out the calculation.
            CALL DLCMIA(ARG(1),ARG(2),ARG(3),OPT(1:NCOPT),EFINAL,
     -           ESTART,DIRX,DIRY,DIRZ,IRCS,IHDIST,DELAY,
     -           NETOT,NITOT,IFAIL1)
*   Set the OK flag according to the IFAIL flag.
            IF(IFAIL1.NE.0)RETURN
*   Return the histogram.
            IF(NARG.GE.10)THEN
                 ARG(10)=IHDIST
                 MODARG(10)=4
            ENDIF
*   Return the rate vectors.
            IF(NARG.GE.11)THEN
                 ARG(11)=IRCS
                 MODARG(11)=5
            ENDIF
*   Return electron and ion count.
            IF(NARG.GE.12)THEN
                 ARG(12)=REAL(NETOT)
                 MODARG(12)=2
            ENDIF
            IF(NARG.GE.13)THEN
                 ARG(13)=REAL(NITOT)
                 MODARG(13)=2
            ENDIF
*** Unknown drift line operation.
       ELSE
            PRINT *,' !!!!!! DLCCAL WARNING : Unknown procedure code'//
     -           ' received; nothing done.'
            IFAIL=1
            RETURN
       ENDIF
*** Seems to have worked.
       IFAIL=0
       END
CDECK  ID>, DLCSOL.
       SUBROUTINE DLCSOL(XX0,YY0,ZZ0,XX1,YY1,ZZ1,DT,ILOC,Q,ITYPE)
*-----------------------------------------------------------------------
*   DLCSOL - Terminates drift line calculation by making a last step
*            to the boundary of a solid.
*   VARIABLES : (XX0,YY0,ZZ0): Last point in drift medium.
*               (XX1,YY1,ZZ1): Estimated step, outside drift medium.
*               (X0,Y0,Z0)  : Final point just inside medium
*               (X1,Y1,Z1)  : Final point just outside medium
*               FF0         : Drift velocity at (XX0,YY0,ZZ0)
*               F0          : Drift velocity at (X0,Y0,Z0)
*               DELTAT      : Time step
*   (Last changed on  8/ 5/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER NBISEC
       PARAMETER(NBISEC=20)
       INTEGER ILOC,ITYPE,ILOC0,ILOC1,ILOCM,ILOCS,I,ILOCVF,IFAIL,IVOL
       REAL Q,EOVERM,X0,Y0,Z0,X1,Y1,Z1,XM,YM,ZM
       DOUBLE PRECISION XX0,YY0,ZZ0,XX1,YY1,ZZ1,POS(3),
     -      FF0(3),F0(3),ACC(3),SPEED,ACCEL,STEP,
     -      XOLD,YOLD,ZOLD,DT
       COMMON /VFUCOM/ EOVERM,ILOCVF
*** Identify this routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE DLCSOL ///'
*** Ensure there is a previous stored step.
       IF(NU.LE.0)THEN
            PRINT *,' ###### DLCSOL ERROR   : Called at first step;'//
     -           ' program bug, please report.'
            ISTAT=-3
            RETURN
       ENDIF
*** Check we may still add points.
       IF(NU.GE.MXLIST)THEN
            ISTAT=-2
            IF(LDEBUG)PRINT *,' ++++++ DLCSOL DEBUG   : Last point'//
     -           ' not added because MXLIST is reached.'
            RETURN
       ENDIF
*** Ensure we got an appropriate location code.
       IF(ILOC.LE.2*MXWIRE)THEN
            PRINT *,' ###### DLCSOL ERROR   : Called for location'//
     -           ' code ',ILOC,'; program bug, please report.'
            ISTAT=-3
            RETURN
       ENDIF
*** Initialise the bisection loop.
       X0=REAL(XX0)
       Y0=REAL(YY0)
       Z0=REAL(ZZ0)
       X1=REAL(XX1)
       Y1=REAL(YY1)
       Z1=REAL(ZZ1)
       CALL CELVPT(DBLE(X0),DBLE(Y0),DBLE(Z0),ILOC0)
       CALL CELVPT(DBLE(X1),DBLE(Y1),DBLE(Z1),ILOC1)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   : Starting'',
     -      '' from (x,y,z)='',3E15.8,'' loc='',I5/34X,
     -      '' to   (x,y,z)='',3E15.8,'' loc='',I5)') X0,Y0,Z0,ILOC0,
     -      X1,Y1,Z1,ILOC1
       IF(ILOC0.NE.0.OR.ILOC1.EQ.0)THEN
            IF(LDEBUG)PRINT *,' ++++++ DLCSOL DEBUG   : Called but'//
     -           ' ILOC=',ILOC0,ILOC1,' returning ISTAT=-3.'
            ISTAT=-3
            RETURN
       ENDIF
*** Perform some bisections.
       ILOCS=ILOC1
       DO 10 I=1,NBISEC
*   Quit bisection when interval becomes too small.
       IF(ABS(X1-X0).LE.1D-6*(ABS(X0)+ABS(X1)).AND.
     -      ABS(Y1-Y0).LE.1D-6*(ABS(Y0)+ABS(Y1)).AND.
     -      ABS(Z1-Z0).LE.1D-6*(ABS(Z0)+ABS(Z1)))THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   :'',
     -           '' Bisection ended at loop '',I5,'' (interval'',
     -           '' too small).'')') I
            GOTO 20
       ENDIF
*   Middle point.
       XM=0.5*(X0+X1)
       YM=0.5*(Y0+Y1)
       ZM=0.5*(Z0+Z1)
*   Evaluate field.
       CALL CELVPT(DBLE(XM),DBLE(YM),DBLE(ZM),ILOCM)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   : Bisection'',
     -      '' at  (x,y,z)='',3E15.8,'' loc='',I5)') XM,YM,ZM,ILOCM
*   Shift limits of the bisection.
       IF(ILOCM.EQ.0)THEN
            X0=XM
            Y0=YM
            Z0=ZM
       ELSE
            X1=XM
            Y1=YM
            Z1=ZM
            ILOCS=ILOCM
       ENDIF
10     CONTINUE
*   Maximum number of iterations reached.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   :'',
     -      '' Bisection ended at loop '',I5,'' (maximum number'',
     -      '' of iterations).'')') NBISEC
*** Calculate the drift velocity over the last step.
20     CONTINUE
**  Runge-Kutta-Fehlberg or Monte-Carlo drifting.
       IF(ITYPE.EQ.1.OR.ITYPE.EQ.2)THEN
*   Compute drift velocity at begin and end of the step.
            CALL DLCVEL(XX0,YY0,ZZ0,FF0,Q,ITYPE,ILOC0)
            CALL DLCVEL(DBLE(X0),DBLE(Y0),DBLE(Z0),F0,Q,ITYPE,ILOC1)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   :'',
     -           '' Loc start: '',I5,'' Loc end: '',I5)') ILOC0,ILOC1
*   Average if both are in a free area.
            IF(ILOC0.EQ.0.AND.ILOC1.EQ.0)THEN
                 SPEED=SQRT((FF0(1)+F0(1))**2+(FF0(2)+F0(2))**2+
     -                (FF0(3)+F0(3))**2)/2
*   Or approximate with the last step only.
            ELSEIF(ILOC0.EQ.0)THEN
                 SPEED=SQRT(FF0(1)**2+FF0(2)**2+FF0(3)**2)
                 PRINT *,' ------ DLCSOL MESSAGE : Unable to compute'//
     -                ' mean drift speed at last step; approximated.'
*   At least one should be OK.
            ELSE
                 PRINT *,' !!!!!! DLCSOL WARNING : Unable to compute'//
     -                ' drift speed at last step; aborted.'
                 ISTAT=-3
                 RETURN
            ENDIF
**  Vacuum drift.
       ELSEIF(ITYPE.EQ.3)THEN
*   If there are already steps, estimate speed from the last step.
            IF(NU.GT.1)THEN
                 IF(TU(NU)-TU(NU-1).GT.0)THEN
                      FF0(1)=(XU(NU)-XU(NU-1))/(TU(NU)-TU(NU-1))
                      FF0(2)=(YU(NU)-YU(NU-1))/(TU(NU)-TU(NU-1))
                      FF0(3)=(ZU(NU)-ZU(NU-1))/(TU(NU)-TU(NU-1))
                 ELSE
                      PRINT *,' !!!!!! DLCSOL WARNING : Drift speed'//
     -                     ' over previous step is 0; aborted.'
                      ISTAT=-3
                      RETURN
                 ENDIF
*   Otherwise set speed to 0.
            ELSE
                 FF0(1)=0
                 FF0(2)=0
                 FF0(3)=0
            ENDIF
*   Use speed and location to compute the acceleration.
            POS(1)=XX0
            POS(2)=YY0
            POS(3)=ZZ0
            ILOCVF=0
            CALL DLCVFU(0.0D0,POS,FF0,ACC)
            IF(ILOCVF.NE.0)THEN
                 PRINT *,' !!!!!! DLCSOL WARNING : Unable to compute'//
     -                ' acceleration over last step; aborted.'
                 ISTAT=-3
                 RETURN
            ENDIF
*   Estimate from these what the average speed for the last step is.
            SPEED=SQRT(FF0(1)**2+FF0(2)**2+FF0(3)**2)
            ACCEL=SQRT(ACC(1)**2+ACC(2)**2+ACC(3)**2)
            STEP=SQRT((X0-XX0)**2+(Y0-YY0)**2+(Z0-ZZ0)**2)
            SPEED=SPEED/2+SQRT(SPEED**2+2*ACCEL*STEP)/2
**  Microscopic tracking
       ELSEIF(ITYPE.EQ.4)THEN
            IF(DT.LE.0)THEN
                 PRINT *,' !!!!!! DLCSOL WARNING : Time delay over'//
     -                ' the proposed step is not > 0; aborted.'
                 ISTAT=-3
                 RETURN
            ELSE
                 SPEED=SQRT((XX0-XX1)**2+(YY0-YY1)**2+(ZZ0-ZZ1)**2)/DT
            ENDIF
**  Anything else
       ELSE
            PRINT *,' ###### DLCSOL ERROR   : Unknown tracking method'//
     -           ' received: ',ITYPE,'; abandoning the drift line.'
            ISTAT=-3
            RETURN
       ENDIF
**  Check velocity.
       IF(SPEED.LE.0)THEN
            PRINT *,' !!!!!! DLCSOL WARNING : Drift line not properly'//
     -           ' terminated because of zero velocity.'
            ISTAT=-3
            RETURN
       ENDIF
*** Add the last step to the boundary.
       NU=NU+1
       XU(NU)=DBLE(X0)
       YU(NU)=DBLE(Y0)
       ZU(NU)=DBLE(Z0)
*** And fill in the time for the last step.
       TU(NU)=TU(NU-1)+SQRT((XU(NU)-XU(NU-1))**2+
     -      (YU(NU)-YU(NU-1))**2+(ZU(NU)-ZU(NU-1))**2)/SPEED
*** Assign the status code.
       CALL CELVPT(DBLE(X0),DBLE(Y0),DBLE(Z0),IVOL)
       IF(IVOL.LE.0)THEN
            ISTAT=2*MXWIRE+ILOCS
       ELSE
            ISTAT=2*MXWIRE+IVOL
       ENDIF
*** Check that the particle is still inside the drift area, clip if not.
       IF(XU(NU).LT.DDXMIN)ISTAT=ISTAT1
       IF(XU(NU).GT.DDXMAX)ISTAT=ISTAT2
       IF(YU(NU).LT.DDYMIN)ISTAT=ISTAT3
       IF(YU(NU).GT.DDYMAX)ISTAT=ISTAT4
       IF(ZU(NU).LT.DDZMIN)ISTAT=ISTAT5
       IF(ZU(NU).GT.DDZMAX)ISTAT=ISTAT6
       IF(ISTAT.NE.ILOCS)THEN
            XOLD=XU(NU)
            YOLD=YU(NU)
            ZOLD=ZU(NU)
            CALL CLIP3D(XU(NU-1),    YU(NU-1),    ZU(NU-1),
     -                  XU(NU),      YU(NU),      ZU(NU),
     -                  DBLE(DDXMIN),DBLE(DDYMIN),DBLE(DDZMIN),
     -                  DBLE(DDXMAX),DBLE(DDYMAX),DBLE(DDZMAX),IFAIL)
            IF(IFAIL.NE.0.OR.(XOLD.EQ.XU(NU-1).AND.
     -           YOLD.EQ.YU(NU-1).AND.ZOLD.EQ.ZU(NU-1)))THEN
                 NU=NU-1
            ELSE
                 TU(NU)=TU(NU-1)+(TU(NU)-TU(NU-1))*SQRT(
     -                ((XU(NU)-XU(NU-1))**2+(YU(NU)-YU(NU-1))**2+
     -                 (ZU(NU)-ZU(NU-1))**2)/
     -                ((XOLD-XU(NU-1))**2+(YOLD-YU(NU-1))**2+
     -                 (ZOLD-ZU(NU-1))**2))
            ENDIF
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   : Area'',
     -           '' left or solid entered, ISTAT='',I5)') ISTAT
       ENDIF
*** Debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSOL DEBUG   : NU='',I5/
     -      5X,''Old step: '',3E12.5,'' location: '',I10/
     -      5X,''End     : '',3E12.5,'' location: '',I10/
     -      5X,''New step: '',3E12.5,'' status:   '',I10/
     -      5X,''Speed   : '',E12.5)')
     -      NU,XX0,YY0,ZZ0,ILOC0,XX1,YY1,ZZ1,ILOC1,X0,Y0,Z0,ISTAT,SPEED
       END
CDECK  ID>, DLCSTA.
       SUBROUTINE DLCSTA(Q,ITYPE)
*-----------------------------------------------------------------------
*   DLCSTA - Subroutine returning the status of a drift line. It checks
*            that the particle is not inside or near a wire or a plane.
*            If that is the case however, the drift line is finished and
*            a non-zero status code is returned.
*   VARIABLES : XLAST,YLAST: Last particle position in basic cell.
*               SHIFT      : .TRUE. if we are not in the basic period.
*               XW,YW      : Wire position moved to the particle period.
*               DIST2      : Minimum distance of particle during the
*                            last step to a given wire squared.
*   (Last changed on 16/12/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       DOUBLE PRECISION WGT,FPRMAT,
     -      FPROJ,FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX,GYBOX,GZBOX
       REAL PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM
       INTEGER NLINED,NGRIDX,NGRIDY,ITRTYP,NTRLIN,NTRSAM,INDPOS,NCTRW,
     -      NTRFLX,NINORD,
     -      NCPNAM,NCXLAB,NCYLAB,NCFPRO,IPRMAT,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,ITFSRM,NTRERR
       LOGICAL LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG,LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       COMMON /PARMS / WGT(MXLIST),FPRMAT(3,3),
     -      FPROJ(3,3),FPROJA,FPROJB,FPROJC,FPROJD,FPROJN,
     -      EPSGX,EPSGY,EPSGZ,
     -      GXMIN,GYMIN,GZMIN,GXMAX,GYMAX,GZMAX,
     -      GXBOX(12),GYBOX(12),GZBOX(12),
     -      PXMIN,PYMIN,PZMIN,PXMAX,PYMAX,PZMAX,
     -      PRTHL,PRPHIL,PRAL,PRBL,PRCL,PROROT,
     -      PRFABS,PRFREF,PRFMIN,PRFMAX,PRFCAL,WLMIN,WLMAX,
     -      XT0,YT0,ZT0,XT1,YT1,ZT1,
     -      TRMASS,TRENER,TRCHAR,TRXDIR,TRYDIR,TRZDIR,TRTH,TRPHI,TRDIST,
     -      TRFLUX,TRELEC,TRNSRM,
     -      INDPOS(11000),IPRMAT(3),NCTRW,NCPNAM,
     -      ITRTYP,NTRLIN,NTRSAM,NTRFLX,ITFSRM,NTRERR(10),
     -      NLINED,NINORD,NGRIDX,NGRIDY,NCXLAB,NCYLAB,NCFPRO,
     -      NPRCOL,ICOL0,ICOLBX,ICOLPL,ICOLST,ICOLW1,ICOLW2,ICOLW3,
     -      ICOLD1,ICOLD2,ICOLD3,ICOLRB,NGBOX,
     -      LTRMS,LTRDEL,LTRINT,LTREXB,LTRCUT,TRFLAG(10),LINCAL,
     -      LFULLB,LFULLP,LFULLT,LSPLIT,LSORT,LOUTL,LEPSG,LGSTEP,
     -      LDLSRM,LDTSRM,LTRVVL
       CHARACTER*80 PARTID,PXLAB,PYLAB,PROLAB
       CHARACTER*10 PNAME
       CHARACTER*5  PRVIEW
       CHARACTER*(MXCHAR) FCNTRW
       COMMON /PARCHR/ PARTID,FCNTRW,PNAME,PXLAB,PYLAB,PROLAB,PRVIEW
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XOLD,YOLD,ZOLD,XW,YW,XDIST,YDIST,DIST2,DISMIN
       REAL DCXMIN,DCXMAX,DCYMIN,DCYMAX,Q
       INTEGER IFAIL,I,IOUT,IFLAG,ITYPE,IVOL
       LOGICAL SHIFT
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE DLCSTA ///'
*** Preset ISTAT to 0 (normal situation).
       ISTAT=0
*** Handle the case NU=1 seperately.
       IF(NU.EQ.1)THEN
*   Define the area to be used for checks later on, when NU > 1
            DDXMIN=DXMIN
            DDYMIN=DYMIN
            DDZMIN=DZMIN
            DDXMAX=DXMAX
            DDYMAX=DYMAX
            DDZMAX=DZMAX
*   Check position with respect to the planes.
            ISTAT1=-1
            ISTAT2=-1
            ISTAT3=-1
            ISTAT4=-1
            ISTAT5=-1
            ISTAT6=-1
            IF(YNPLAN(1))THEN
                 DCXMIN=COPLAN(1)
                 IF(PERX)THEN
                      DCXMIN=DCXMIN+AINT((REAL(XU(1))-COPLAN(1))/SX)*SX
                      IF(XU(1).LT.COPLAN(1))DCXMIN=DCXMIN-SX
                 ENDIF
                 IF(DCXMIN.GT.DXMIN)ISTAT1=-11
                 DDXMIN=MAX(DCXMIN,DXMIN)
            ENDIF
            IF(YNPLAN(2))THEN
                 DCXMAX=COPLAN(2)
                 IF(PERX)THEN
                      DCXMAX=DCXMAX+AINT((REAL(XU(1))-COPLAN(2))/SX)*SX
                      IF(XU(1).GT.COPLAN(2))DCXMAX=DCXMAX+SX
                 ENDIF
                 IF(DCXMAX.LT.DXMAX)ISTAT2=-12
                 DDXMAX=MIN(DCXMAX,DXMAX)
            ENDIF
            IF(YNPLAN(3))THEN
                 DCYMIN=COPLAN(3)
                 IF(PERY)THEN
                      DCYMIN=DCYMIN+AINT((REAL(YU(1))-COPLAN(3))/SY)*SY
                      IF(YU(1).LT.COPLAN(3))DCYMIN=DCYMIN-SY
                 ENDIF
                 IF(DCYMIN.GT.DYMIN)ISTAT3=-13
                 DDYMIN=MAX(DCYMIN,DYMIN)
            ENDIF
            IF(YNPLAN(4))THEN
                 DCYMAX=COPLAN(4)
                 IF(PERY)THEN
                      DCYMAX=DCYMAX+AINT((REAL(YU(1))-COPLAN(4))/SY)*SY
                      IF(YU(1).GT.COPLAN(4))DCYMAX=DCYMAX+SY
                 ENDIF
                 IF(DCYMAX.LT.DYMAX)ISTAT4=-14
                 DDYMAX=MIN(DCYMAX,DYMAX)
            ENDIF
*   Check position with respect to the tube, if it exists.
            IF(TUBE)THEN
                 CALL INTUBE(REAL(XU(1)),REAL(YU(1)),COTUBE,NTUBE,IOUT)
                 IF(IOUT.EQ.1)THEN
                      ISTAT=-15
                 ELSEIF(IOUT.NE.0)THEN
                      ISTAT=-3
                 ENDIF
            ENDIF
*   particle outside the drift area right at the start,
            IF(XU(1).LT.DDXMIN)ISTAT=ISTAT1
            IF(XU(1).GT.DDXMAX)ISTAT=ISTAT2
            IF(YU(1).LT.DDYMIN)ISTAT=ISTAT3
            IF(YU(1).GT.DDYMAX)ISTAT=ISTAT4
            IF(ZU(1).LT.DDZMIN)ISTAT=ISTAT5
            IF(ZU(1).GT.DDZMAX)ISTAT=ISTAT6
            IF(ISTAT.NE.0)RETURN
**  Check whether the particle is already very near a wire.
            ITARG=0
            DISMIN=0
            DO 10 I=1,NWIRE
*   Skip wires with the wrong charge.
            IF(LREPSK.AND.Q*E(I).GT.0.0)GOTO 10
*   First find the wire closest to where we are now.
            XW=DBLE(X(I))
            YW=DBLE(Y(I))
            SHIFT=.FALSE.
            IF(PERX)THEN
                 XDIST=XU(1)-DBLE(X(I))
                 XW=DBLE(X(I))+SX*ANINT(XDIST/SX)
                 IF(ABS(XDIST).GT.SX/2)SHIFT=.TRUE.
            ENDIF
            IF(PERY)THEN
                 YDIST=YU(1)-DBLE(Y(I))
                 YW=DBLE(Y(I))+SY*ANINT(YDIST/SY)
                 IF(ABS(YDIST).GT.SY/2)SHIFT=.TRUE.
            ENDIF
            DIST2=(XU(NU)-XW)**2+(YU(NU)-YW)**2
*   Keep track of which one is closest.
            IF(ITARG.EQ.0.OR.DIST2.LT.DISMIN)THEN
                 DISMIN=DIST2
                 IF(SHIFT)THEN
                      ITARG=I+MXWIRE
                 ELSE
                      ITARG=I
                 ENDIF
                 XTARG=XW
                 YTARG=YW
                 DTARG=D(I)
            ENDIF
*   Next find out if we have to make some last step or not.
            IF(DIST2.LE.(0.5*RTRAP*D(I))**2)THEN
                 IF(DIST2.LE.(0.5*D(I))**2)THEN
                      IF(LDEBUG)
     -                     WRITE(LUNOUT,'(''  ++++++ DLCSTA DEBUG   :'',
     -                     '' Particle is inside the wire at NU=1.'')')
                      ISTAT=I
                 ELSE
                      IF(LDEBUG)
     -                     WRITE(LUNOUT,'(''  ++++++ DLCSTA DEBUG   :'',
     -                     '' DLCWIR entered from DLCSTA at NU=1.'')')
                      CALL DLCWIR(0,Q,ITYPE)
                 ENDIF
                 RETURN
            ENDIF
10          CONTINUE
**  Check whether the point is inside a solid
            IF(NSOLID.GT.0)THEN
                 CALL CELVPT(XU(NU),YU(NU),ZU(NU),IVOL)
                 IF(IVOL.NE.0)ISTAT=2*MXWIRE+IVOL
            ENDIF
**  On first step, stop here.                      
            RETURN
       ENDIF
*** Next handle the case of NU > 1, check crossing of a whole period.
       IF((PERX.AND.ABS(XU(NU)-XU(NU-1)).GE.SX).OR.
     -      (PERY.AND.ABS(YU(NU)-YU(NU-1)).GE.SY))THEN
            PRINT *,' ###### DLCSTA ERROR   : Particle crossed more'//
     -           ' than one period ; calculation is abandoned.'
            ISTAT=-3
            RETURN
       ENDIF
*** Check that the particle is still inside the drift area, clip if not.
       IF(XU(NU).LT.DDXMIN)ISTAT=ISTAT1
       IF(XU(NU).GT.DDXMAX)ISTAT=ISTAT2
       IF(YU(NU).LT.DDYMIN)ISTAT=ISTAT3
       IF(YU(NU).GT.DDYMAX)ISTAT=ISTAT4
       IF(ZU(NU).LT.DDZMIN)ISTAT=ISTAT5
       IF(ZU(NU).GT.DDZMAX)ISTAT=ISTAT6
       IF(ISTAT.NE.0)THEN
            XOLD=XU(NU)
            YOLD=YU(NU)
            ZOLD=ZU(NU)
            CALL CLIP3D(XU(NU-1),    YU(NU-1),    ZU(NU-1),
     -                  XU(NU),      YU(NU),      ZU(NU),
     -                  DBLE(DDXMIN),DBLE(DDYMIN),DBLE(DDZMIN),
     -                  DBLE(DDXMAX),DBLE(DDYMAX),DBLE(DDZMAX),IFAIL)
            IF(IFAIL.NE.0.OR.(XOLD.EQ.XU(NU-1).AND.
     -           YOLD.EQ.YU(NU-1).AND.ZOLD.EQ.ZU(NU-1)))THEN
                 NU=NU-1
            ELSE
                 TU(NU)=TU(NU-1)+(TU(NU)-TU(NU-1))*SQRT(
     -                ((XU(NU)-XU(NU-1))**2+(YU(NU)-YU(NU-1))**2+
     -                 (ZU(NU)-ZU(NU-1))**2)/
     -                ((XOLD-XU(NU-1))**2+(YOLD-YU(NU-1))**2+
     -                 (ZOLD-ZU(NU-1))**2))
            ENDIF
            RETURN
       ENDIF
*** Left the tube ?
       IF(TUBE)THEN
            CALL INTUBE(REAL(XU(NU)),REAL(YU(NU)),COTUBE,NTUBE,IOUT)
            IF(IOUT.NE.0)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSTA DEBUG   :'',
     -                '' Particle is leaving the tube.'')')
                 CALL DLCTUB(Q,ITYPE)
                 RETURN
            ENDIF
       ENDIF
*** Check whether the point is inside a solid
       IF(NSOLID.GT.0)THEN
            CALL CELVPT(XU(NU),YU(NU),ZU(NU),IVOL)
            IF(IVOL.NE.0)THEN
                 ISTAT=2*MXWIRE+IVOL
                 RETURN
            ENDIF
       ENDIF
*** Find out whether a wire has been hit and remember the nearest wire.
       ITARG=0
       DISMIN=0
       DO 20 I=1,NWIRE
*   Skip wires with the wrong charge.
       IF(LREPSK.AND.Q*E(I).GT.0.0)GOTO 20
*   First find the wire closest to where we are now.
       XW=X(I)
       YW=Y(I)
       SHIFT=.FALSE.
       IF(PERX)THEN
            XDIST=(XU(NU)+XU(NU-1))/2-XW
            XW=XW+SX*ANINT(XDIST/SX)
            IF(ABS(XDIST).GT.SX/2)SHIFT=.TRUE.
       ENDIF
       IF(PERY)THEN
            YDIST=(YU(NU)+YU(NU-1))/2-YW
            YW=YW+SY*ANINT(YDIST/SY)
            IF(ABS(YDIST).GT.SY/2)SHIFT=.TRUE.
       ENDIF
       IF(XW+0.5*D(I).LT.DDXMIN.OR.XW-0.5*D(I).GT.DDXMAX.OR.
     -      YW+0.5*D(I).LT.DDYMIN.OR.YW-0.5*D(I).GT.DDYMAX)GOTO 20
*   Compute distance of the last point to the (replica of) wire I.
       CALL DLCMIN(XW,YW,XU(NU-1),YU(NU-1),XU(NU),YU(NU),DIST2,IFLAG)
*   Keep track of which one is closest.
       IF(ITARG.EQ.0.OR.DIST2.LT.DISMIN)THEN
            DISMIN=DIST2
            IF(SHIFT)THEN
                 ITARG=I+MXWIRE
            ELSE
                 ITARG=I
            ENDIF
            XTARG=XW
            YTARG=YW
            DTARG=D(I)
       ENDIF
*   Next find out if we have to make some last step or not.
       IF(DIST2.LE.(0.5*RTRAP*D(I))**2)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCSTA DEBUG   :'',
     -           '' Particle hit wire '',I5,'' at '',2E15.8/26X,
     -           ''distance from centre is '',E15.8,
     -           '', wire radius is '',E15.8/26X,''DLCWIR called'',
     -           '' from DLCSTA because the wire is hit.'')')
     -           I,XW,YW,SQRT(DIST2),D(I)/2.0
            IF(IPTECH.NE.4.AND.(DIST2.LE.
     -           (0.5*D(I))**2.OR.IFLAG.NE.+1))NU=NU-1
            CALL DLCWIR(0,Q,ITYPE)
            RETURN
       ENDIF
20     CONTINUE
       END
CDECK  ID>, DLCWIR.
       SUBROUTINE DLCWIR(ISKIP,Q,ITYPE)
*-----------------------------------------------------------------------
*   DLCWIR - Terminates drift line calculation by making some last steps
*            towards the surface of the wire on which it is supposed to
*            end. The precision is controlled in order to obtain a
*            good estimate of the total remaining drift-time.
*   VARIABLES : (X1,Y1)     : First point of an integration segment.
*               (XM,YM)     : Middle point of an integration segment.
*               (X2,Y2)     : Last point of an integration segment.
*               F1, FM, F2  : Velocities at (X1,Y1), (XM,YM), (X2,Y2).
*               ONWIRE      : .TRUE. if the last point is on the wire.
*               ISKIP       : Skip searching for the nearest wire and
*                             use (XTARG,YTARG) instead.
*   (Last changed on 28/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER MXSPLT
       PARAMETER (MXSPLT=10)
       DOUBLE PRECISION F1(3),FM(3),F2(3),X1,XM,X2,Y1,YM,Y2,
     -      Z1,ZM,Z2,T1,T2,DIST2,TCRUDE,XDIST,YDIST,DISMIN
       REAL Q,EX,EY,EZ,ETOT,VOLT,XWAUX,YWAUX
       INTEGER ITYPE,IFLAG,ILOC,ILOC1,ILOC2,ILOCM,I,ISKIP,ISPLIT,IWEND
       LOGICAL ONWIRE,SHIFT
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE DLCWIR ///'
*** Call dedicated routine for microscopic tracking.
       IF(IPTECH.EQ.4)THEN
            CALL DLCWIM
            RETURN
       ENDIF
*** Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   : ITARG='',
     -      I5,'' (x,y)=('',E15.8,'' , '',E15.8,''), d='',E15.8)')
     -      ITARG,XTARG,YTARG,DTARG
*** Step backwards until we have a point where the field is non-zero.
10     CONTINUE
       CALL EFIELD(REAL(XU(NU)),REAL(YU(NU)),REAL(ZU(NU)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   : NU = '',
     -      I5,'', pos = '',3E15.8,'', loc = '',I5,'', E = '',E15.8)')
     -      NU,XU(NU),YU(NU),ZU(NU),ILOC,ETOT
       IF(ILOC.NE.0.OR.ETOT.EQ.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' Last point at NU='',I5,'' is at zero field ;'',
     -           '' NU lowered by 1.'')') NU
            IF(NU.GT.1)THEN
                 NU=NU-1
                 GOTO 10
            ELSE
                 PRINT *,' !!!!!! DLCWIR WARNING : Unable to find a',
     -                ' point on the drift-line where E is not zero.'
                 ISTAT=-3
            ENDIF
       ENDIF
*** Make sure space is left for the steps to come.
       IF(NU.GE.MXLIST)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   : No'',
     -           '' storage left ; stepping to the wire not done.'')')
            ISTAT=-2
            NU=MXLIST
            RETURN
       ENDIF
*** Skip finding the wire if ISKIP=1.
       IF(ISKIP.EQ.1)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' Wire search skipped due to ISKIP='',I5)') ISKIP
            IF(ITARG.GT.MXWIRE)THEN
                 IWEND=ITARG-MXWIRE
            ELSE
                 IWEND=ITARG
            ENDIF
       ELSE
*** Find out whether the diagnosis about the target wire is correct.
            ITARG=0
            DISMIN=0
            IWEND=0
            DO 20 I=1,NWIRE
*   First find the wire closest to where we are now.
            XWAUX=X(I)
            YWAUX=Y(I)
            SHIFT=.FALSE.
            IF(PERX)THEN
                 XDIST=XU(NU)-DBLE(X(I))
                 IF(ABS(XDIST).GT.SX/2)SHIFT=.TRUE.
                 XWAUX=X(I)+SX*ANINT(XDIST/SX)
            ENDIF
            IF(PERY)THEN
                 YDIST=YU(NU)-DBLE(Y(I))
                 IF(ABS(YDIST).GT.SY/2)SHIFT=.TRUE.
                 YWAUX=Y(I)+SY*ANINT(YDIST/SY)
            ENDIF
            DIST2=(XU(NU)-XWAUX)**2+(YU(NU)-YWAUX)**2
*   Keep track of which one is closest.
            IF(ITARG.EQ.0.OR.DIST2.LT.DISMIN)THEN
                 DISMIN=DIST2
                 XTARG=XWAUX
                 YTARG=YWAUX
                 DTARG=D(I)
                 IWEND=I
                 IF(SHIFT)THEN
                      ITARG=I+MXWIRE
                 ELSE
                      ITARG=I
                 ENDIF
            ENDIF
20          CONTINUE
            IF(IWEND.EQ.0)THEN
                 PRINT *,' ###### DLCWIR ERROR   : No target wire'//
     -                ' found ; program bug - please report.'
                 ISTAT=-3
            ENDIF
       ENDIF
*** Cheat with the target wire to avoid getting into it.
       D(IWEND)=DTARG/2
**  Final stepping towards the wire starts.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   : Stepping'',
     -      '' towards wire '',I5,'' started at NU= '',I5)') IWEND,NU
       X1=XU(NU)
       Y1=YU(NU)
       Z1=ZU(NU)
       T1=TU(NU)
**  Make an estimate for a full step towards the wire.
       CALL DLCVEL(X1,Y1,Z1,F1,Q,ITYPE,ILOC1)
       IF(SQRT(F1(1)**2+F1(2)**2).LE.0.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -      '' Initial drift-velocity zero; quit on ISTAT=-3.'')')
            ISTAT=-3
            D(IWEND)=DTARG
            RETURN
       ENDIF
*   Estimate the time needed to reach the wire.
       TCRUDE=(SQRT((X1-XTARG)**2+(Y1-YTARG)**2)-DTARG/2.0)/
     -      SQRT(F1(1)**2+F1(2)**2)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   : Estimated'',
     -      '' time needed to reach the wire: '',E12.5)') TCRUDE
*   Special handling for small TCRUDE.
       IF(TCRUDE.LT.1.0E-6*TU(NU))THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' Small TCRUDE exception; no further processing.'')')
            ISTAT=ITARG
            D(IWEND)=DTARG
            RETURN
       ENDIF
*** Iteration starts here: set the number of integration divisions to 0.
       ISPLIT=0
100    CONTINUE
*   Estimate where the drift-line will end up after this time.
       X2=X1+F1(1)*TCRUDE
       Y2=Y1+F1(2)*TCRUDE
       Z2=Z1+F1(3)*TCRUDE
*   Set the flag for being in the wire to .FALSE.
       ONWIRE=.FALSE.
**  Take action depending on where we end up, first moving away.
       CALL DLCMIN(XTARG,YTARG,X1,Y1,X2,Y2,DIST2,IFLAG)
       IF(IFLAG.EQ.-1)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' Particle moves away from the wire ; quit on'',
     -           '' ISTAT=-3.'')')
            ISTAT=-3
            D(IWEND)=DTARG
            RETURN
*   Next the case the wire has been crossed.
       ELSEIF(IFLAG.EQ.0.OR.DIST2.LE.(DTARG/2)**2)THEN
            X2=XTARG-0.5*DTARG*(XTARG-X1)/
     -           SQRT((X1-XTARG)**2+(Y1-YTARG)**2)
            Y2=YTARG-0.5*DTARG*(YTARG-Y1)/
     -           SQRT((X1-XTARG)**2+(Y1-YTARG)**2)
            TCRUDE=SQRT(((X2-X1)**2+(Y2-Y1)**2)/(F1(1)**2+F1(2)**2))
            Z2=Z1+TCRUDE*F1(3)
            ONWIRE=.TRUE.
       ENDIF
**  Calculate the drift-velocity at the end point.
       CALL DLCVEL(X2,Y2,Z2,F2,Q,ITYPE,ILOC2)
**  Set a point halfway between 1 and 2 for an accuracy check.
       XM=0.5*(X1+X2)
       YM=0.5*(Y1+Y2)
       ZM=0.5*(Z1+Z2)
       CALL DLCVEL(XM,YM,ZM,FM,Q,ITYPE,ILOCM)
**  Check the location codes.
       IF(ILOC1.NE.0.OR.ILOCM.NE.0.OR.ILOC2.NE.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' ILOC position codes cause ISTAT=-3 quit: '',
     -           3I5)') ILOC1,ILOCM,ILOC2
            ISTAT=-3
            D(IWEND)=DTARG
            RETURN
       ENDIF
*   Check the non-zeroness of the velocities.
       IF(SQRT(F1(1)**2+F1(2)**2).LE.0.0.OR.
     -      SQRT(FM(1)**2+FM(2)**2).LE.0.0.OR.
     -      SQRT(F2(1)**2+F2(2)**2).LE.0.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -           '' Intermediate drift-velocity zero; ISTAT=-3.'')')
            ISTAT=-3
            D(IWEND)=DTARG
            RETURN
       ENDIF
**  Compare first and second order estimates.
       IF(ISPLIT.GE.MXSPLT.OR.SQRT((X2-X1)**2+(Y2-Y1)**2)*
     -      ABS(1.0/SQRT(F1(1)**2+F1(2)**2)-2.0/SQRT(FM(1)**2+FM(2)**2)+
     -      1.0/SQRT(F2(1)**2+F2(2)**2))/3.0.LT.1.0D-4*(1+ABS(T1)))THEN
*   Accurate enough: integrate the drift-time over this segment.
            T2=T1+SQRT((X2-X1)**2+(Y2-Y1)**2)*
     -           (1.0/SQRT(F1(1)**2+F1(2)**2)+
     -            4.0/SQRT(FM(1)**2+FM(2)**2)+
     -            1.0/SQRT(F2(1)**2+F2(2)**2))/6.0
*   Add to the drift-line if there is space left.
            IF(NU.GE.MXLIST)THEN
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -                '' No space left for ; ISTAT=-2 return.'')')
                 ISTAT=-2
                 NU=MXLIST
                 D(IWEND)=DTARG
                 RETURN
            ELSE
                 NU=NU+1
                 XU(NU)=X2
                 YU(NU)=Y2
                 ZU(NU)=Z2
                 TU(NU)=T2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -                '' Adding point '',I5,'' at '',4E15.8)')
     -                NU,XU(NU),YU(NU),ZU(NU),TU(NU)
                 IF(ONWIRE)THEN
                      ISTAT=ITARG
                      D(IWEND)=DTARG
                      IF(LDEBUG)
     -                     WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -                     '' This was the last step.'')')
                      RETURN
                 ENDIF
                 IF(LDEBUG.AND.ISPLIT.GT.0)
     -                WRITE(LUNOUT,'(''  ++++++ DLCWIR DEBUG   :'',
     -                '' Adding at ISPLIT='',I5)') ISPLIT
            ENDIF
*   Proceed with the next step.
            X1=X2
            Y1=Y2
            Z1=Z2
            T1=T2
            ILOC1=ILOC2
            F1(1)=F2(1)
            F1(2)=F2(2)
            F1(3)=F2(3)
            GOTO 100
**  Halve the step-size if the accuracy is insufficient.
       ELSE
            TCRUDE=TCRUDE/2
            ISPLIT=ISPLIT+1
            GOTO 100
       ENDIF
       END
CDECK  ID>, DLCWIM.
       SUBROUTINE DLCWIM
*-----------------------------------------------------------------------
*   DLCWIM - Terminates drift line calculation by truncating the last
*            step towards the surface of the wire inside which it has
*            landed. Version for microscopic tracking (not using the
*            drift velocity vector).
*   (Last changed on 29/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
C       logical ldebug,lident
C       integer lunout
C       parameter(ldebug=.true.,lident=.true.,lunout=6)
       REAL EX,EY,EZ,ETOT,VOLT,DIST,STEP,XDIST,YDIST
       INTEGER ILOC
       LOGICAL SHIFT
*** Identify the routine if requested.
       IF(LIDENT)PRINT *,' /// ROUTINE DLCWIM ///'
*** Check NU and print debugging output.
       IF(NU.LT.1)THEN
            PRINT *,' !!!!!! DLCWIM WARNING : Number of steps is not'//
     -           ' > 0; terminating on ISTAT=-3.'
            ISTAT=-3
            RETURN
       ENDIF
*** Ensure the last position is inside a wire.
       CALL EFIELD(REAL(XU(NU)),REAL(YU(NU)),REAL(ZU(NU)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIM DEBUG   : NU = '',
     -      I5,'', pos = '',3E15.8,'', loc = '',I5,'', E = '',E15.8)')
     -      NU,XU(NU),YU(NU),ZU(NU),ILOC,ETOT
*   Quit if not ...
       IF(ILOC.LE.0.OR.ILOC.GT.NWIRE)THEN
            IF(NU.EQ.1.AND.RTRAP.GT.1)THEN
                 PRINT *,' !!!!!! DLCDIW WARNING : Premature end of'//
     -                ' a drift-line due to a TRAP-RADIUS > 1.'
            ELSE
                 PRINT *,' !!!!!! DLCWIM WARNING : Final location is'//
     -                ' not in a wire; abandoning the drift line.'
            ENDIF
            ISTAT=-3
            RETURN
*   Otherwise establish the target wire, which can be a copy.
       ELSE
            SHIFT=.FALSE.
            IF(PERX)THEN
                 XDIST=XU(NU)-DBLE(X(ILOC))
                 IF(ABS(XDIST).GT.SX/2)SHIFT=.TRUE.
                 XTARG=X(ILOC)+SX*ANINT(XDIST/SX)
            ELSE
                 XTARG=X(ILOC)
            ENDIF
            IF(PERY)THEN
                 YDIST=YU(NU)-DBLE(Y(ILOC))
                 IF(ABS(YDIST).GT.SY/2)SHIFT=.TRUE.
                 YTARG=Y(ILOC)+SY*ANINT(YDIST/SY)
            ELSE
                 YTARG=Y(ILOC)
            ENDIF
            DTARG=D(ILOC)
            IF(SHIFT)THEN
                 ITARG=ILOC+MXWIRE
            ELSE
                 ITARG=ILOC
            ENDIF
       ENDIF
*   Debugging.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIM DEBUG   : ITARG='',
     -      I5,'' (x,y)=('',E15.8,'' , '',E15.8,''), d='',E15.8/26X,
     -      ''Last location: '',3E15.8)') ITARG,XTARG,YTARG,DTARG,
     -      XU(NU),YU(NU),ZU(NU)
*** And be sure the one-but last position is outside the wire.
10     CONTINUE
       IF(NU.LT.2)THEN
            PRINT *,' !!!!!! DLCWIM WARNING : Unable to find a',
     -           ' point on the drift-line outside the wire.'
            ISTAT=-3
            RETURN
       ENDIF
       CALL EFIELD(REAL(XU(NU-1)),REAL(YU(NU-1)),REAL(ZU(NU-1)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       IF(ILOC.NE.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCWIM DEBUG   : '',
     -           '' Going back one step to NU = '',I5,'', pos = '',
     -           3E15.8,'', loc = '',I5,'', E = '',E15.8)')
     -           NU,XU(NU),YU(NU),ZU(NU),ILOC,ETOT
            NU=NU-1
            GOTO 10
       ENDIF
*** Truncate the step
       STEP=SQRT((XU(NU)-XU(NU-1))**2+(YU(NU)-YU(NU-1))**2)
       DIST=SQRT((XTARG -XU(NU-1))**2+(YTARG -YU(NU-1))**2)
       IF(STEP.LE.0.OR.DIST.LE.0)THEN
            PRINT *,' !!!!!! DLCWIM WARNING : Zero length step or'//
     -           ' distance; drift line abandoned.'
            ISTAT=-3
            RETURN
       ENDIF
       XU(NU)=XTARG+DTARG*(XU(NU-1)-XTARG)/(2.0001*DIST)
       YU(NU)=YTARG+DTARG*(YU(NU-1)-YTARG)/(2.0001*DIST)
       ZU(NU)=ZU(NU-1)+(ZU(NU)-ZU(NU-1))*SQRT((XU(NU)-XU(NU-1))**2+
     -      (YU(NU)-YU(NU-1))**2)/STEP
       TU(NU)=TU(NU-1)+(TU(NU)-TU(NU-1))*SQRT((XU(NU)-XU(NU-1))**2+
     -      (YU(NU)-YU(NU-1))**2)/STEP
       ISTAT=ITARG
       END
CDECK  ID>, DLCEX1.
       SUBROUTINE DLCEX1(EXRATE)
*-----------------------------------------------------------------------
*   DLCEX1 - Routine returning the number of excitation for the current
*            drift line. The routine uses an adaptive Simpson style
*            integration.
*   VARIABLES : ALFA.      : Townsend coefficients (1,2 end; M middle).
*               ALFINT     : Integral of the Townsend coefficient.
*               EXRATE     : Returned excitation rates.
*   (Last changed on 24/ 8/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL TWNVEC(MXLIST),ALFA1,ALFA2,ALFAM,EXM,EYM,EZM,ETOTM,
     -      EX,EY,EZ,ETOT,BX,BY,BZ,BTOT,VOLT,GASTWN,GASVEL,DRES,
     -      BXM,BYM,BZM,BTOTM,EXVEC(MXEXG,MXLIST),EXVECM(MXEXG),
     -      EXVEC1(MXEXG),EXVEC2(MXEXG),VEL,VELM,EXRATE(MXEXG)
       DOUBLE PRECISION XAUX1,XAUX2,YAUX1,YAUX2,STEP,ALFINT,
     -      XPOS1,XPOS2,XPOSM,YPOS1,YPOS2,YPOSM,ZPOSM,ZPOS1,ZPOS2,
     -      TOTSTP,CRUDE,EXCCR(MXEXG),STACK(MXSTCK,4+MXEXG),SINT
       INTEGER LOCVEC(MXLIST),ISTACK,NSTACK,ILOCRS,NFC,ILOCM,IU,ILOC,
     -      I,J,STRLEN
       EXTERNAL GASTWN,GASVEL,STRLEN
*** Identify the routine
       IF(LIDENT)PRINT *,' /// ROUTINE DLCEX1 ///'
*** Return straight away if there is only one data point.
       IF(NU.LE.1)RETURN
*   Check that this is an electron drift line.
       IF(IPTYPE.NE.1.OR.IPTECH.NE.1)THEN
            PRINT *,' !!!!!! DLCEX1 WARNING : This is not an RKF'//
     -           ' integrated electron drift line; no integration.'
            RETURN
       ENDIF
*** Obtain a very rough estimate of the result.
       CRUDE=0.0
       DO 110 J=1,NEXGAS
       EXCCR(J)=0
110    CONTINUE
       DO 100 IU=1,NU
*   Evaluate the fields.
       CALL EFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       CALL BFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -      BX,BY,BZ,BTOT)
*   Cheat in case the point is located inside a wire.
       IF(ILOC.GT.0.AND.ILOC.LE.MXWIRE)THEN
            DRES=D(ILOC)
            ILOCRS=ILOC
            D(ILOCRS)=0.0
            CALL EFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           EX,EY,EZ,ETOT,VOLT,0,ILOC)
            CALL BFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           BX,BY,BZ,BTOT)
            D(ILOCRS)=DRES
            IF(LDEBUG)PRINT *,' ++++++ DLCEX1 DEBUG   : Drift-line',
     -           ' data point in wire ',ILOCRS,' detected; d=0 fix.'
       ENDIF
*   In case this didn't help, just log the failure.
       LOCVEC(IU)=ILOC
       IF(ILOC.NE.0)THEN
            PRINT *,' !!!!!! DLCEX1 WARNING : Skipping a drift line'//
     -           ' point (',IU,'/',NU,') outside the drift area.'
            GOTO 100
       ENDIF
*   Calculate Townsend coefficients and excitation rates.
       IF(POLAR)THEN
            TWNVEC(IU)=GASTWN(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ)
            VEL=GASVEL(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ)
            CALL GASEXR(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ,EXVEC(1,IU))
            IF(IU.GT.1)THEN
                 CALL CF2RTC(XU(IU),YU(IU),XAUX1,YAUX1,1)
                 CALL CF2RTC(XU(IU-1),YU(IU-1),XAUX2,YAUX2,1)
                 STEP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -                (ZU(IU)-ZU(IU-1))**2)
            ENDIF
       ELSE
            TWNVEC(IU)=GASTWN(EX,EY,EZ,BX,BY,BZ)
            VEL=GASVEL(EX,EY,EZ,BX,BY,BZ)
            CALL GASEXR(EX,EY,EZ,BX,BY,BZ,EXVEC(1,IU))
            IF(IU.GT.1)STEP=SQRT((XU(IU)-XU(IU-1))**2+
     -           (YU(IU)-YU(IU-1))**2+(ZU(IU)-ZU(IU-1))**2)
       ENDIF
       IF(VEL.LE.0)THEN
            PRINT *,' !!!!!! DLCEX1 WARNING : Skipping a drift line'//
     -           ' point (',IU,'/',NU,') with v <= 0.'
            GOTO 100
       ENDIF
*   Convert rates from THz to 1/cm via v in cm/microsec.
       DO 130 J=1,NEXGAS
       EXVEC(J,IU)=1.0E6*EXVEC(J,IU)/VEL
       IF(EXVEC(J,IU).LT.0)THEN
            PRINT *,' !!!!!! DLCEX1 WARNING : Met negative'//
     -           ' excitation rate ',EXVEC(J,IU),' THz of level ',J,
     -           ' at step ',IU,'/',NU,'; set to 0.'
            EXVEC(J,IU)=0
       ENDIF
130    CONTINUE
*   Compute the gain
       IF(IU.GT.1)THEN
            IF(CRUDE.LT.40.0)THEN
                 DO 120 J=1,NEXGAS
                 CALL INTEXC(DBLE(TWNVEC(IU-1)),DBLE(TWNVEC(IU)),
     -                DBLE(EXVEC(J,IU-1)),DBLE(EXVEC(J,IU)),
     -                STEP,EXP(CRUDE),SINT)
                      EXCCR(J)=EXCCR(J)+SINT
120              CONTINUE
            ELSE
                 PRINT *,' !!!!!! DLCEX1 WARNING : Reduced precision'//
     -                ' in the integration of the excitation rates.'
            ENDIF
            CRUDE=CRUDE+STEP*(TWNVEC(IU)+TWNVEC(IU-1))/2.0
       ENDIF
*   Compute the excitations
100    CONTINUE
       NFC=NU
*** Print a heading for the debugging output.
       IF(LDEBUG)THEN
            PRINT *,' ++++++ DLCEX1 DEBUG   : Crude rates:'
            DO 220 I=1,NEXGAS
            PRINT *,' Level ',I,': ',EXCCR(I),' (',
     -           DSCEXG(I)(1:STRLEN(DSCEXG(I))),')'
220         CONTINUE
            PRINT *,' ++++++ DLCEX1 DEBUG   : Crude gain: ',
     -           EXP(MIN(40.0,CRUDE))
            PRINT *,' ++++++ DLCEX1 DEBUG   : Townsend integration',
     -           ' debugging output follows:'
            PRINT *,' '
            PRINT *,'  IU  loc              XU(IU)'//
     -           '              YU(IU)'//
     -           '              ZU(IU)'//
     -           ' number of electrons'
            PRINT *,'                         [cm]'//
     -           '                [cm]'//
     -           '                [cm]'//
     -           '           [numeric]'
            PRINT *,' '
            PRINT '(2(2X,I3),3(5X,E15.8))',1,LOCVEC(1),XU(1),YU(1),ZU(1)
       ENDIF
*** Initialise the sum ALFINT
       ALFINT=0.0
       DO 210 J=1,NEXGAS
       EXCCR(J)=0
210    CONTINUE
*** Loop over the whole drift-line.
       ISTACK=0
       DO 10 IU=1,NU-1
       IF(LOCVEC(IU).NE.0.OR.LOCVEC(IU+1).NE.0)GOTO 30
*   Initial values for the position.
       XPOS1=XU(IU)
       YPOS1=YU(IU)
       ZPOS1=ZU(IU)
       ALFA1=TWNVEC(IU)
       XPOS2=XU(IU+1)
       YPOS2=YU(IU+1)
       ZPOS2=ZU(IU+1)
       ALFA2=TWNVEC(IU+1)
       DO 160 J=1,NEXGAS
       EXVEC1(J)=EXVEC(J,IU)
       EXVEC2(J)=EXVEC(J,IU+1)
160    CONTINUE
*   Calculate the total steplength, in Cartesian coordinates.
       IF(POLAR)THEN
            CALL CF2RTC(XPOS1,YPOS1,XAUX1,YAUX1,1)
            CALL CF2RTC(XPOS2,YPOS2,XAUX2,YAUX2,1)
            TOTSTP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -           (ZPOS2-ZPOS1)**2)
       ELSE
            TOTSTP=SQRT((XPOS2-XPOS1)**2+(YPOS2-YPOS1)**2+
     -           (ZPOS2-ZPOS1)**2)
       ENDIF
*   Return at this point of further refinement is needed.
       NSTACK=0
20     CONTINUE
*   Set the new middle point, to be used for comparison.
       XPOSM=0.5*(XPOS1+XPOS2)
       YPOSM=0.5*(YPOS1+YPOS2)
       ZPOSM=0.5*(ZPOS1+ZPOS2)
*   Compute the field and the Townsend coeff. at the middle point.
       CALL EFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -      EXM,EYM,EZM,ETOTM,VOLT,0,ILOCM)
       CALL BFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -      BXM,BYM,BZM,BTOTM)
       NFC=NFC+1
*   Cheat in case the point is located inside a wire.
       IF(ILOCM.GT.0.AND.ILOCM.LE.MXWIRE)THEN
            DRES=D(ILOCM)
            ILOCRS=ILOCM
            D(ILOCRS)=0.0
            CALL EFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -           EXM,EYM,EZM,ETOTM,VOLT,0,ILOCM)
            CALL BFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -           BXM,BYM,BZM,BTOTM)
            NFC=NFC+1
            D(ILOCRS)=DRES
            IF(LDEBUG)PRINT *,' ++++++ DLCEX1 DEBUG   : Intermediate',
     -           ' point in wire ',ILOCRS,' detected; d=0 fix.'
       ENDIF
*   Skip this step in case the ILOC is not due to a wire.
       IF(ILOCM.NE.0)GOTO 30
       IF(POLAR)THEN
            ALFAM=GASTWN(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM)
            VELM=GASVEL(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM)
            CALL GASEXR(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM,EXVECM)
       ELSE
            ALFAM=GASTWN(EXM,EYM,EZM,BXM,BYM,BZM)
            VELM=GASVEL(EXM,EYM,EZM,BXM,BYM,BZM)
            CALL GASEXR(EXM,EYM,EZM,BXM,BYM,BZM,EXVECM)
       ENDIF
*   Convert rates from THz to 1/cm via v in cm/microsec.
       DO 140 J=1,NEXGAS
       EXVECM(J)=1.0E6*EXVECM(J)/VELM
       IF(EXVECM(J).LT.0)THEN
            PRINT *,' !!!!!! DLCEX1 WARNING : Met negative'//
     -           ' excitation rate ',EXVECM(J),' THz of level ',J,
     -           '; set to 0.'
            EXVECM(J)=0
       ENDIF
140    CONTINUE
*   Compare first and second order estimates, divide if too large.
       IF(NSTACK.LT.MIN(MXSTCK,MXTWNS).AND.EPSTWI*CRUDE.LT.
     -      TOTSTP*ABS(ALFA1-2.0*ALFAM+ALFA2)/3.0)THEN
            NSTACK=NSTACK+1
            ISTACK=MAX(ISTACK,NSTACK)
            STACK(NSTACK,1)=XPOS2
            STACK(NSTACK,2)=YPOS2
            STACK(NSTACK,3)=ZPOS2
            STACK(NSTACK,4)=ALFA2
            XPOS2=XPOSM
            YPOS2=YPOSM
            ZPOS2=ZPOSM
            ALFA2=ALFAM
            DO 170 J=1,NEXGAS
            STACK(NSTACK,4+J)=EXVEC2(J)
            EXVEC2(J)=EXVECM(J)
170         CONTINUE
            GOTO 20
*   No further subdevision is required, transform polar coordinates.
       ELSE
*   Make sure the distances are measured in cartesian coordinates.
            IF(POLAR)THEN
                 CALL CF2RTC(XPOS1,YPOS1,XAUX1,YAUX1,1)
                 CALL CF2RTC(XPOS2,YPOS2,XAUX2,YAUX2,1)
                 STEP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -                (ZPOS2-ZPOS1)**2)
            ELSE
                 STEP=SQRT((XPOS2-XPOS1)**2+(YPOS2-YPOS1)**2+
     -                (ZPOS2-ZPOS1)**2)
            ENDIF
*   Add the new rates
            IF(ALFINT.LT.40.0)THEN
                 DO 150 J=1,NEXGAS
                 CALL INTEXC(DBLE(ALFA1),DBLE(ALFAM),
     -                DBLE(EXVEC1(J)),DBLE(EXVECM(J)),STEP/2,
     -                EXP(ALFINT),SINT)
                 EXCCR(J)=EXCCR(J)+SINT
                 CALL INTEXC(DBLE(ALFAM),DBLE(ALFA2),
     -                DBLE(EXVECM(J)),DBLE(EXVEC2(J)),STEP/2,
     -                EXP(ALFINT+STEP*(5.0*ALFA1+8.0*ALFAM-ALFA2)/24.0),
     -                SINT)
                 EXCCR(J)=EXCCR(J)+SINT
150              CONTINUE
            ELSE
                 PRINT *,' !!!!!! DLCEX1 WARNING : Reduced precision'//
     -                ' in the integration of the excitation rates.'
            ENDIF
*   Add the new term to the integral.
            ALFINT=ALFINT+STEP*(ALFA1+4.0*ALFAM+ALFA2)/6.0
*   Continue with the next segment (if complete) or the next subsegment.
            XPOS1=XPOS2
            YPOS1=YPOS2
            ZPOS1=ZPOS2
            ALFA1=ALFA2
            DO 180 J=1,NEXGAS
            EXVEC1(J)=EXVEC2(J)
180         CONTINUE
            IF(NSTACK.GT.0)THEN
                 XPOS2=STACK(NSTACK,1)
                 YPOS2=STACK(NSTACK,2)
                 ZPOS2=STACK(NSTACK,3)
                 ALFA2=STACK(NSTACK,4)
                 DO 190 J=1,NEXGAS
                 EXVEC2(J)=STACK(NSTACK,4+J)
190              CONTINUE
                 NSTACK=NSTACK-1
                 GOTO 20
            ENDIF
       ENDIF
*   Continue with the next segment.
30     CONTINUE
*   Print some debugging output.
       IF(LDEBUG)PRINT '(2I5,4(5X,E15.8))',IU+1,LOCVEC(IU+1),XU(IU+1),
     -      YU(IU+1),ZU(IU+1),EXP(MIN(50.0D0,ALFINT))
10     CONTINUE
*** Make a single precision copy.
       IF(LDEBUG)PRINT *,' ++++++ DLCEX1 DEBUG   : EFIELD calls: ',NFC,
     -      ', deepest stack: ',ISTACK
       DO 200 I=1,NEXGAS
       EXRATE(I)=REAL(EXCCR(I))
       IF(LDEBUG)PRINT *,' ++++++ DLCEX1 DEBUG   : Final rate ',I,': ',
     -      EXRATE(I)
200    CONTINUE
       END
CDECK  ID>, DLCIO1.
       SUBROUTINE DLCIO1(IORATE)
*-----------------------------------------------------------------------
*   DLCIO1 - Routine returning the number of ionisations for the current
*            drift line. The routine uses an adaptive Simpson style
*            integration.
*   VARIABLES : ALFA.      : Townsend coefficients (1,2 end; M middle).
*               ALFINT     : Integral of the Townsend coefficient.
*               IORATE     : Returned rates.
*   (Last changed on  1/ 3/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL TWNVEC(MXLIST),ALFA1,ALFA2,ALFAM,EXM,EYM,EZM,ETOTM,
     -      EX,EY,EZ,ETOT,BX,BY,BZ,BTOT,VOLT,GASTWN,GASVEL,DRES,
     -      BXM,BYM,BZM,BTOTM,IOVEC(MXIOG,MXLIST),IOVECM(MXIOG),
     -      IOVEC1(MXIOG),IOVEC2(MXIOG),VEL,VELM,IORATE(MXIOG)
       DOUBLE PRECISION XAUX1,XAUX2,YAUX1,YAUX2,STEP,ALFINT,
     -      XPOS1,XPOS2,XPOSM,YPOS1,YPOS2,YPOSM,ZPOSM,ZPOS1,ZPOS2,
     -      TOTSTP,CRUDE,IONCR(MXIOG),STACK(MXSTCK,4+MXIOG),SINT
       INTEGER LOCVEC(MXLIST),ISTACK,NSTACK,ILOCRS,NFC,ILOCM,IU,ILOC,
     -      I,J,STRLEN
       EXTERNAL GASTWN,GASVEL,STRLEN
*** Identify the routine
       IF(LIDENT)PRINT *,' /// ROUTINE DLCIO1 ///'
*** Default results.
       DO 110 J=1,NIOGAS
       IONCR(J)=0
110    CONTINUE
*** Return straight away if there is only one data point.
       IF(NU.LE.1)RETURN
*   Check that this is an electron drift line.
       IF(IPTYPE.NE.1.OR.IPTECH.NE.1)THEN
            PRINT *,' !!!!!! DLCIO1 WARNING : This is not an RKF'//
     -           ' integrated electron drift line; no integration.'
            RETURN
       ENDIF
*** Obtain a very rough estimate of the result.
       CRUDE=0.0
       DO 100 IU=1,NU
*   Evaluate the fields.
       CALL EFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -      EX,EY,EZ,ETOT,VOLT,0,ILOC)
       CALL BFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -      BX,BY,BZ,BTOT)
*   Cheat in case the point is located inside a wire.
       IF(ILOC.GT.0.AND.ILOC.LE.MXWIRE)THEN
            DRES=D(ILOC)
            ILOCRS=ILOC
            D(ILOCRS)=0.0
            CALL EFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           EX,EY,EZ,ETOT,VOLT,0,ILOC)
            CALL BFIELD(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           BX,BY,BZ,BTOT)
            D(ILOCRS)=DRES
            IF(LDEBUG)PRINT *,' ++++++ DLCIO1 DEBUG   : Drift-line',
     -           ' data point in wire ',ILOCRS,' detected; d=0 fix.'
       ENDIF
*   In case this didn't help, just log the failure.
       LOCVEC(IU)=ILOC
*   Calculate Townsend coefficients and ionisation rates.
       IF(POLAR)THEN
            TWNVEC(IU)=GASTWN(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ)
            VEL=GASVEL(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ)
            CALL GASIOR(EX/EXP(REAL(XU(IU))),EY/EXP(REAL(XU(IU))),
     -           EZ,BX,BY,BZ,IOVEC(1,IU))
            IF(IU.GT.1)THEN
                 CALL CF2RTC(XU(IU),YU(IU),XAUX1,YAUX1,1)
                 CALL CF2RTC(XU(IU-1),YU(IU-1),XAUX2,YAUX2,1)
                 STEP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -                (ZU(IU)-ZU(IU-1))**2)
            ENDIF
       ELSE
            TWNVEC(IU)=GASTWN(EX,EY,EZ,BX,BY,BZ)
            VEL=GASVEL(EX,EY,EZ,BX,BY,BZ)
            CALL GASIOR(EX,EY,EZ,BX,BY,BZ,IOVEC(1,IU))
            IF(IU.GT.1)STEP=SQRT((XU(IU)-XU(IU-1))**2+
     -           (YU(IU)-YU(IU-1))**2+(ZU(IU)-ZU(IU-1))**2)
       ENDIF
*   Convert rates from THz to 1/cm via v in cm/microsec.
       DO 130 J=1,NIOGAS
       IOVEC(J,IU)=1.0E6*IOVEC(J,IU)/VEL
       IF(IOVEC(J,IU).LT.0)THEN
            PRINT *,' !!!!!! DLCIO1 WARNING : Met negative'//
     -           ' ionisation rate ',IOVEC(J,IU),' THz of level ',J,
     -           ' at step ',IU,'/',NU,'; set to 0.'
            IOVEC(J,IU)=0
       ENDIF
130    CONTINUE
*   Compute the gain
       IF(IU.GT.1)THEN
            IF(CRUDE.LT.40.0)THEN
                 DO 120 J=1,NIOGAS
                 CALL INTEXC(DBLE(TWNVEC(IU-1)),DBLE(TWNVEC(IU)),
     -                DBLE(IOVEC(J,IU-1)),DBLE(IOVEC(J,IU)),
     -                STEP,EXP(CRUDE),SINT)
                      IONCR(J)=IONCR(J)+SINT
120              CONTINUE
            ELSE
                 PRINT *,' !!!!!! DLCIO1 WARNING : Reduced precision'//
     -                ' in the integration of the ionisation rates.'
            ENDIF
            CRUDE=CRUDE+STEP*(TWNVEC(IU)+TWNVEC(IU-1))/2.0
       ENDIF
*   Compute the ionisations
100    CONTINUE
       NFC=NU
*** Print a heading for the debugging output.
       IF(LDEBUG)THEN
            PRINT *,' ++++++ DLCIO1 DEBUG   : Crude rates:'
            DO 220 I=1,NIOGAS
            PRINT *,' Level ',I,': ',IONCR(I),' (',
     -           DSCIOG(I)(1:STRLEN(DSCIOG(I))),')'
220         CONTINUE
            PRINT *,' ++++++ DLCIO1 DEBUG   : Crude gain: ',
     -           EXP(MIN(40.0,CRUDE))
            PRINT *,' ++++++ DLCIO1 DEBUG   : Townsend integration',
     -           ' debugging output follows:'
            PRINT *,' '
            PRINT *,'  IU  loc              XU(IU)'//
     -           '              YU(IU)'//
     -           '              ZU(IU)'//
     -           ' number of electrons'
            PRINT *,'                         [cm]'//
     -           '                [cm]'//
     -           '                [cm]'//
     -           '           [numeric]'
            PRINT *,' '
            PRINT '(2(2X,I3),3(5X,E15.8))',1,LOCVEC(1),XU(1),YU(1),ZU(1)
       ENDIF
*** Initialise the sum ALFINT
       ALFINT=0.0
       DO 210 J=1,NIOGAS
       IONCR(J)=0
210    CONTINUE
*** Loop over the whole drift-line.
       ISTACK=0
       DO 10 IU=1,NU-1
       IF(LOCVEC(IU).NE.0.OR.LOCVEC(IU+1).NE.0)GOTO 30
*   Initial values for the position.
       XPOS1=XU(IU)
       YPOS1=YU(IU)
       ZPOS1=ZU(IU)
       ALFA1=TWNVEC(IU)
       XPOS2=XU(IU+1)
       YPOS2=YU(IU+1)
       ZPOS2=ZU(IU+1)
       ALFA2=TWNVEC(IU+1)
       DO 160 J=1,NIOGAS
       IOVEC1(J)=IOVEC(J,IU)
       IOVEC2(J)=IOVEC(J,IU+1)
160    CONTINUE
*   Calculate the total steplength, in Cartesian coordinates.
       IF(POLAR)THEN
            CALL CF2RTC(XPOS1,YPOS1,XAUX1,YAUX1,1)
            CALL CF2RTC(XPOS2,YPOS2,XAUX2,YAUX2,1)
            TOTSTP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -           (ZPOS2-ZPOS1)**2)
       ELSE
            TOTSTP=SQRT((XPOS2-XPOS1)**2+(YPOS2-YPOS1)**2+
     -           (ZPOS2-ZPOS1)**2)
       ENDIF
*   Return at this point of further refinement is needed.
       NSTACK=0
20     CONTINUE
*   Set the new middle point, to be used for comparison.
       XPOSM=0.5*(XPOS1+XPOS2)
       YPOSM=0.5*(YPOS1+YPOS2)
       ZPOSM=0.5*(ZPOS1+ZPOS2)
*   Compute the field and the Townsend coeff. at the middle point.
       CALL EFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -      EXM,EYM,EZM,ETOTM,VOLT,0,ILOCM)
       CALL BFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -      BXM,BYM,BZM,BTOTM)
       NFC=NFC+1
*   Cheat in case the point is located inside a wire.
       IF(ILOCM.GT.0.AND.ILOCM.LE.MXWIRE)THEN
            DRES=D(ILOCM)
            ILOCRS=ILOCM
            D(ILOCRS)=0.0
            CALL EFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -           EXM,EYM,EZM,ETOTM,VOLT,0,ILOCM)
            CALL BFIELD(REAL(XPOSM),REAL(YPOSM),REAL(ZPOSM),
     -           BXM,BYM,BZM,BTOTM)
            NFC=NFC+1
            D(ILOCRS)=DRES
            IF(LDEBUG)PRINT *,' ++++++ DLCIO1 DEBUG   : Intermediate',
     -           ' point in wire ',ILOCRS,' detected; d=0 fix.'
       ENDIF
*   Skip this step in case the ILOC is not due to a wire.
       IF(ILOCM.NE.0)GOTO 30
       IF(POLAR)THEN
            ALFAM=GASTWN(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM)
            VELM=GASVEL(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM)
            CALL GASIOR(EXM/EXP(REAL(XPOSM)),EYM/EXP(REAL(XPOSM)),EZM,
     -           BXM,BYM,BZM,IOVECM)
       ELSE
            ALFAM=GASTWN(EXM,EYM,EZM,BXM,BYM,BZM)
            VELM=GASVEL(EXM,EYM,EZM,BXM,BYM,BZM)
            CALL GASIOR(EXM,EYM,EZM,BXM,BYM,BZM,IOVECM)
       ENDIF
*   Convert rates from THz to 1/cm via v in cm/microsec.
       DO 140 J=1,NIOGAS
       IOVECM(J)=1.0E6*IOVECM(J)/VELM
       IF(IOVECM(J).LT.0)THEN
            PRINT *,' !!!!!! DLCIO1 WARNING : Met negative'//
     -           ' ionisation rate ',IOVECM(J),' THz of level ',J,
     -           '; set to 0.'
            IOVECM(J)=0
       ENDIF
140    CONTINUE
*   Compare first and second order estimates, divide if too large.
       IF(NSTACK.LT.MIN(MXSTCK,MXTWNS).AND.EPSTWI*CRUDE.LT.
     -      TOTSTP*ABS(ALFA1-2.0*ALFAM+ALFA2)/3.0)THEN
            NSTACK=NSTACK+1
            ISTACK=MAX(ISTACK,NSTACK)
            STACK(NSTACK,1)=XPOS2
            STACK(NSTACK,2)=YPOS2
            STACK(NSTACK,3)=ZPOS2
            STACK(NSTACK,4)=ALFA2
            XPOS2=XPOSM
            YPOS2=YPOSM
            ZPOS2=ZPOSM
            ALFA2=ALFAM
            DO 170 J=1,NIOGAS
            STACK(NSTACK,4+J)=IOVEC2(J)
            IOVEC2(J)=IOVECM(J)
170         CONTINUE
            GOTO 20
*   No further subdevision is required, transform polar coordinates.
       ELSE
*   Make sure the distances are measured in cartesian coordinates.
            IF(POLAR)THEN
                 CALL CF2RTC(XPOS1,YPOS1,XAUX1,YAUX1,1)
                 CALL CF2RTC(XPOS2,YPOS2,XAUX2,YAUX2,1)
                 STEP=SQRT((XAUX2-XAUX1)**2+(YAUX2-YAUX1)**2+
     -                (ZPOS2-ZPOS1)**2)
            ELSE
                 STEP=SQRT((XPOS2-XPOS1)**2+(YPOS2-YPOS1)**2+
     -                (ZPOS2-ZPOS1)**2)
            ENDIF
*   Add the new rates
            IF(ALFINT+STEP*(ALFA1+2*ALFAM).LT.40.0)THEN
                 DO 150 J=1,NIOGAS
                 CALL INTEXC(DBLE(ALFA1),DBLE(ALFAM),
     -                DBLE(IOVEC1(J)),DBLE(IOVECM(J)),STEP/2,
     -                EXP(ALFINT),SINT)
                 IONCR(J)=IONCR(J)+SINT
                 CALL INTEXC(DBLE(ALFAM),DBLE(ALFA2),
     -                DBLE(IOVECM(J)),DBLE(IOVEC2(J)),STEP/2,
     -                EXP(ALFINT+STEP*(5.0*ALFA1+8.0*ALFAM-ALFA2)/24.0),
     -                SINT)
                 IONCR(J)=IONCR(J)+SINT
150              CONTINUE
            ELSE
                 PRINT *,' !!!!!! DLCIO1 WARNING : Reduced precision'//
     -                ' in the integration of the ionisation rates.'
            ENDIF
*   Add the new term to the integral.
            ALFINT=ALFINT+STEP*(ALFA1+4.0*ALFAM+ALFA2)/6.0
*   Continue with the next segment (if complete) or the next subsegment.
            XPOS1=XPOS2
            YPOS1=YPOS2
            ZPOS1=ZPOS2
            ALFA1=ALFA2
            DO 180 J=1,NIOGAS
            IOVEC1(J)=IOVEC2(J)
180         CONTINUE
            IF(NSTACK.GT.0)THEN
                 XPOS2=STACK(NSTACK,1)
                 YPOS2=STACK(NSTACK,2)
                 ZPOS2=STACK(NSTACK,3)
                 ALFA2=STACK(NSTACK,4)
                 DO 190 J=1,NIOGAS
                 IOVEC2(J)=STACK(NSTACK,4+J)
190              CONTINUE
                 NSTACK=NSTACK-1
                 GOTO 20
            ENDIF
       ENDIF
*   Continue with the next segment.
30     CONTINUE
*   Print some debugging output.
       IF(LDEBUG)PRINT '(2I5,4(5X,E15.8))',IU+1,LOCVEC(IU+1),XU(IU+1),
     -      YU(IU+1),ZU(IU+1),EXP(MIN(50.0D0,ALFINT))
10     CONTINUE
*** Make a single precision copy.
       IF(LDEBUG)PRINT *,' ++++++ DLCIO1 DEBUG   : EFIELD calls: ',NFC,
     -      ', deepest stack: ',ISTACK
       DO 200 I=1,NIOGAS
       IORATE(I)=REAL(IONCR(I))
       IF(LDEBUG)PRINT *,' ++++++ DLCIO1 DEBUG   : Final rate ',I,': ',
     -      IORATE(I)
200    CONTINUE
       END
CDECK  ID>, INTEXC.
       SUBROUTINE INTEXC(A1,A2,S1,S2,STEP,N1,SINT)
*-----------------------------------------------------------------------
*   INTEXC - Integrates excitation rates over a step over an
*            underlying avalanche. Uses a set of approximations
*            to evaluate the analytic expressions that assume a
*            linear dependence of alpha and rate.
*            All expressions computed with Mathematica.
*   (Last changed on 24/ 8/09.)
*-----------------------------------------------------------------------
       implicit none
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION A1,A2,DA,S1,S2,DS,N1,STEP,ERFIR,ERF,SINT
       EXTERNAL ERFIR
       INTRINSIC ERF,ERFC
*** Protect against incorrect arguments and overflow
       IF(STEP.EQ.0)THEN
            SINT=0
            RETURN
       ELSEIF(A1.LT.0.OR.A2.LT.0.OR.S1.LT.0.OR.S2.LT.0.OR.STEP.LT.0)THEN
            PRINT *,' !!!!!! INTEXC WARNING : Incorrect arguments'//
     -           ' received; no evaluation.'
            SINT=0
            RETURN
       ELSEIF(STEP*MAX(A1,A2).GT.40.0)THEN
            PRINT *,' !!!!!! INTEXC WARNING : Can not integrate'//
     -           ' without overflow; no evaluation.'
            SINT=0
            RETURN
       ENDIF
*** Compute steps.
       DA=(A2-A1)/STEP
       DS=(S2-S1)/STEP
*** Various formulae: increasing alpha using reduced Erfi formulae.
       IF(DA.GT.0)THEN
C            print *,' da > 0'
            SINT=N1*(EXP(A1*STEP+DA*STEP**2/2.0)-1.0)*DS/DA +
     -           N1*SQRT(PI/2.0)*(A1*DS-S1*DA)*(
     -           ERFIR(A1/SQRT(2.0*DA))-
     -           EXP(A1*STEP+DA*STEP**2/2.0)*
     -           ERFIR((A1+DA*STEP)/SQRT(2.0*DA)))/SQRT(DA)**3
*   Constant alpha without gain.
       ELSEIF(A1.EQ.0.AND.DA.EQ.0)THEN
C            print *,' a = 0, da = 0'
            SINT=N1*STEP*(S1+DS*STEP/2.0)
       ELSEIF(DA.EQ.0)THEN
*   Constant alpha and gain.
C            print *,' a > 0, da = 0'
            SINT=N1*(DS-A1*S1+EXP(A1*STEP)*(A1*S1+DS*(A1*STEP-1.0)))/
     -           A1**2
*   Tiny alpha decrease, using reduced Erfc asymptotic approximation.
       ELSEIF(A1/SQRT(-2.0*DA).GT.8.OR.
     -      (A1+DA*STEP)/SQRT(-2.0*DA).GT.8)THEN
C            print *,' very small da < 0: ',a1/sqrt(-2.0*da),
C     -           (a1+da*step)/sqrt(-2.0*da)
            SINT=N1*(EXP(A1*STEP+DA*STEP**2/2.0)-1.0)*DS/DA +
     -           N1*SQRT(2.0)*(A1*DS-S1*DA)*
     -           (EXP(A1*STEP+DA*STEP**2/2.0)/
     -              ((A1+DA*STEP)/SQRT(-2.0*DA)+
     -              SQRT((A1+DA*STEP)**2/(-2.0*DA)+1.6))-
     -           1.0/(A1/SQRT(-2.0*DA)+SQRT(A1**2/(-2.0*DA)+1.6)))/
     -           SQRT(-DA)**3
*   Small alpha decrease, using Erfc regular expression.
       ELSEIF(A1/SQRT(-2.0*DA).GT.3.OR.
     -      (A1+DA*STEP)/SQRT(-2.0*DA).GT.3)THEN
C            print *,' small da < 0: ',a1/sqrt(-2.0*da),
C     -           (a1+da*step)/sqrt(-2.0*da)
            SINT=N1*(EXP(A1*STEP+DA*STEP**2/2.0)-1.0)*DS/DA +
     -           N1*SQRT(PI/2.0)*(A1*DS-S1*DA)*EXP(-A1**2/(2*DA))*
     -           (ERFC((A1+DA*STEP)/SQRT(-2.0*DA))-
     -           ERFC(A1/SQRT(-2.0*DA)))/SQRT(-DA)**3
*   Other alpha decrease, using Erf expressions.
       ELSE
C            print *,' da < 0'
            SINT=N1*(EXP(A1*STEP+DA*STEP**2/2.0)-1.0)*DS/DA +
     -           N1*SQRT(PI/2.0)*(A1*DS-S1*DA)*EXP(-A1**2/(2*DA))*
     -           (ERF(A1/SQRT(-2.0*DA))-
     -           ERF((A1+DA*STEP)/SQRT(-2.0*DA)))/SQRT(-DA)**3
       ENDIF
C      print *,' alpha: ',A1,A2,', exc/v: ',S1,S2,', step: ',STEP,
C     -     ', n: ',N1,', sint: ',sint
       END
CDECK  ID>, ERFIR.
       DOUBLE PRECISION FUNCTION ERFIR(X)
*-----------------------------------------------------------------------
*   ERFIR  - Error function of imaginary argument erfi, divided by the
*            exponential term exp(x**2).
*
*            Repeated fraction and asymptotic series expansion from
*            Mathematica and Mathworld documentation.
*   (Last changed on 26/ 2/08.)
*-----------------------------------------------------------------------
       implicit none
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION X,X2,FRAC
       INTEGER I
*** Special cases
       IF(X.EQ.0)THEN
            ERFIR=0
*** Asymptotic power series
      ELSEIF(ABS(X).GT.5)THEN
           ERFIR = (1.0/X + 1.0/(2.0*X**3) + 3.0/(4.0*X**5) +
     -          15.0/(8.0*X**7) + 105.0/(16.0*X**9) +
     -          945.0/(32.0*X**11) + 10395.0/(64.0*X**13) +
     -          135135.0/(132.0*X**15))/SQRT(PI)
*** Continued fraction
       ELSE
            X2 = X**2
            FRAC=1.0
            DO 10 I=52,4,-4
            FRAC=DBLE(I-3)+DBLE(I-2)*X2/(DBLE(I-1)-DBLE(I)*X2/FRAC)
10          CONTINUE
            ERFIR=2.0*X/(SQRT(PI)*FRAC)
       ENDIF
       END
CDECK  ID>, SIGADD.
       SUBROUTINE SIGADD(ISW,CROSS,NSIG,TIME,SIG,Q,TMIN,TSHIFT,IFAIL)
*-----------------------------------------------------------------------
*   SIGADD - Adds a signal to the current signal banks.
*   (Last changed on 27/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER ISW,NSIG,IFAIL,I,J,MSIG,KIORD
       REAL Q,TMIN,TSHIFT
       LOGICAL CROSS
       DOUBLE PRECISION TIME(*),SIG(*),TIMIN,TIMAX,TINT,SUM,CHECK
       DOUBLE PRECISION DIVDF2,TSIMP
       EXTERNAL DIVDF2
*** Identify the routine.
       IF(LIDENT)PRINT *,' /// ROUTINE SIGADD (CERNLIB) ///'
*** Don't do anything if there are no points on the signal.
       IF(NSIG.LT.2)THEN
            IFAIL=0
            RETURN
       ENDIF
*** Assume that the routine will fail.
       IFAIL=1
*** Debugging output.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADD DEBUG   : Adding a '',
     -      I4,''-vector to sense wire '',I4,'', terms='',I3,'',''/
     -      26X,''order='',I3,'', charge='',F10.3,'', tmin='',F10.3,
     -      '',''/26X,''shift='',F10.3)')
     -      NSIG,ISW,NISIMP,JIORD,Q,TMIN,TSHIFT
*** Ensure that the sense wire number is in range.
       IF(ISW.LE.0.OR.ISW.GT.NSW)THEN
            PRINT *,' !!!!!! SIGADD WARNING : Sense wire number out'//
     -           ' of range; signals not added.'
            RETURN
       ENDIF
*** Debugging output.
C       IF(LDEBUG)THEN
C            WRITE(LUNOUT,'(''  ++++++ SIGADD DEBUG   : Raw signal''/
C     -           ''   Slot  Time [microsec]  Signal [microA]''/)')
C            DO 40 I=1,NSIG
C            WRITE(LUNOUT,'(2X,I5,2X,E15.8,2X,E15.8)')
C     -           I,TIME(I),SIG(I)
C40          CONTINUE
C       ENDIF
*** Verify that the signal has no 2 equal times in succession.
       DO 100 I=2,NSIG
       IF(TIME(I).LE.TIME(I-1))THEN
            MSIG=I-1
            IF(MSIG.LT.NSIG-1)PRINT *,' !!!!!! SIGADD WARNING :'//
     -           ' Cutting signal at step ',MSIG,' out of ',NSIG,
     -           ' (equal time).'
            GOTO 110
       ENDIF
100    CONTINUE
       MSIG=NSIG
110    CONTINUE
*** Store the interpolation order.
       KIORD=MIN(JIORD,MSIG-1)
*** Debugging header.
C       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADD DEBUG   :'',
C     -      '' Signal added to signal bank:''/
C     -      ''   Slot  Time [microsec]  Signal [microA]''/)')
*** Add the signal to the signal bank.
       CHECK=0
       DO 10 I=1,NTIME
       TINT=TIMSIG(I)-TSHIFT
**  Averageing mode: establish integration time window.
       IF(NISIMP.GT.0)THEN
*   Truncate the time window to overlap with the computed signal.
            TIMIN=MAX(TIME(1),TINT-DBLE(TDEV/2),DBLE(TMIN))
            TIMAX=MIN(TIME(NSIG),TINT+DBLE(TDEV/2))
*   Skip this point if there is no overlap.
            IF(TIMAX.LE.TIMIN)GOTO 10
**  Summing mode
       ELSEIF(NISIMP.EQ.-1)THEN
            TIMIN=TINT-DBLE(TDEV/2)
            TIMAX=TINT+DBLE(TDEV/2)
**  Sampling mode: just check the point is in the computed signal.
       ELSE
            IF(TINT.LT.TIME(1).OR.TINT.GT.TIME(NSIG))GOTO 10
       ENDIF
*   Newton-Raphson integration over this bin.
       IF(NISIMP.EQ.-1)THEN
            SUM=0
            DO 40 J=1,MSIG
            IF(TIME(J).LE.TIMAX.AND.TIME(J+1).GE.TIMIN)SUM=SUM+
     -           SIG(J)*(MIN(TIME(J+1),TIMAX)-MAX(TIME(J),TIMIN))/
     -           TDEV
40          CONTINUE
       ELSEIF(NISIMP.LE.0)THEN
            SUM=DIVDF2(SIG,TIME,MSIG,TINT,JIORD)
       ELSE
            DO 20 J=-NISIMP,NISIMP
            TSIMP=TIMIN+DBLE(J+NISIMP)*(TIMAX-TIMIN)/DBLE(2*NISIMP)
            IF(J.EQ.-NISIMP)THEN
                 SUM=DIVDF2(SIG,TIME,MSIG,TSIMP,KIORD)
            ELSEIF(J.EQ.NISIMP)THEN
                 SUM=SUM+DIVDF2(SIG,TIME,MSIG,TSIMP,KIORD)
            ELSEIF(J+NISIMP.EQ.2*((J+NISIMP)/2))THEN
                 SUM=SUM+2*DIVDF2(SIG,TIME,MSIG,TSIMP,KIORD)
            ELSE
                 SUM=SUM+4*DIVDF2(SIG,TIME,MSIG,TSIMP,KIORD)
            ENDIF
20          CONTINUE
       ENDIF
*   Normalise the integral if Simpson-Raphson was used.
       IF(NISIMP.GT.0)SUM=SUM*(TIMAX-TIMIN)/(6*NISIMP*TDEV)
*   Add the result to the signal.
       IF(CROSS)THEN
            SIGNAL(I,ISW,2)=SIGNAL(I,ISW,2)-ECHARG*1E12*Q*SUM
       ELSE
            SIGNAL(I,ISW,1)=SIGNAL(I,ISW,1)-ECHARG*1E12*Q*SUM
       ENDIF
*   Debugging.
C       IF(LDEBUG)WRITE(LUNOUT,'(2X,I5,2X,E15.8,2X,E15.8)')
C     -      I,TIMSIG(I),ECHARG*1E12*Q*SUM
       CHECK=CHECK+Q*SUM
10     CONTINUE
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADD DEBUG   : Total'',
     -      '' added: '',E15.8)') CHECK
*** Seems to have worked since we got here.
       IFAIL=0
       END
CDECK  ID>, SIGADS.
       SUBROUTINE SIGADS(TSHIFT,CROSS,WEIGHT,IFAIL)
*-----------------------------------------------------------------------
*   SIGADS - Adds the signals induced by the current drift line.
*   (Last changed on 26/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL CROSS
       INTEGER ISW,JSW,IU,ILOC,ILOCRS,IFAIL,IFAIL1
       REAL EX,EY,EZ,DRES,TSHIFT,WEIGHT
       DOUBLE PRECISION VDRIFT(3),TIME(MXLIST),SIG(MXLIST)
*** Identification.
       IF(LIDENT)PRINT *,' /// ROUTINE SIGADS ///'
*** Assume the procedure will fail.
       IFAIL=1
*** Check status and nature of current drift line.
       IF(IPTECH.EQ.4)THEN
            CALL SIGADM(TSHIFT,CROSS,WEIGHT,IFAIL)
            RETURN
       ELSEIF(ISTAT.EQ.0)THEN
            PRINT *,' !!!!!! SIGADS WARNING : The current drift'//
     -           ' line has not yet ended; no signals computed.'
            RETURN
       ELSEIF(IPTYPE.NE.1.AND.IPTYPE.NE.2)THEN
            PRINT *,' !!!!!! SIGADS WARNING : Current drift line is'//
     -           ' neither for an e- nor an ion; no signals computed.'
            RETURN
       ELSEIF(ABS(QPCHAR).LT.0.1)THEN
            PRINT *,' !!!!!! SIGADS WARNING : Current drift line is'//
     -           ' for an uncharged particle; no signals computed.'
            RETURN
       ENDIF
*** Make sure the time resolution has been set.
       IF(.NOT.RESSET)THEN
            PRINT *,' !!!!!! SIGADS WARNING : The time resolution has'//
     -           ' not yet been set; no signals computed.'
            RETURN
       ENDIF
*** Obtain the sense wire number.
       CALL DLCISW(ISTAT,ISW)
*   Cheat in case the point is located inside a wire.
       IF(ISTAT.GT.0)THEN
            ILOCRS=MOD(ISTAT,MXWIRE)
            DRES=D(ILOCRS)
       ELSE
            ILOCRS=0
            DRES=0
       ENDIF
       IF(ILOCRS.GT.0)D(ILOCRS)=DRES/2
**  Cross induction: loop over all sense wires.
       IF(CROSS)THEN
*   Loop over the sense wires.
            DO 10 JSW=1,NSW
*   Compute contribution of the current drift line to the signal
            DO 20 IU=1,NU
            CALL SIGFLS(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           EX,EY,EZ,JSW)
            CALL DLCVEL(XU(IU),YU(IU),ZU(IU),VDRIFT,QPCHAR,IPTYPE,ILOC)
            SIG(IU)=(VDRIFT(1)*EX+VDRIFT(2)*EY+VDRIFT(3)*EZ)
            TIME(IU)=TU(IU)
C      print *,'iu=',iu,
C     -        'v=',sqrt(vdrift(1)**2+vdrift(2)**2+vdrift(3)**2),
C     -        'w=',sqrt(ex**2+ey**2+ez**2),
C     -        'i=',sig(iu)
20          CONTINUE
*   Add this current to the total.
            CALL SIGADD(JSW,ISW.NE.JSW,NU,TIME,SIG,
     -           QPCHAR*WEIGHT,0.0,TSHIFT,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! SIGADS WARNING : Adding'//
     -           ' the computed signal failed; signal incomplete.'
*   Finish loop over the sense wires,
10          CONTINUE
*   Make sure we will know cross induced signals have been computed.
            LCROSS=.TRUE.
**  Otherwise do not do the loop.
       ELSEIF(ISW.NE.0)THEN
*   Compute contribution of the current drift line to the signal
            DO 30 IU=1,NU
            CALL SIGFLS(REAL(XU(IU)),REAL(YU(IU)),REAL(ZU(IU)),
     -           EX,EY,EZ,ISW)
            CALL DLCVEL(XU(IU),YU(IU),ZU(IU),VDRIFT,QPCHAR,IPTYPE,ILOC)
            SIG(IU)=(VDRIFT(1)*EX+VDRIFT(2)*EY+VDRIFT(3)*EZ)
            TIME(IU)=TU(IU)
30          CONTINUE
*   Add this current to the total.
            CALL SIGADD(ISW,.FALSE.,NU,TIME,SIG,
     -           QPCHAR*WEIGHT,0.0,TSHIFT,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! SIGADS WARNING : Adding'//
     -           ' the computed signal failed; signal incomplete.'
*   Make sure we will know cross induced signals have not been computed.
            LCROSS=.FALSE.
       ENDIF
*** Restore the wire diameter.
       IF(ILOCRS.GT.0)D(ILOCRS)=DRES
*** Things seem to have worked.
       IFAIL=0
       END
CDECK  ID>, SIGADM.
       SUBROUTINE SIGADM(TSHIFT,CROSS,WEIGHT,IFAIL)
*-----------------------------------------------------------------------
*   SIGADM - Adds the signals induced by the current microscopic
*            tracking drift line.
*   (Last changed on 29/ 7/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       LOGICAL CROSS
       INTEGER ISW,JSW,IU,ILOCRS,IFAIL,IFAIL1,I,J
       REAL EX,EY,EZ,DRES,TSHIFT,WEIGHT,EXT,EYT,EZT
       DOUBLE PRECISION VDRIFT(3),TIME(MXLIST),SIG(MXLIST),SUM,
     -      WG6(6),TG6(6)
       SAVE TG6,WG6
*** Locations and weights for 6-point Gaussian integration.
       DATA (TG6(I),WG6(I),I=1,6) /
     -      -0.93246 95142 03152 028D0, 0.17132 44923 79170 345D0,
     -      -0.66120 93864 66264 514D0, 0.36076 15730 48138 608D0,
     -      -0.23861 91860 83196 909D0, 0.46791 39345 72691 047D0,
     -       0.23861 91860 83196 909D0, 0.46791 39345 72691 047D0,
     -       0.66120 93864 66264 514D0, 0.36076 15730 48138 608D0,
     -       0.93246 95142 03152 028D0, 0.17132 44923 79170 345D0/
*** Identification.
       IF(LIDENT)PRINT *,' /// ROUTINE SIGADM ///'
*** Assume the procedure will fail.
       IFAIL=1
*** Ensure there is a drift line.
       IF(ISTAT.EQ.0)THEN
            PRINT *,' !!!!!! SIGADM WARNING : The current drift'//
     -           ' line has not yet ended; no signals computed.'
            RETURN
       ELSEIF(IPTYPE.NE.1)THEN
            PRINT *,' !!!!!! SIGADM WARNING : Current drift line is'//
     -           ' not for an e-; no signals computed.'
            RETURN
       ELSEIF(IPTECH.NE.4)THEN
            PRINT *,' !!!!!! SIGADM WARNING : Current drift line is'//
     -           ' not microscopically tracked; no signals computed.'
            RETURN
       ELSEIF(ABS(QPCHAR).LT.0.1)THEN
            PRINT *,' !!!!!! SIGADM WARNING : Current drift line is'//
     -           ' for an uncharged particle; no signals computed.'
            RETURN
       ENDIF
*** Make sure the time resolution has been set.
       IF(.NOT.RESSET)THEN
            PRINT *,' !!!!!! SIGADM WARNING : The time resolution has'//
     -           ' not yet been set; no signals computed.'
            RETURN
       ENDIF
*** Obtain the sense wire number.
       CALL DLCISW(ISTAT,ISW)
*   Cheat in case the point is located inside a wire.
       IF(ISTAT.GT.0)THEN
            ILOCRS=MOD(ISTAT,MXWIRE)
            DRES=D(ILOCRS)
       ELSE
            ILOCRS=0
            DRES=0
       ENDIF
       IF(ILOCRS.GT.0)D(ILOCRS)=DRES/2
**  Cross induction: loop over all sense wires.
       IF(CROSS)THEN
*   Loop over the read-out electrodes.
            DO 10 JSW=1,NSW
*   Compute contribution of the current drift line to the signal.
            SUM=0
            DO 20 IU=1,NU-1
            IF(NMQUAD.EQ.0)THEN
                 CALL SIGFLS(REAL(XU(IU)+XU(IU+1))/2.0,
     -                REAL(YU(IU)+YU(IU+1))/2.0,
     -                REAL(ZU(IU)+ZU(IU+1))/2.0,
     -                EX,EY,EZ,JSW)
            ELSEIF(NMQUAD.EQ.1)THEN
                 EX=0
                 EY=0
                 EZ=0
                 DO 40 J=1,6
                 CALL SIGFLS(
     -                REAL(XU(IU)+(1+TG6(J))/2*(XU(IU+1)-XU(IU))),
     -                REAL(YU(IU)+(1+TG6(J))/2*(YU(IU+1)-YU(IU))),
     -                REAL(ZU(IU)+(1+TG6(J))/2*(ZU(IU+1)-ZU(IU))),
     -                EXT,EYT,EZT,JSW)
                 EX=EX+EXT*WG6(J)/2
                 EY=EY+EYT*WG6(J)/2
                 EZ=EZ+EZT*WG6(J)/2
40               CONTINUE
            ELSE
                 PRINT *,' !!!!!! SIGADM WARNING : Unknown quadrature'//
     -                ' type ',NMQUAD,' requested; Ew set to 0.'
                 EX=0
                 EY=0
                 EZ=0
            ENDIF
            IF(TU(IU+1).GT.TU(IU))THEN
                 VDRIFT(1)=(XU(IU+1)-XU(IU))/(TU(IU+1)-TU(IU))
                 VDRIFT(2)=(YU(IU+1)-YU(IU))/(TU(IU+1)-TU(IU))
                 VDRIFT(3)=(ZU(IU+1)-ZU(IU))/(TU(IU+1)-TU(IU))
                 SIG(IU)=VDRIFT(1)*EX+VDRIFT(2)*EY+VDRIFT(3)*EZ
            ELSE
                 SIG(IU)=0
C                 PRINT *,' !!!!!! SIGADM WARNING : Zero interval'//
C     -                ' at step ',IU,'/',NU,'; skipped.'
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADM WARNING :'',
     -                '' IU/NU = '',I5,''/'',I5,'', dt = '',E12.5,
     -                '', Ew = '',3E12.5)') IU,NU,TU(IU+1)-TU(IU),
     -                EX,EY,EZ
            ENDIF
            TIME(IU)=TU(IU)
            SUM=SUM+SIG(IU)*(TU(IU+1)-TU(IU))
20          CONTINUE
            TIME(NU)=TU(NU)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADM DEBUG   :'',
     -           '' Group '',I5,'' sum = '',E15.8)') JSW,SUM
*   Add this current to the total.
            CALL SIGADD(JSW,ISW.NE.JSW,NU-1,TIME,SIG,
     -           QPCHAR*WEIGHT,0.0,TSHIFT,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! SIGADM WARNING : Adding'//
     -           ' the computed signal failed; signal incomplete.'
*   Finish loop over the sense wires,
10          CONTINUE
*   Make sure we will know cross induced signals have been computed.
            LCROSS=.TRUE.
**  Otherwise do not do the loop.
       ELSEIF(ISW.NE.0)THEN
*   Compute contribution of the current drift line to the signal
            SUM=0
            DO 30 IU=1,NU-1
            IF(NMQUAD.EQ.0)THEN
                 CALL SIGFLS(REAL(XU(IU)+XU(IU+1))/2.0,
     -                REAL(YU(IU)+YU(IU+1))/2.0,
     -                REAL(ZU(IU)+ZU(IU+1))/2.0,
     -                EX,EY,EZ,ISW)
            ELSEIF(NMQUAD.EQ.1)THEN
                 EX=0
                 EY=0
                 EZ=0
                 DO 50 J=1,6
                 CALL SIGFLS(
     -                REAL(XU(IU)+(1+TG6(J))/2*(XU(IU+1)-XU(IU))),
     -                REAL(YU(IU)+(1+TG6(J))/2*(YU(IU+1)-YU(IU))),
     -                REAL(ZU(IU)+(1+TG6(J))/2*(ZU(IU+1)-ZU(IU))),
     -                EXT,EYT,EZT,ISW)
                 EX=EX+EXT*WG6(J)/2
                 EY=EY+EYT*WG6(J)/2
                 EZ=EZ+EZT*WG6(J)/2
50               CONTINUE
            ELSE
                 PRINT *,' !!!!!! SIGADM WARNING : Unknown quadrature'//
     -                ' type ',NMQUAD,' requested; Ew set to 0.'
                 EX=0
                 EY=0
                 EZ=0
            ENDIF
            IF(TU(IU+1).GT.TU(IU))THEN
                 VDRIFT(1)=(XU(IU+1)-XU(IU))/(TU(IU+1)-TU(IU))
                 VDRIFT(2)=(YU(IU+1)-YU(IU))/(TU(IU+1)-TU(IU))
                 VDRIFT(3)=(ZU(IU+1)-ZU(IU))/(TU(IU+1)-TU(IU))
                 SIG(IU)=VDRIFT(1)*EX+VDRIFT(2)*EY+VDRIFT(3)*EZ
            ELSE
                 SIG(IU)=0
C                 PRINT *,' !!!!!! SIGADM WARNING : Zero interval'//
C     -                ' at step ',IU,'/',NU,'; skipped.'
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADM WARNING :'',
     -                '' IU/NU = '',I5,''/'',I5,'', dt = '',E12.5,
     -                '', Ew = '',3E12.5)') IU,NU,TU(IU+1)-TU(IU),
     -                EX,EY,EZ
            ENDIF
            TIME(IU)=TU(IU)
            SUM=SUM+SIG(IU)*(TU(IU+1)-TU(IU))
30          CONTINUE
            TIME(NU)=TU(NU)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGADM DEBUG   '',
     -           '' Group '',I5,'' sum = '',E12.5)') ISW,SUM
*   Add this current to the total.
            CALL SIGADD(ISW,.FALSE.,NU-1,TIME,SIG,
     -           QPCHAR*WEIGHT,0.0,TSHIFT,IFAIL1)
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! SIGADM WARNING : Adding'//
     -           ' the computed signal failed; signal incomplete.'
*   Make sure we will know cross induced signals have not been computed.
            LCROSS=.FALSE.
       ENDIF
*** Restore the wire diameter.
       IF(ILOCRS.GT.0)D(ILOCRS)=DRES
*** Things seem to have worked.
       IFAIL=0
       END
CDECK  ID>, SIGFLS.
       SUBROUTINE SIGFLS(XPOS,YPOS,ZPOS,EXSUM,EYSUM,EZSUM,ISW)
*-----------------------------------------------------------------------
*   SIGFLS - Sums the weighting field components at (XPOS,YPOS,ZPOS).
*   (Last changed on 13/ 1/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       DOUBLE PRECISION CBUF(MXSBUF)
       CHARACTER SOLTYP(MXSOLI)
       INTEGER NSOLID,ISTART(MXSOLI),ISOLTP(MXSOLI),INDSOL(MXSOLI),
     -      ICCURR,IQ(MXPLAN),NQ,ISOLMT(MXSOLI),IWFBEM(MXSW)
       COMMON /SOLIDS/ CBUF,ISTART,INDSOL,IWFBEM,ISOLTP,NSOLID,ICCURR,
     -      IQ,NQ,ISOLMT
       COMMON /SOLCHR/ SOLTYP
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       COMPLEX SIGMAT
       REAL QPLANE,EWXCOR,EWYCOR
       INTEGER IWORK,DUMMY
       COMMON /MATRIX/ SIGMAT(MXWIRE,MXWIRE),QPLANE(5,MXWIRE),
     -      IWORK(MXWIRE),DUMMY(2*MXWIRE+6)
       COMMON /SPLDAT/ EWXCOR(5),EWYCOR(5)
       REAL XPOS,YPOS,ZPOS,EX,EY,EZ,EXSUM,EYSUM,EZSUM
       INTEGER MX,MY,IFAIL,IW,ISW,IPLANE,IWMAP,ISTRIP
*** Preset the sums.
       EXSUM=0
       EYSUM=0
       EZSUM=0
*** Make sure that the signal matrices are present.
       IF(.NOT.SIGSET)THEN
            PRINT *,' !!!!!! SIGFLS WARNING : Initialisation of'//
     -           ' signal calculation not yet done; no field.'
            RETURN
       ENDIF
*** Loop over the signal layers.
       DO 10 MX=MXMIN,MXMAX
       DO 20 MY=MYMIN,MYMAX
*** Load the layers of the wire matrices.
       CALL IONIO(MX,MY,2,0,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! SIGFLS WARNING : Wire matrix'//
     -           ' store error; no weighting field returned.'
            EXSUM=0
            EYSUM=0
            EZSUM=0
            RETURN
       ENDIF
*** Loop over all wires.
       DO 30 IW=1,NWIRE
*   Pick out those wires that are part of this read out group.
       IF(INDSW(IW).EQ.ISW)THEN
            EX=0
            EY=0
            EZ=0
            IF(FCELTP.EQ.'A  ')THEN
                 CALL IONA00(XPOS,YPOS,EX,EY,MX,MY,IW)
            ELSEIF(FCELTP.EQ.'B2X')THEN
                 CALL IONB2X(XPOS,YPOS,EX,EY   ,MY,IW)
            ELSEIF(FCELTP.EQ.'B2Y')THEN
                 CALL IONB2Y(XPOS,YPOS,EX,EY,MX   ,IW)
            ELSEIF(FCELTP.EQ.'C2X')THEN
                 CALL IONC2X(XPOS,YPOS,EX,EY      ,IW)
            ELSEIF(FCELTP.EQ.'C2Y')THEN
                 CALL IONC2Y(XPOS,YPOS,EX,EY      ,IW)
            ELSEIF(FCELTP.EQ.'C3 ')THEN
                 CALL IONC30(XPOS,YPOS,EX,EY      ,IW)
            ELSEIF(FCELTP.EQ.'D1 ')THEN
                 CALL IOND10(XPOS,YPOS,EX,EY      ,IW)
            ELSEIF(FCELTP.EQ.'D3 ')THEN
                 CALL IOND30(XPOS,YPOS,EX,EY      ,IW)
            ELSE
                 PRINT *,' ###### SIGFLS ERROR   : Unknown signal'//
     -                ' field type ',FCELTP,' received; program error.'
                 PRINT *,'                         Encountered for'//
     -                ' Wire ',IW,' indsw=',INDSW(IW)
                 EXSUM=0
                 EYSUM=0
                 EZSUM=0
                 RETURN
            ENDIF
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
30     CONTINUE
*** Load the layers of the plane matrices.
       CALL IPLIO(MX,MY,2,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! SIGFLS WARNING : Plane matrix'//
     -           ' store error; no weighting field returned.'
            EXSUM=0
            EYSUM=0
            EZSUM=0
            RETURN
       ENDIF
*** Loop over all planes.
       DO 40 IPLANE=1,5
*   Pick out those wires that are part of this read out group.
       IF(INDPLA(IPLANE).EQ.ISW)THEN
            EX=0
            EY=0
            EZ=0
            IF(FCELTP.EQ.'A  ')THEN
                 CALL IPLA00(XPOS,YPOS,EX,EY,MX,MY,IPLANE)
            ELSEIF(FCELTP.EQ.'B2X')THEN
                 CALL IPLB2X(XPOS,YPOS,EX,EY   ,MY,IPLANE)
            ELSEIF(FCELTP.EQ.'B2Y')THEN
                 CALL IPLB2Y(XPOS,YPOS,EX,EY,MX   ,IPLANE)
            ELSEIF(FCELTP.EQ.'C2X')THEN
                 CALL IPLC2X(XPOS,YPOS,EX,EY      ,IPLANE)
            ELSEIF(FCELTP.EQ.'C2Y')THEN
                 CALL IPLC2Y(XPOS,YPOS,EX,EY      ,IPLANE)
            ELSEIF(FCELTP.EQ.'C3 ')THEN
                 CALL IPLC30(XPOS,YPOS,EX,EY      ,IPLANE)
            ELSEIF(FCELTP.EQ.'D1 ')THEN
                 CALL IPLD10(XPOS,YPOS,EX,EY      ,IPLANE)
            ELSEIF(FCELTP.EQ.'D3 ')THEN
                 CALL IPLD30(XPOS,YPOS,EX,EY      ,IPLANE)
            ELSE
                 PRINT *,' ###### SIGFLS ERROR   : Unknown signal'//
     -                ' field type ',FCELTP,' received; program error.'
                 PRINT *,'                         Encountered for'//
     -                ' Plane ',IPLANE,' indpla=',INDPLA(IPLANE)
                 EXSUM=0
                 EYSUM=0
                 EZSUM=0
                 RETURN
            ENDIF
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
40     CONTINUE
*** Next signal layer.
20     CONTINUE
10     CONTINUE
*** Add the field due to the planes themselves.
       DO 50 IPLANE=1,5
       IF(INDPLA(IPLANE).EQ.ISW)THEN
            EXSUM=EXSUM+EWXCOR(IPLANE)
            EYSUM=EYSUM+EWYCOR(IPLANE)
       ENDIF
50     CONTINUE
*** Add the field map, if appropriate.
       DO 60 IWMAP=1,NWMAP
       IF(INDEWS(IWMAP).EQ.ISW)THEN
            CALL IONFMP(XPOS,YPOS,ZPOS,EX,EY,EZ,IWMAP)
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
60     CONTINUE
*** Add BEM fields, if appropriate.
       IF(BEMSET)THEN
            CALL IONBEM(XPOS,YPOS,ZPOS,EX,EY,EZ,IWFBEM(ISW))
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
*** Add strips, if there are any.
       DO 70 IPLANE=1,5
       DO 80 ISTRIP=1,NPSTR1(IPLANE)
       IF(INDST1(IPLANE,ISTRIP).EQ.ISW)THEN
            CALL IONEST(XPOS,YPOS,ZPOS,EX,EY,EZ,IPLANE,ISTRIP,1)
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
80     CONTINUE
       DO 90 ISTRIP=1,NPSTR2(IPLANE)
       IF(INDST2(IPLANE,ISTRIP).EQ.ISW)THEN
            CALL IONEST(XPOS,YPOS,ZPOS,EX,EY,EZ,IPLANE,ISTRIP,2)
            EXSUM=EXSUM+EX
            EYSUM=EYSUM+EY
            EZSUM=EZSUM+EZ
       ENDIF
90     CONTINUE
70     CONTINUE
       END
CDECK  ID>, IONFMP.
       SUBROUTINE IONFMP(XIN,YIN,ZIN,EX,EY,EZ,ISW)
*-----------------------------------------------------------------------
*   IONFMP - Interpolates the weighting field map at (XPOS,YPOS,ZPOS).
*   (Last changed on  9/ 1/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL EXMAP,EYMAP,EZMAP,VMAP,EWXMAP,EWYMAP,EWZMAP,VWMAP,
     -      BXMAP,BYMAP,BZMAP,
     -      XMAP,YMAP,ZMAP,XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,
     -      VMMIN,VMMAX,EPSMAT,EPSSUR,XFMOFF,YFMOFF,ZFMOFF
       INTEGER MATMAP,NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS,
     -      NWMAP
       LOGICAL MAPFLG,LMAPPL,SETAX,SETAY,SETAZ,ELMDGN,LSFDER
       CHARACTER EWSTYP
       CHARACTER*10 MATSRC
       COMMON /FLDMAP/ VMAP(MXMAP,10),VWMAP(MXMAP,10,MXWMAP),
     -      EXMAP(MXMAP,10),EYMAP(MXMAP,10),EZMAP(MXMAP,10),
     -      EWXMAP(MXMAP,10,MXWMAP),EWYMAP(MXMAP,10,MXWMAP),
     -      EWZMAP(MXMAP,10,MXWMAP),
     -      BXMAP(MXMAP,10),BYMAP(MXMAP,10),BZMAP(MXMAP,10),
     -      XMAP(MXMAP,10),YMAP(MXMAP,10),ZMAP(MXMAP,10),
     -      XMMIN,XMMAX,YMMIN,YMMAX,ZMMIN,ZMMAX,
     -      XAMIN,XAMAX,YAMIN,YAMAX,ZAMIN,ZAMAX,VMMIN,VMMAX,
     -      XFMOFF,YFMOFF,ZFMOFF,
     -      EPSMAT(MXEPS),EPSSUR(MXEPS),MATMAP(MXMAP),
     -      NMAP,NEPS,MAPORD,MAPTYP,IDRMAT,INDEWS(MXWMAP),NWMAP,
     -      MAPFLG(10+4*MXWMAP),ELMDGN(MXMAP),
     -      LMAPPL,SETAX,SETAY,SETAZ,LSFDER
       COMMON /FLDCHR/ EWSTYP(MXWMAP),MATSRC
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       REAL XIN,YIN,ZIN,XPOS,YPOS,ZPOS,EX,EY,EZ,XNEW,YNEW,ZNEW,
     -      T1,T2,T3,T4,AUXR,AUXPHI,AROT,XAUX,YAUX,ER,EAXIS,RCOOR,ZCOOR,
     -      DN1DUH,DN2DUH,DN3DUH,DN4DUH,DN5DUH,DN6DUH,DN7DUH,DN8DUH,
     -      DN1DVH,DN2DVH,DN3DVH,DN4DVH,DN5DVH,DN6DVH,DN7DVH,DN8DVH,
     -      DN1DWH,DN2DWH,DN3DWH,DN4DWH,DN5DWH,DN6DWH,DN7DWH,DN8DWH,
     -      DN1DUP,DN2DUP,DN3DUP,DN4DUP,DN5DUP,DN6DUP,
     -      DN1DVP,DN2DVP,DN3DVP,DN4DVP,DN5DVP,DN6DVP,
     -      DN1DWP,DN2DWP,DN3DWP,DN4DWP,DN5DWP,DN6DWP,
     -      DT1DX,DT2DX,DT3DX,DT4DX,
     -      DT1DY,DT2DY,DT3DY,DT4DY,
     -      DT1DZ,DT2DZ,DT3DZ,DT4DZ
       DOUBLE PRECISION JAC(4,4),DET
       INTEGER IMAP,NX,NY,NZ,ISW
       LOGICAL MIRRX,MIRRY,MIRRZ
*** Derivatives of the shape functions for hexahedrals.
       DN1DUH(T1,T2,T3)=-(1 - T2)*(1 - T3)/8
       DN2DUH(T1,T2,T3)= (1 - T2)*(1 - T3)/8
       DN3DUH(T1,T2,T3)= (1 + T2)*(1 - T3)/8
       DN4DUH(T1,T2,T3)=-(1 + T2)*(1 - T3)/8
       DN5DUH(T1,T2,T3)=-(1 - T2)*(1 + T3)/8
       DN6DUH(T1,T2,T3)= (1 - T2)*(1 + T3)/8
       DN7DUH(T1,T2,T3)= (1 + T2)*(1 + T3)/8
       DN8DUH(T1,T2,T3)=-(1 + T2)*(1 + T3)/8
       DN1DVH(T1,T2,T3)=-(1 - T1)*(1 - T3)/8
       DN2DVH(T1,T2,T3)=-(1 + T1)*(1 - T3)/8
       DN3DVH(T1,T2,T3)= (1 + T1)*(1 - T3)/8
       DN4DVH(T1,T2,T3)= (1 - T1)*(1 - T3)/8
       DN5DVH(T1,T2,T3)=-(1 - T1)*(1 + T3)/8
       DN6DVH(T1,T2,T3)=-(1 + T1)*(1 + T3)/8
       DN7DVH(T1,T2,T3)= (1 + T1)*(1 + T3)/8
       DN8DVH(T1,T2,T3)= (1 - T1)*(1 + T3)/8
       DN1DWH(T1,T2,T3)=-(1 - T1)*(1 - T2)/8
       DN2DWH(T1,T2,T3)=-(1 + T1)*(1 - T2)/8
       DN3DWH(T1,T2,T3)=-(1 + T1)*(1 + T2)/8
       DN4DWH(T1,T2,T3)=-(1 - T1)*(1 + T2)/8
       DN5DWH(T1,T2,T3)= (1 - T1)*(1 - T2)/8
       DN6DWH(T1,T2,T3)= (1 + T1)*(1 - T2)/8
       DN7DWH(T1,T2,T3)= (1 + T1)*(1 + T2)/8
       DN8DWH(T1,T2,T3)= (1 - T1)*(1 + T2)/8
*** Derivatives of the shape functions for pentahedrals.
       DN1DUP(T1,T2,T3)=(-1+T3)/2
       DN2DUP(T1,T2,T3)=( 1-T3)/2
       DN3DUP(T1,T2,T3)=0
       DN4DUP(T1,T2,T3)=(-1-T3)/2
       DN5DUP(T1,T2,T3)=( 1+T3)/2
       DN6DUP(T1,T2,T3)=0
       DN1DVP(T1,T2,T3)=(-1+T3)/2
       DN2DVP(T1,T2,T3)=0
       DN3DVP(T1,T2,T3)=( 1-T3)/2
       DN4DVP(T1,T2,T3)=(-1-T3)/2
       DN5DVP(T1,T2,T3)=0
       DN6DVP(T1,T2,T3)=( 1+T3)/2
       DN1DWP(T1,T2,T3)=(-1+T1+T2)/2
       DN2DWP(T1,T2,T3)=-T1/2
       DN3DWP(T1,T2,T3)=-T2/2
       DN4DWP(T1,T2,T3)=( 1-T1-T2)/2
       DN5DWP(T1,T2,T3)= T1/2
       DN6DWP(T1,T2,T3)= T2/2
*** Initial values.
       EX=0
       EY=0
       EZ=0
       XPOS=XIN-XFMOFF
       YPOS=YIN-YFMOFF
       ZPOS=ZIN-ZFMOFF
*** First see whether we at all have a grid.
       IF(.NOT.MAPFLG(1))RETURN
*** If chamber is periodic, reduce to the cell volume.
       MIRRX=.FALSE.
       IF(PERX)THEN
            XPOS=XMMIN+MOD(XPOS-XMMIN,XMMAX-XMMIN)
            IF(XPOS.LT.XMMIN)XPOS=XPOS+(XMMAX-XMMIN)
       ELSEIF(PERMX)THEN
            XNEW=XMMIN+MOD(XPOS-XMMIN,XMMAX-XMMIN)
            IF(XNEW.LT.XMMIN)XNEW=XNEW+(XMMAX-XMMIN)
            NX=NINT((XNEW-XPOS)/(XMMAX-XMMIN))
            IF(NX.NE.2*(NX/2))THEN
                 XNEW=XMMIN+XMMAX-XNEW
                 MIRRX=.TRUE.
            ENDIF
            XPOS=XNEW
       ENDIF
       IF(PERAX.AND.(ZPOS.NE.0.OR.YPOS.NE.0))THEN
            AUXR=SQRT(ZPOS**2+YPOS**2)
            AUXPHI=ATAN2(ZPOS,YPOS)
            AROT=(XAMAX-XAMIN)*ANINT((AUXPHI-0.5*(XAMIN+XAMAX))/
     -           (XAMAX-XAMIN))
            IF(AUXPHI-AROT.LT.XAMIN)AROT=AROT-(XAMAX-XAMIN)
            IF(AUXPHI-AROT.GT.XAMAX)AROT=AROT+(XAMAX-XAMIN)
            AUXPHI=AUXPHI-AROT
            YPOS=AUXR*COS(AUXPHI)
            ZPOS=AUXR*SIN(AUXPHI)
       ENDIF
       MIRRY=.FALSE.
       IF(PERY)THEN
            YPOS=YMMIN+MOD(YPOS-YMMIN,YMMAX-YMMIN)
            IF(YPOS.LT.YMMIN)YPOS=YPOS+(YMMAX-YMMIN)
       ELSEIF(PERMY)THEN
            YNEW=YMMIN+MOD(YPOS-YMMIN,YMMAX-YMMIN)
            IF(YNEW.LT.YMMIN)YNEW=YNEW+(YMMAX-YMMIN)
            NY=NINT((YNEW-YPOS)/(YMMAX-YMMIN))
            IF(NY.NE.2*(NY/2))THEN
                 YNEW=YMMIN+YMMAX-YNEW
                 MIRRY=.TRUE.
            ENDIF
            YPOS=YNEW
       ENDIF
       IF(PERAY.AND.(XPOS.NE.0.OR.ZPOS.NE.0))THEN
            AUXR=SQRT(XPOS**2+ZPOS**2)
            AUXPHI=ATAN2(XPOS,ZPOS)
            AROT=(YAMAX-YAMIN)*ANINT((AUXPHI-0.5*(YAMIN+YAMAX))/
     -           (YAMAX-YAMIN))
            IF(AUXPHI-AROT.LT.YAMIN)AROT=AROT-(YAMAX-YAMIN)
            IF(AUXPHI-AROT.GT.YAMAX)AROT=AROT+(YAMAX-YAMIN)
            AUXPHI=AUXPHI-AROT
            ZPOS=AUXR*COS(AUXPHI)
            XPOS=AUXR*SIN(AUXPHI)
       ENDIF
       MIRRZ=.FALSE.
       IF(PERZ)THEN
            ZPOS=ZMMIN+MOD(ZPOS-ZMMIN,ZMMAX-ZMMIN)
            IF(ZPOS.LT.ZMMIN)ZPOS=ZPOS+(ZMMAX-ZMMIN)
       ELSEIF(PERMZ)THEN
            ZNEW=ZMMIN+MOD(ZPOS-ZMMIN,ZMMAX-ZMMIN)
            IF(ZNEW.LT.ZMMIN)ZNEW=ZNEW+(ZMMAX-ZMMIN)
            NZ=NINT((ZNEW-ZPOS)/(ZMMAX-ZMMIN))
            IF(NZ.NE.2*(NZ/2))THEN
                 ZNEW=ZMMIN+ZMMAX-ZNEW
                 MIRRZ=.TRUE.
            ENDIF
            ZPOS=ZNEW
       ENDIF
       IF(PERAZ.AND.(YPOS.NE.0.OR.XPOS.NE.0))THEN
            AUXR=SQRT(YPOS**2+XPOS**2)
            AUXPHI=ATAN2(YPOS,XPOS)
            AROT=(ZAMAX-ZAMIN)*ANINT((AUXPHI-0.5*(ZAMIN+ZAMAX))/
     -           (ZAMAX-ZAMIN))
            IF(AUXPHI-AROT.LT.ZAMIN)AROT=AROT-(ZAMAX-ZAMIN)
            IF(AUXPHI-AROT.GT.ZAMAX)AROT=AROT+(ZAMAX-ZAMIN)
            AUXPHI=AUXPHI-AROT
            XPOS=AUXR*COS(AUXPHI)
            YPOS=AUXR*SIN(AUXPHI)
       ENDIF
*** If we have a rotationally symmetric field map, store coordinates.
       IF(PERRX)THEN
            RCOOR=SQRT(YPOS**2+ZPOS**2)
            ZCOOR=XPOS
       ELSEIF(PERRY)THEN
            RCOOR=SQRT(XPOS**2+ZPOS**2)
            ZCOOR=YPOS
       ELSEIF(PERRZ)THEN
            RCOOR=SQRT(XPOS**2+YPOS**2)
            ZCOOR=ZPOS
       ENDIF
       IF(PERRX.OR.PERRY.OR.PERRZ)THEN
            XPOS=RCOOR
            YPOS=ZCOOR
            ZPOS=0
       ENDIF
*** Locate the point.
       CALL MAPIND(XPOS,YPOS,ZPOS,T1,T2,T3,T4,JAC,DET,IMAP)
       IF(IMAP.LE.0.OR.IMAP.GT.NMAP)RETURN
*** A 2-dimensional interpolation (triangles), linear ...
       IF((MAPTYP.EQ.1.OR.MAPTYP.EQ.2.OR.MAPTYP.EQ.3).AND.
     -      MAPORD.EQ.1)THEN
            IF(LSFDER)THEN
                 DET=-(XMAP(IMAP,2)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,3)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,3)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3))
                 DT1DX=(YMAP(IMAP,3) - YMAP(IMAP,2))/DET
                 DT1DY=(XMAP(IMAP,2) - XMAP(IMAP,3))/DET
                 DT2DX=(YMAP(IMAP,1) - YMAP(IMAP,3))/DET
                 DT2DY=(XMAP(IMAP,3) - XMAP(IMAP,1))/DET
                 DT3DX=(YMAP(IMAP,2) - YMAP(IMAP,1))/DET
                 DT3DY=(XMAP(IMAP,1) - XMAP(IMAP,2))/DET
                 EX=VWMAP(IMAP, 1,ISW)*DT1DX+
     -              VWMAP(IMAP, 2,ISW)*DT2DX+
     -              VWMAP(IMAP, 3,ISW)*DT3DX
                 EY=VWMAP(IMAP, 1,ISW)*DT1DY+
     -              VWMAP(IMAP, 2,ISW)*DT2DY+
     -              VWMAP(IMAP, 3,ISW)*DT3DY
                 EZ=0
            ELSE
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                EWXMAP(IMAP,1,ISW)*T1+
     -                EWXMAP(IMAP,2,ISW)*T2+
     -                EWXMAP(IMAP,3,ISW)*T3
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1+
     -                EWYMAP(IMAP,2,ISW)*T2+
     -                EWYMAP(IMAP,3,ISW)*T3
                 IF(MAPFLG(12+4*ISW-3))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1+
     -                EWZMAP(IMAP,2,ISW)*T2+
     -                EWZMAP(IMAP,3,ISW)*T3
            ENDIF
**  or quadratic.
       ELSEIF(MAPTYP.EQ.2.AND.MAPORD.EQ.2)THEN
*   By gradient of the potential
            IF(LSFDER)THEN
                 DET=-(XMAP(IMAP,2)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,3)*YMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,3)*YMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3))
                 DT1DX=(YMAP(IMAP,3) - YMAP(IMAP,2))/DET
                 DT1DY=(XMAP(IMAP,2) - XMAP(IMAP,3))/DET
                 DT2DX=(YMAP(IMAP,1) - YMAP(IMAP,3))/DET
                 DT2DY=(XMAP(IMAP,3) - XMAP(IMAP,1))/DET
                 DT3DX=(YMAP(IMAP,2) - YMAP(IMAP,1))/DET
                 DT3DY=(XMAP(IMAP,1) - XMAP(IMAP,2))/DET
                 EX=VWMAP(IMAP, 1,ISW)*(4*T1-1)*DT1DX+
     -              VWMAP(IMAP, 2,ISW)*(4*T2-1)*DT2DX+
     -              VWMAP(IMAP, 3,ISW)*(4*T3-1)*DT3DX+
     -              VWMAP(IMAP, 4,ISW)*(4*T2*DT1DX+4*T1*DT2DX)+
     -              VWMAP(IMAP, 5,ISW)*(4*T3*DT1DX+4*T1*DT3DX)+
     -              VWMAP(IMAP, 6,ISW)*(4*T3*DT2DX+4*T2*DT3DX)
                 EY=VWMAP(IMAP, 1,ISW)*(4*T1-1)*DT1DY+
     -              VWMAP(IMAP, 2,ISW)*(4*T2-1)*DT2DY+
     -              VWMAP(IMAP, 3,ISW)*(4*T3-1)*DT3DY+
     -              VWMAP(IMAP, 4,ISW)*(4*T2*DT1DY+4*T1*DT2DY)+
     -              VWMAP(IMAP, 5,ISW)*(4*T3*DT1DY+4*T1*DT3DY)+
     -              VWMAP(IMAP, 6,ISW)*(4*T3*DT2DY+4*T2*DT3DY)
                 EZ=0
*   By interpolation of field maps.
            ELSE
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                EWXMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWXMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWXMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWXMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWXMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWXMAP(IMAP,6,ISW)*T2*T3
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWYMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWYMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWYMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWYMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWYMAP(IMAP,6,ISW)*T2*T3
                 IF(MAPFLG(12+4*ISW-3))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWZMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWZMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWZMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWZMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWZMAP(IMAP,6,ISW)*T2*T3
            ENDIF
**  or quadratic interpolation in curved triangles ...
       ELSEIF((MAPTYP.EQ.3.AND.MAPORD.EQ.2).OR.
     -      (MAPTYP.EQ.5.AND.MAPORD.EQ.2.AND.ELMDGN(IMAP)))THEN
*   By gradient of the potential
            IF(LSFDER)THEN
                 EX=-(VWMAP(IMAP, 1,ISW)*(4*T1-1)*JAC(1,2)+
     -                VWMAP(IMAP, 2,ISW)*(4*T2-1)*JAC(2,2)+
     -                VWMAP(IMAP, 3,ISW)*(4*T3-1)*JAC(3,2)+
     -                VWMAP(IMAP, 4,ISW)*(4*T2*JAC(1,2)+4*T1*JAC(2,2))+
     -                VWMAP(IMAP, 5,ISW)*(4*T3*JAC(1,2)+4*T1*JAC(3,2))+
     -                VWMAP(IMAP, 6,ISW)*(4*T3*JAC(2,2)+4*T2*JAC(3,2)))/
     -                DET
                 EY=-(VWMAP(IMAP, 1,ISW)*(4*T1-1)*JAC(1,3)+
     -                VWMAP(IMAP, 2,ISW)*(4*T2-1)*JAC(2,3)+
     -                VWMAP(IMAP, 3,ISW)*(4*T3-1)*JAC(3,3)+
     -                VWMAP(IMAP, 4,ISW)*(4*T2*JAC(1,3)+4*T1*JAC(2,3))+
     -                VWMAP(IMAP, 5,ISW)*(4*T3*JAC(1,3)+4*T1*JAC(3,3))+
     -                VWMAP(IMAP, 6,ISW)*(4*T3*JAC(2,3)+4*T2*JAC(3,3)))/
     -                DET
                 EZ=0
*   By interpolation of field maps.
            ELSE
                 IF(MAPFLG(2))EX=
     -                EWXMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWXMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWXMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWXMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWXMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWXMAP(IMAP,6,ISW)*T2*T3
                 IF(MAPFLG(3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWYMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWYMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWYMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWYMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWYMAP(IMAP,6,ISW)*T2*T3
                 IF(MAPFLG(4))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWZMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWZMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                4*EWZMAP(IMAP,4,ISW)*T1*T2+
     -                4*EWZMAP(IMAP,5,ISW)*T1*T3+
     -                4*EWZMAP(IMAP,6,ISW)*T2*T3
            ENDIF
**  or quadratic in 8-node "serendipity" quadrilaterals.
       ELSEIF(MAPTYP.EQ.5.AND.MAPORD.EQ.2)THEN
            IF(LSFDER.AND.MAPFLG(13+4*ISW-3))THEN
                 EX=-(VWMAP(IMAP, 1,ISW)*((1-T2)*(2*T1+T2)*JAC(1,1)+
     -                                    (1-T1)*(T1+2*T2)*JAC(2,1))/4+
     -                VWMAP(IMAP, 2,ISW)*((1-T2)*(2*T1-T2)*JAC(1,1)-
     -                                    (1+T1)*(T1-2*T2)*JAC(2,1))/4+
     -                VWMAP(IMAP, 3,ISW)*((1+T2)*(2*T1+T2)*JAC(1,1)+
     -                                    (1+T1)*(T1+2*T2)*JAC(2,1))/4+
     -                VWMAP(IMAP, 4,ISW)*((1+T2)*(2*T1-T2)*JAC(1,1)-
     -                                    (1-T1)*(T1-2*T2)*JAC(2,1))/4+
     -                VWMAP(IMAP, 5,ISW)*(T1*(T2-1)       *JAC(1,1)+
     -                                    (T1-1)*(T1+1)   *JAC(2,1)/2)+
     -                VWMAP(IMAP, 6,ISW)*((1-T2)*(1+T2)   *JAC(1,1)/2-
     -                                    (1+T1)*T2       *JAC(2,1))+
     -                VWMAP(IMAP, 7,ISW)*(-T1*(1+T2)      *JAC(1,1)+
     -                                    (1-T1)*(1+T1)   *JAC(2,1)/2)+
     -                VWMAP(IMAP, 8,ISW)*((T2-1)*(T2+1)   *JAC(1,1)/2+
     -                                    (T1-1)*T2       *JAC(2,1)))/
     -                DET
                 EY=-(VWMAP(IMAP, 1,ISW)*((1-T2)*(2*T1+T2)*JAC(1,2)+
     -                                    (1-T1)*(T1+2*T2)*JAC(2,2))/4+
     -                VWMAP(IMAP, 2,ISW)*((1-T2)*(2*T1-T2)*JAC(1,2)-
     -                                    (1+T1)*(T1-2*T2)*JAC(2,2))/4+
     -                VWMAP(IMAP, 3,ISW)*((1+T2)*(2*T1+T2)*JAC(1,2)+
     -                                    (1+T1)*(T1+2*T2)*JAC(2,2))/4+
     -                VWMAP(IMAP, 4,ISW)*((1+T2)*(2*T1-T2)*JAC(1,2)-
     -                                    (1-T1)*(T1-2*T2)*JAC(2,2))/4+
     -                VWMAP(IMAP, 5,ISW)*(T1*(T2-1)       *JAC(1,2)+
     -                                    (T1-1)*(T1+1)   *JAC(2,2)/2)+
     -                VWMAP(IMAP, 6,ISW)*((1-T2)*(1+T2)   *JAC(1,2)/2-
     -                                    (1+T1)*T2       *JAC(2,2))+
     -                VWMAP(IMAP, 7,ISW)*(-T1*(1+T2)      *JAC(1,2)+
     -                                    (1-T1)*(1+T1)   *JAC(2,2)/2)+
     -                VWMAP(IMAP, 8,ISW)*((T2-1)*(T2+1)   *JAC(1,2)/2+
     -                                    (T1-1)*T2       *JAC(2,2)))/
     -                DET
            ELSEIF(.NOT.LSFDER)THEN
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                -EWXMAP(IMAP,1,ISW)*(1-T1)*(1-T2)*(1+T1+T2)/4-
     -                 EWXMAP(IMAP,2,ISW)*(1+T1)*(1-T2)*(1-T1+T2)/4-
     -                 EWXMAP(IMAP,3,ISW)*(1+T1)*(1+T2)*(1-T1-T2)/4-
     -                 EWXMAP(IMAP,4,ISW)*(1-T1)*(1+T2)*(1+T1-T2)/4+
     -                 EWXMAP(IMAP,5,ISW)*(1-T1)*(1+T1)*(1-T2)/2+
     -                 EWXMAP(IMAP,6,ISW)*(1+T1)*(1+T2)*(1-T2)/2+
     -                 EWXMAP(IMAP,7,ISW)*(1-T1)*(1+T1)*(1+T2)/2+
     -                 EWXMAP(IMAP,8,ISW)*(1-T1)*(1+T2)*(1-T2)/2
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                -EWYMAP(IMAP,1,ISW)*(1-T1)*(1-T2)*(1+T1+T2)/4-
     -                 EWYMAP(IMAP,2,ISW)*(1+T1)*(1-T2)*(1-T1+T2)/4-
     -                 EWYMAP(IMAP,3,ISW)*(1+T1)*(1+T2)*(1-T1-T2)/4-
     -                 EWYMAP(IMAP,4,ISW)*(1-T1)*(1+T2)*(1+T1-T2)/4+
     -                 EWYMAP(IMAP,5,ISW)*(1-T1)*(1+T1)*(1-T2)/2+
     -                 EWYMAP(IMAP,6,ISW)*(1+T1)*(1+T2)*(1-T2)/2+
     -                 EWYMAP(IMAP,7,ISW)*(1-T1)*(1+T1)*(1+T2)/2+
     -                 EWYMAP(IMAP,8,ISW)*(1-T1)*(1+T2)*(1-T2)/2
            ENDIF
*** A 3-dimensional interpolation (tetrahedra), linear ...
       ELSEIF((MAPTYP.EQ.11.OR.MAPTYP.EQ.12.OR.MAPTYP.EQ.13).AND.
     -      MAPORD.EQ.1)THEN
            IF(LSFDER)THEN
                 DET = XMAP(IMAP,2)*YMAP(IMAP,3)*ZMAP(IMAP,1)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,4)*ZMAP(IMAP,1)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)*ZMAP(IMAP,2)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,4)*ZMAP(IMAP,2)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,1)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)*ZMAP(IMAP,3)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,4)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,2)*YMAP(IMAP,4)*ZMAP(IMAP,3)+
     -                 XMAP(IMAP,4)*(YMAP(IMAP,2)*ZMAP(IMAP,1)-
     -                               YMAP(IMAP,3)*ZMAP(IMAP,1)-
     -                               YMAP(IMAP,1)*ZMAP(IMAP,2)+
     -                               YMAP(IMAP,3)*ZMAP(IMAP,2)+
     -                               YMAP(IMAP,1)*ZMAP(IMAP,3)-
     -                               YMAP(IMAP,2)*ZMAP(IMAP,3))+
     -                 XMAP(IMAP,2)*YMAP(IMAP,1)*ZMAP(IMAP,4)-
     -                 XMAP(IMAP,1)*YMAP(IMAP,2)*ZMAP(IMAP,4)+
     -                 XMAP(IMAP,1)*YMAP(IMAP,3)*ZMAP(IMAP,4)-
     -                 XMAP(IMAP,2)*YMAP(IMAP,3)*ZMAP(IMAP,4)+
     -                 XMAP(IMAP,3)*(YMAP(IMAP,4)*ZMAP(IMAP,1)+
     -                               YMAP(IMAP,1)*ZMAP(IMAP,2)-
     -                               YMAP(IMAP,4)*ZMAP(IMAP,2)-
     -                               YMAP(IMAP,1)*ZMAP(IMAP,4)-
     -                               YMAP(IMAP,2)*ZMAP(IMAP,1)+
     -                               YMAP(IMAP,2)*ZMAP(IMAP,4))
                 EX=-(VWMAP(IMAP,1,ISW)*(
     -                     YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                     YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,2,ISW)*(
     -                     YMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))+
     -                     YMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,1)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,3,ISW)*(
     -                     YMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                     YMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                     YMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,4,ISW)*(
     -                     YMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                     YMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                     YMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))))/
     -                DET
                 EY=-(VWMAP(IMAP,1,ISW)*(
     -                     XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                     XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,2,ISW)*(
     -                     XMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                     XMAP(IMAP,1)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,3,ISW)*(
     -                     XMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                     XMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                     XMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                VWMAP(IMAP,4,ISW)*(
     -                     XMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                     XMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                     XMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))))/
     -                DET
                 EZ=-(VWMAP(IMAP,1,ISW)*(
     -                     XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                     XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))+
     -                VWMAP(IMAP,2,ISW)*(
     -                     XMAP(IMAP,4)*(-YMAP(IMAP,1)+YMAP(IMAP,3))+
     -                     XMAP(IMAP,3)*( YMAP(IMAP,1)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,1)*(-YMAP(IMAP,3)+YMAP(IMAP,4)))+
     -                VWMAP(IMAP,3,ISW)*(
     -                     XMAP(IMAP,4)*( YMAP(IMAP,1)-YMAP(IMAP,2))+
     -                     XMAP(IMAP,1)*( YMAP(IMAP,2)-YMAP(IMAP,4))+
     -                     XMAP(IMAP,2)*(-YMAP(IMAP,1)+YMAP(IMAP,4)))+
     -                VWMAP(IMAP,4,ISW)*(
     -                     XMAP(IMAP,3)*(-YMAP(IMAP,1)+YMAP(IMAP,2))+
     -                     XMAP(IMAP,2)*( YMAP(IMAP,1)-YMAP(IMAP,3))+
     -                     XMAP(IMAP,1)*(-YMAP(IMAP,2)+YMAP(IMAP,3))))/
     -                DET
            ELSE
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                EWXMAP(IMAP,1,ISW)*T1+
     -                EWXMAP(IMAP,2,ISW)*T2+
     -                EWXMAP(IMAP,3,ISW)*T3+
     -                EWXMAP(IMAP,4,ISW)*T4
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1+
     -                EWYMAP(IMAP,2,ISW)*T2+
     -                EWYMAP(IMAP,3,ISW)*T3+
     -                EWYMAP(IMAP,4,ISW)*T4
                 IF(MAPFLG(12+4*ISW-3))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1+
     -                EWZMAP(IMAP,2,ISW)*T2+
     -                EWZMAP(IMAP,3,ISW)*T3+
     -                EWZMAP(IMAP,4,ISW)*T4
            ENDIF
**  or quadratic in linear tetrahedra ....
       ELSEIF(MAPTYP.EQ.12.AND.MAPORD.EQ.2)THEN
            IF(LSFDER)THEN
*   Determinant of the Jacobian.
                 DET=-((ZMAP(IMAP,1)-ZMAP(IMAP,2))*
     -                 (XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))+
     -                 (XMAP(IMAP,1)-XMAP(IMAP,2))*
     -                 (YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))+
     -                 (YMAP(IMAP,1)-YMAP(IMAP,2))*
     -                 (XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4))))
*   Elements of the Jacobian
                 DT1DX=(YMAP(IMAP,4)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,3)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))/DET
                 DT1DY=(XMAP(IMAP,4)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))/DET
                 DT1DZ=(XMAP(IMAP,4)*( YMAP(IMAP,2)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,3)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-YMAP(IMAP,2)+YMAP(IMAP,4)))/DET
                 DT2DX=(YMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3))+
     -                  YMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,1)*(-ZMAP(IMAP,3)+ZMAP(IMAP,4)))/DET
                 DT2DY=(XMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                  XMAP(IMAP,1)*( ZMAP(IMAP,3)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))/DET
                 DT2DZ=(XMAP(IMAP,4)*(-YMAP(IMAP,1)+YMAP(IMAP,3))+
     -                  XMAP(IMAP,3)*( YMAP(IMAP,1)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,1)*(-YMAP(IMAP,3)+YMAP(IMAP,4)))/DET
                 DT3DX=(YMAP(IMAP,4)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                  YMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,4))+
     -                  YMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,4)))/DET
                 DT3DY=(XMAP(IMAP,4)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                  XMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,4))+
     -                  XMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,4)))/DET
                 DT3DZ=(XMAP(IMAP,4)*( YMAP(IMAP,1)-YMAP(IMAP,2))+
     -                  XMAP(IMAP,1)*( YMAP(IMAP,2)-YMAP(IMAP,4))+
     -                  XMAP(IMAP,2)*(-YMAP(IMAP,1)+YMAP(IMAP,4)))/DET
                 DT4DX=(YMAP(IMAP,3)*(-ZMAP(IMAP,1)+ZMAP(IMAP,2))+
     -                  YMAP(IMAP,2)*( ZMAP(IMAP,1)-ZMAP(IMAP,3))+
     -                  YMAP(IMAP,1)*(-ZMAP(IMAP,2)+ZMAP(IMAP,3)))/DET
                 DT4DY=(XMAP(IMAP,3)*( ZMAP(IMAP,1)-ZMAP(IMAP,2))+
     -                  XMAP(IMAP,1)*( ZMAP(IMAP,2)-ZMAP(IMAP,3))+
     -                  XMAP(IMAP,2)*(-ZMAP(IMAP,1)+ZMAP(IMAP,3)))/DET
                 DT4DZ=(XMAP(IMAP,3)*(-YMAP(IMAP,1)+YMAP(IMAP,2))+
     -                  XMAP(IMAP,2)*( YMAP(IMAP,1)-YMAP(IMAP,3))+
     -                  XMAP(IMAP,1)*(-YMAP(IMAP,2)+YMAP(IMAP,3)))/DET
*   Electric field
                 EX=VWMAP(IMAP, 1,ISW)*(4*T1-1)*DT1DX+
     -              VWMAP(IMAP, 2,ISW)*(4*T2-1)*DT2DX+
     -              VWMAP(IMAP, 3,ISW)*(4*T3-1)*DT3DX+
     -              VWMAP(IMAP, 4,ISW)*(4*T4-1)*DT4DX+
     -              VWMAP(IMAP, 5,ISW)*(4*T2*DT1DX+4*T1*DT2DX)+
     -              VWMAP(IMAP, 6,ISW)*(4*T3*DT1DX+4*T1*DT3DX)+
     -              VWMAP(IMAP, 7,ISW)*(4*T4*DT1DX+4*T1*DT4DX)+
     -              VWMAP(IMAP, 8,ISW)*(4*T3*DT2DX+4*T2*DT3DX)+
     -              VWMAP(IMAP, 9,ISW)*(4*T4*DT2DX+4*T2*DT4DX)+
     -              VWMAP(IMAP,10,ISW)*(4*T4*DT3DX+4*T3*DT4DX)
                 EY=VWMAP(IMAP, 1,ISW)*(4*T1-1)*DT1DY+
     -              VWMAP(IMAP, 2,ISW)*(4*T2-1)*DT2DY+
     -              VWMAP(IMAP, 3,ISW)*(4*T3-1)*DT3DY+
     -              VWMAP(IMAP, 4,ISW)*(4*T4-1)*DT4DY+
     -              VWMAP(IMAP, 5,ISW)*(4*T2*DT1DY+4*T1*DT2DY)+
     -              VWMAP(IMAP, 6,ISW)*(4*T3*DT1DY+4*T1*DT3DY)+
     -              VWMAP(IMAP, 7,ISW)*(4*T4*DT1DY+4*T1*DT4DY)+
     -              VWMAP(IMAP, 8,ISW)*(4*T3*DT2DY+4*T2*DT3DY)+
     -              VWMAP(IMAP, 9,ISW)*(4*T4*DT2DY+4*T2*DT4DY)+
     -              VWMAP(IMAP,10,ISW)*(4*T4*DT3DY+4*T3*DT4DY)
                 EZ=VWMAP(IMAP, 1,ISW)*(4*T1-1)*DT1DZ+
     -              VWMAP(IMAP, 2,ISW)*(4*T2-1)*DT2DZ+
     -              VWMAP(IMAP, 3,ISW)*(4*T3-1)*DT3DZ+
     -              VWMAP(IMAP, 4,ISW)*(4*T4-1)*DT4DZ+
     -              VWMAP(IMAP, 5,ISW)*(4*T2*DT1DZ+4*T1*DT2DZ)+
     -              VWMAP(IMAP, 6,ISW)*(4*T3*DT1DZ+4*T1*DT3DZ)+
     -              VWMAP(IMAP, 7,ISW)*(4*T4*DT1DZ+4*T1*DT4DZ)+
     -              VWMAP(IMAP, 8,ISW)*(4*T3*DT2DZ+4*T2*DT3DZ)+
     -              VWMAP(IMAP, 9,ISW)*(4*T4*DT2DZ+4*T2*DT4DZ)+
     -              VWMAP(IMAP,10,ISW)*(4*T4*DT3DZ+4*T3*DT4DZ)
            ELSE
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                EWXMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWXMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWXMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWXMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWXMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWXMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWXMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWXMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWXMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWXMAP(IMAP,10,ISW)*T3*T4
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWYMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWYMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWYMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWYMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWYMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWYMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWYMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWYMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWYMAP(IMAP,10,ISW)*T3*T4
                 IF(MAPFLG(12+4*ISW-3))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWZMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWZMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWZMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWZMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWZMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWZMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWZMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWZMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWZMAP(IMAP,10,ISW)*T3*T4
            ENDIF
**  or quadratic in quadratic tetrahedra ....
       ELSEIF(MAPTYP.EQ.13.AND.MAPORD.EQ.2)THEN
            IF(LSFDER.AND.MAPFLG(13+4*ISW-3))THEN
                 EX=-(VWMAP(IMAP, 1,ISW)*(4*T1-1)*JAC(1,2)+
     -                VWMAP(IMAP, 2,ISW)*(4*T2-1)*JAC(2,2)+
     -                VWMAP(IMAP, 3,ISW)*(4*T3-1)*JAC(3,2)+
     -                VWMAP(IMAP, 4,ISW)*(4*T4-1)*JAC(4,2)+
     -                VWMAP(IMAP, 5,ISW)*(4*T2*JAC(1,2)+4*T1*JAC(2,2))+
     -                VWMAP(IMAP, 6,ISW)*(4*T3*JAC(1,2)+4*T1*JAC(3,2))+
     -                VWMAP(IMAP, 7,ISW)*(4*T4*JAC(1,2)+4*T1*JAC(4,2))+
     -                VWMAP(IMAP, 8,ISW)*(4*T3*JAC(2,2)+4*T2*JAC(3,2))+
     -                VWMAP(IMAP, 9,ISW)*(4*T4*JAC(2,2)+4*T2*JAC(4,2))+
     -                VWMAP(IMAP,10,ISW)*(4*T4*JAC(3,2)+4*T3*JAC(4,2)))/
     -                DET
                 EY=-(VWMAP(IMAP, 1,ISW)*(4*T1-1)*JAC(1,3)+
     -                VWMAP(IMAP, 2,ISW)*(4*T2-1)*JAC(2,3)+
     -                VWMAP(IMAP, 3,ISW)*(4*T3-1)*JAC(3,3)+
     -                VWMAP(IMAP, 4,ISW)*(4*T4-1)*JAC(4,3)+
     -                VWMAP(IMAP, 5,ISW)*(4*T2*JAC(1,3)+4*T1*JAC(2,3))+
     -                VWMAP(IMAP, 6,ISW)*(4*T3*JAC(1,3)+4*T1*JAC(3,3))+
     -                VWMAP(IMAP, 7,ISW)*(4*T4*JAC(1,3)+4*T1*JAC(4,3))+
     -                VWMAP(IMAP, 8,ISW)*(4*T3*JAC(2,3)+4*T2*JAC(3,3))+
     -                VWMAP(IMAP, 9,ISW)*(4*T4*JAC(2,3)+4*T2*JAC(4,3))+
     -                VWMAP(IMAP,10,ISW)*(4*T4*JAC(3,3)+4*T3*JAC(4,3)))/
     -                DET
                 EZ=-(VWMAP(IMAP, 1,ISW)*(4*T1-1)*JAC(1,4)+
     -                VWMAP(IMAP, 2,ISW)*(4*T2-1)*JAC(2,4)+
     -                VWMAP(IMAP, 3,ISW)*(4*T3-1)*JAC(3,4)+
     -                VWMAP(IMAP, 4,ISW)*(4*T4-1)*JAC(4,4)+
     -                VWMAP(IMAP, 5,ISW)*(4*T2*JAC(1,4)+4*T1*JAC(2,4))+
     -                VWMAP(IMAP, 6,ISW)*(4*T3*JAC(1,4)+4*T1*JAC(3,4))+
     -                VWMAP(IMAP, 7,ISW)*(4*T4*JAC(1,4)+4*T1*JAC(4,4))+
     -                VWMAP(IMAP, 8,ISW)*(4*T3*JAC(2,4)+4*T2*JAC(3,4))+
     -                VWMAP(IMAP, 9,ISW)*(4*T4*JAC(2,4)+4*T2*JAC(4,4))+
     -                VWMAP(IMAP,10,ISW)*(4*T4*JAC(3,4)+4*T3*JAC(4,4)))/
     -                DET
C      print *,' At ',t1,t2,t3,t4,' for isw = ',isw,' imap = ',imap,
C     -     ' E = ',ex,ey,ez,' vwmap = ',(vwmap(imap,i,isw),i=1,10)
            ELSEIF(.NOT.LSFDER)THEN
                 IF(MAPFLG(10+4*ISW-3))EX=
     -                EWXMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWXMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWXMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWXMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWXMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWXMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWXMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWXMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWXMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWXMAP(IMAP,10,ISW)*T3*T4
                 IF(MAPFLG(11+4*ISW-3))EY=
     -                EWYMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWYMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWYMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWYMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWYMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWYMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWYMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWYMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWYMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWYMAP(IMAP,10,ISW)*T3*T4
                 IF(MAPFLG(12+4*ISW-3))EZ=
     -                EWZMAP(IMAP,1,ISW)*T1*(2*T1-1)+
     -                EWZMAP(IMAP,2,ISW)*T2*(2*T2-1)+
     -                EWZMAP(IMAP,3,ISW)*T3*(2*T3-1)+
     -                EWZMAP(IMAP,4,ISW)*T4*(2*T4-1)+
     -                4*EWZMAP(IMAP,5,ISW)*T1*T2+
     -                4*EWZMAP(IMAP,6,ISW)*T1*T3+
     -                4*EWZMAP(IMAP,7,ISW)*T1*T4+
     -                4*EWZMAP(IMAP,8,ISW)*T2*T3+
     -                4*EWZMAP(IMAP,9,ISW)*T2*T4+
     -                4*EWZMAP(IMAP,10,ISW)*T3*T4
            ENDIF
*** Or an interpolation on a non-degerate hexahedron, interpolate.
       ELSEIF(MAPTYP.EQ.14.AND..NOT.ELMDGN(IMAP).AND..NOT.LSFDER)THEN
            IF(MAPFLG(10+4*ISW-3))EX=
     -           EWXMAP(IMAP,1,ISW)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EWXMAP(IMAP,2,ISW)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EWXMAP(IMAP,3,ISW)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EWXMAP(IMAP,4,ISW)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EWXMAP(IMAP,5,ISW)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EWXMAP(IMAP,6,ISW)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EWXMAP(IMAP,7,ISW)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EWXMAP(IMAP,8,ISW)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(11+4*ISW-3))EY=
     -           EWYMAP(IMAP,1,ISW)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EWYMAP(IMAP,2,ISW)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EWYMAP(IMAP,3,ISW)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EWYMAP(IMAP,4,ISW)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EWYMAP(IMAP,5,ISW)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EWYMAP(IMAP,6,ISW)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EWYMAP(IMAP,7,ISW)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EWYMAP(IMAP,8,ISW)*(1-T1)*(1+T2)*(1+T3)/8
            IF(MAPFLG(12+4*ISW-3))EZ=
     -           EWZMAP(IMAP,1,ISW)*(1-T1)*(1-T2)*(1-T3)/8+
     -           EWZMAP(IMAP,2,ISW)*(1+T1)*(1-T2)*(1-T3)/8+
     -           EWZMAP(IMAP,3,ISW)*(1+T1)*(1+T2)*(1-T3)/8+
     -           EWZMAP(IMAP,4,ISW)*(1-T1)*(1+T2)*(1-T3)/8+
     -           EWZMAP(IMAP,5,ISW)*(1-T1)*(1-T2)*(1+T3)/8+
     -           EWZMAP(IMAP,6,ISW)*(1+T1)*(1-T2)*(1+T3)/8+
     -           EWZMAP(IMAP,7,ISW)*(1+T1)*(1+T2)*(1+T3)/8+
     -           EWZMAP(IMAP,8,ISW)*(1-T1)*(1+T2)*(1+T3)/8
**  or an interpolation on a non-degerate hexahedron, derivatives.
       ELSEIF(MAPTYP.EQ.14.AND..NOT.ELMDGN(IMAP).AND.LSFDER)THEN
            IF(MAPFLG(13+4*ISW-3))EX=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,4,ISW)*(DN4DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,5,ISW)*(DN5DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,6,ISW)*(DN6DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,7,ISW)*(DN7DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,8,ISW)*(DN8DUH(T1,T2,T3)*JAC(1,1)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,1)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,1)))/DET
            IF(MAPFLG(13+4*ISW-3))EY=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,4,ISW)*(DN4DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,5,ISW)*(DN5DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,6,ISW)*(DN6DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,7,ISW)*(DN7DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,8,ISW)*(DN8DUH(T1,T2,T3)*JAC(1,2)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,2)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,2)))/DET
            IF(MAPFLG(13+4*ISW-3))EZ=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN1DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN1DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN2DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN2DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN3DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN3DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,4,ISW)*(DN4DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN4DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN4DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,5,ISW)*(DN5DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN5DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN5DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,6,ISW)*(DN6DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN6DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN6DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,7,ISW)*(DN7DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN7DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN7DWH(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,8,ISW)*(DN8DUH(T1,T2,T3)*JAC(1,3)+
     -                         DN8DVH(T1,T2,T3)*JAC(2,3)+
     -                         DN8DWH(T1,T2,T3)*JAC(3,3)))/DET
**  or an interpolation on a degerate hexahedron, interpolate
       ELSEIF(MAPTYP.EQ.14.AND.ELMDGN(IMAP).AND..NOT.LSFDER)THEN
            IF(MAPFLG(10+4*ISW-3))EX=
     -           EWXMAP(IMAP,1,ISW)*(1-T1-T2)*(1-T3)/2+
     -           EWXMAP(IMAP,2,ISW)*      T1 *(1-T3)/2+
     -           EWXMAP(IMAP,3,ISW)*      T2 *(1-T3)/2+
     -           EWXMAP(IMAP,5,ISW)*(1-T1-T2)*(1+T3)/2+
     -           EWXMAP(IMAP,6,ISW)*      T1 *(1+T3)/2+
     -           EWXMAP(IMAP,7,ISW)*      T2 *(1+T3)/2
            IF(MAPFLG(11+4*ISW-3))EY=
     -           EWYMAP(IMAP,1,ISW)*(1-T1-T2)*(1-T3)/2+
     -           EWYMAP(IMAP,2,ISW)*      T1 *(1-T3)/2+
     -           EWYMAP(IMAP,3,ISW)*      T2 *(1-T3)/2+
     -           EWYMAP(IMAP,5,ISW)*(1-T1-T2)*(1+T3)/2+
     -           EWYMAP(IMAP,6,ISW)*      T1 *(1+T3)/2+
     -           EWYMAP(IMAP,7,ISW)*      T2 *(1+T3)/2
            IF(MAPFLG(12+4*ISW-3))EZ=
     -           EWZMAP(IMAP,1,ISW)*(1-T1-T2)*(1-T3)/2+
     -           EWZMAP(IMAP,2,ISW)*      T1 *(1-T3)/2+
     -           EWZMAP(IMAP,3,ISW)*      T2 *(1-T3)/2+
     -           EWZMAP(IMAP,5,ISW)*(1-T1-T2)*(1+T3)/2+
     -           EWZMAP(IMAP,6,ISW)*      T1 *(1+T3)/2+
     -           EWZMAP(IMAP,7,ISW)*      T2 *(1+T3)/2
**  or an interpolation on a degerate hexahedron, derivatives.
       ELSEIF(MAPTYP.EQ.14.AND.ELMDGN(IMAP).AND.LSFDER)THEN
            IF(MAPFLG(13+4*ISW-3))EX=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,5,ISW)*(DN4DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,6,ISW)*(DN5DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,1))+
     -           VWMAP(IMAP,7,ISW)*(DN6DUP(T1,T2,T3)*JAC(1,1)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,1)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,1)))/DET
            IF(MAPFLG(13+4*ISW-3))EY=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,5,ISW)*(DN4DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,6,ISW)*(DN5DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,2))+
     -           VWMAP(IMAP,7,ISW)*(DN6DUP(T1,T2,T3)*JAC(1,2)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,2)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,2)))/DET
            IF(MAPFLG(13+4*ISW-3))EZ=
     -         -(VWMAP(IMAP,1,ISW)*(DN1DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN1DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN1DWP(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,2,ISW)*(DN2DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN2DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN2DWP(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,3,ISW)*(DN3DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN3DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN3DWP(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,5,ISW)*(DN4DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN4DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN4DWP(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,6,ISW)*(DN5DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN5DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN5DWP(T1,T2,T3)*JAC(3,3))+
     -           VWMAP(IMAP,7,ISW)*(DN6DUP(T1,T2,T3)*JAC(1,3)+
     -                         DN6DVP(T1,T2,T3)*JAC(2,3)+
     -                         DN6DWP(T1,T2,T3)*JAC(3,3)))/DET
*   Other elements.
       ELSE
            PRINT *,' !!!!!! IONFMP WARNING : Unknown element, type = ',
     -           MAPTYP,', order = ',MAPORD,', LSFDER = ',LSFDER
            RETURN
       ENDIF
*** Apply mirror imaging.
       IF(MIRRX)EX=-EX
       IF(MIRRY)EY=-EY
       IF(MIRRZ)EZ=-EZ
*** Rotate the field.
       IF(PERAX)THEN
            CALL CFMCTP(EY,EZ,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EY,EZ,1)
       ENDIF
       IF(PERAY)THEN
            CALL CFMCTP(EZ,EX,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EZ,EX,1)
       ENDIF
       IF(PERAZ)THEN
            CALL CFMCTP(EX,EY,XAUX,YAUX,1)
            YAUX=YAUX+AROT*180/PI
            CALL CFMPTC(XAUX,YAUX,EX,EY,1)
       ENDIF
*** And take care of symmetry.
       ER=EX
       EAXIS=EZ
       IF(PERRX)THEN
            IF(RCOOR.LE.0)THEN
                 EX=EAXIS
                 EY=0
                 EZ=0
            ELSE
                 EX=EAXIS
                 EY=ER*YIN/RCOOR
                 EZ=ER*ZIN/RCOOR
            ENDIF
       ENDIF
       IF(PERRY)THEN
            IF(RCOOR.LE.0)THEN
                 EX=0
                 EY=EAXIS
                 EZ=0
            ELSE
                 EX=ER*XIN/RCOOR
                 EY=EAXIS
                 EZ=ER*ZIN/RCOOR
            ENDIF
       ENDIF
       IF(PERRZ)THEN
            IF(RCOOR.LE.0)THEN
                 EX=0
                 EY=0
                 EZ=EAXIS
            ELSE
                 EX=ER*XIN/RCOOR
                 EY=ER*YIN/RCOOR
                 EZ=EAXIS
            ENDIF
       ENDIF
       END
CDECK  ID>, SIGWRT.
       SUBROUTINE SIGWRT
*-----------------------------------------------------------------------
*   SIGWRT - A routine that writes the signals to a file
*   VARIABLES : VALID      : Valid dataset available, if set to .TRUE.
*               FILE etc   : Data on the file to be written.
*   (Last changed on 19/ 1/11.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       CHARACTER*80 CELLID
       CHARACTER*3 TYPE
       CHARACTER WIRTYP(MXWIRE),PLATYP(5),
     -      PSLAB1(5,MXPSTR),PSLAB2(5,MXPSTR)
       LOGICAL YNPLAN(4),PERX,PERY,PERZ,YNPLAX,YNPLAY,YNMATX,YNMATY,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,
     -      PERRX,PERRY,PERRZ,CNALSO(MXWIRE),LBGFMP,CELSET,LDIPOL,
     -      BEMSET
       INTEGER INDSW(MXWIRE),NWIRE,NSW,ICTYPE,MODE,NTUBE,MTUBE,
     -      NXMATT,NYMATT,N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA(5),NPSTR1(5),NPSTR2(5),
     -      INDST1(5,MXPSTR),INDST2(5,MXPSTR)
       REAL X(MXWIRE),Y(MXWIRE),V(MXWIRE),E(MXWIRE),D(MXWIRE),W(MXWIRE),
     -      U(MXWIRE),DENS(MXWIRE),
     -      COSPH2(MXWIRE),SINPH2(MXWIRE),AMP2(MXWIRE),
     -      COPLAN(4),VTPLAN(4),XMATT(MXMATT,5),YMATT(MXMATT,5),
     -      X3D(MX3D),Y3D(MX3D),Z3D(MX3D),E3D(MX3D),
     -      DOWN(3),PLSTR1(5,MXPSTR,3),PLSTR2(5,MXPSTR,3),
     -      COTUBE,VTTUBE,B2SIN(MXWIRE),P1,P2,C1,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,
     -      KAPPA
       COMPLEX ZMULT,WMAP(MXWIRE)
       COMMON /CELDAT/ ZMULT,WMAP,X,Y,V,E,D,W,U,DENS,
     -      COSPH2,SINPH2,AMP2,
     -      B2SIN,COPLAN,VTPLAN,XMATT,YMATT,X3D,Y3D,Z3D,E3D,DOWN,
     -      PLSTR1,PLSTR2,
     -      XMIN,YMIN,ZMIN,XMAX,YMAX,ZMAX,VMIN,VMAX,
     -      COPLAX,COPLAY,COMATX,COMATY,COTUBE,VTTUBE,
     -      CORVTA,CORVTB,CORVTC,V0,SX,SY,SZ,P1,P2,C1,KAPPA,
     -      INDSW,NWIRE,NSW,ICTYPE,MODE,NXMATT,NYMATT,NTUBE,MTUBE,
     -      N3D,NTERMB,NTERMP,IENBGF,
     -      INDPLA,NPSTR1,NPSTR2,INDST1,INDST2,
     -      YNPLAN,YNPLAX,YNPLAY,YNMATX,YNMATY,PERX,PERY,PERZ,
     -      POLAR,TUBE,PERMX,PERMY,PERMZ,PERAX,PERAY,PERAZ,CNALSO,
     -      PERRX,PERRY,PERRZ,LBGFMP,CELSET,LDIPOL,BEMSET
       COMMON /CELCHR/ CELLID,WIRTYP,PLATYP,TYPE,PSLAB1,PSLAB2
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       CHARACTER*(MXCHAR) STRING
       CHARACTER*(MXNAME) FILE,AUX
       CHARACTER*80 FCNWRC,UNIT
       CHARACTER*29 REMARK
       CHARACTER*10 VARLIS(MXVAR)
       CHARACTER*8 TIME,DATE,MEMBER,FORMAT
       LOGICAL FLAG(MXWORD+3),VALID,IFWRT(MXLIST),USE(MXVAR)
C       LOGICAL EXMEMB
       INTEGER INPCMP,IENTRY,NCWRC,I,NWORD,INEXT,NCFILE,NCMEMB,NCREM,
     -      ISW,IOS,NWRITE,J,MODVAR(MXVAR),IFAIL,MODRES(1),NRES,NOUT,
     -      NCUNIT,NCAUX
       REAL RES(1),VAR(MXVAR),SCALET,SCALEI
       EXTERNAL INPCMP
       SAVE VALID,FILE,NCFILE,MEMBER,NCMEMB,REMARK,NCREM,FORMAT,
     -      IENTRY,NCWRC,SCALET,SCALEI
*** Initialise the various parameters.
       DATA VALID /.FALSE./
       DATA FILE   /' '/
       DATA MEMBER /'< none >'/
       DATA REMARK /'none'/
       DATA FORMAT /'SPICE   '/
       DATA NCFILE,NCMEMB,NCREM /1,8,4/
       DATA IENTRY /0/
       DATA SCALET /1.0/, SCALEI /1.0/
       FCNWRC=' '
       NCWRC=0
*** Identify the routine.
       IF(LIDENT)PRINT *,' /// ROUTINE SIGWRT ///'
*** Get the number of words, return if there is only one.
       CALL INPNUM(NWORD)
       IF(NWORD.LE.1)THEN
            PRINT *,' !!!!!! SIGWRT WARNING : WRITE takes at least 1'//
     -           ' argument (a dataset name); data will not be written.'
            RETURN
       ENDIF
**  Mark keywords.
       DO 10 I=1,NWORD+3
       FLAG(I)=.TRUE.
       IF(I.GT.NWORD)GOTO 10
       IF(INPCMP(I,'D#ATASET')+INPCMP(I,'FILE-#NAME')+
     -      INPCMP(I,'R#EMARK')+
     -      INPCMP(I,'WR#ITE-IF')+INPCMP(I,'F#ORMAT')+
     -      INPCMP(I,'U#NITS').EQ.0)FLAG(I)=.FALSE.
10     CONTINUE
**  Loop over the words.
       INEXT=2
       DO 20 I=2,NWORD
       IF(I.LT.INEXT)GOTO 20
*   Look for a DATASET.
       IF(INPCMP(I,'D#ATASET')+INPCMP(I,'FILE-#NAME').NE.0)THEN
            IF(FLAG(I+1))THEN
                 CALL INPMSG(I,'The dataset name is missing.  ')
                 INEXT=I+1
            ELSE
                 CALL INPSTR(I+1,I+1,STRING,NCFILE)
                 FILE=STRING
                 INEXT=I+2
                 IF(.NOT.FLAG(I+2))THEN
                      CALL INPSTR(I+2,I+2,STRING,NCMEMB)
                      MEMBER=STRING
                      INEXT=I+3
                 ENDIF
                 VALID=.TRUE.
            ENDIF
*   FORMAT specification, either SPICE or SCEPTRE.
       ELSEIF(INPCMP(I,'F#ORMAT').NE.0)THEN
            IF(FLAG(I+1))THEN
                 CALL INPMSG(I,'No format specification found.')
                 INEXT=I+1
            ELSE
                 IF(INPCMP(I+1,'SC#EPTRE').NE.0)THEN
                      FORMAT='SCEPTRE '
                 ELSEIF(INPCMP(I+1,'SP#ICE').NE.0)THEN
                      FORMAT='SPICE   '
                 ELSEIF(INPCMP(I+1,'SOR#IN').NE.0)THEN
                      FORMAT='SORIN    '
                 ELSE
                      CALL INPMSG(I+1,'Not a known dataset format.   ')
                 ENDIF
                 INEXT=I+2
            ENDIF
*   Remark.
       ELSEIF(INPCMP(I,'REM#ARK').NE.0)THEN
            IF(FLAG(I+1))THEN
                 CALL INPMSG(I,'The remark is missing.        ')
                 INEXT=I+1
            ELSE
                 CALL INPSTR(I+1,I+1,STRING,NCREM)
                 REMARK=STRING
                 INEXT=I+2
            ENDIF
*   Look for a write condition.
       ELSEIF(INPCMP(I,'WR#ITE-IF').NE.0)THEN
            IF(I+1.GT.NWORD)THEN
                 CALL INPMSG(I,'The function is not specified.')
            ELSE
                 CALL INPSTR(I+1,I+1,FCNWRC,NCWRC)
                 IF(NCWRC.GT.0.AND.IENTRY.GT.0)THEN
                      CALL ALGCLR(IENTRY)
                      IENTRY=0
                 ENDIF
            ENDIF
            INEXT=I+2
*   Units.
       ELSEIF(INPCMP(I,'U#NITS').NE.0)THEN
            DO 30 J=I+1,NWORD
            IF(FLAG(J))THEN
                 INEXT=J
                 GOTO 20
            ELSEIF(INPCMP(J,'SEC#ONDS').NE.0)THEN
                 SCALET=1E-6
            ELSEIF(INPCMP(J,'MIL#LI-SEC#ONDS')+
     -           INPCMP(J,'MILLISEC#ONDS')+
     -           INPCMP(J,'MSEC#ONDS').NE.0)THEN
                 SCALET=1E-3
            ELSEIF(INPCMP(J,'MIC#RO-SEC#ONDS')+
     -           INPCMP(J,'MICROSEC#ONDS')+
     -           INPCMP(J,'MUSEC#ONDS').NE.0)THEN
                 SCALET=1
            ELSEIF(INPCMP(J,'N#ANO-SEC#ONDS')+
     -           INPCMP(J,'NANOSEC#ONDS')+
     -           INPCMP(J,'NSEC#ONDS').NE.0)THEN
                 SCALET=1E+3
            ELSEIF(INPCMP(J,'P#ICO-SEC#ONDS')+
     -           INPCMP(J,'PICOSEC#ONDS')+
     -           INPCMP(J,'PSEC#ONDS').NE.0)THEN
                 SCALET=1E+6
            ELSEIF(INPCMP(J,'F#EMTO-SEC#ONDS')+
     -           INPCMP(J,'F#EMTOSEC#ONDS')+
     -           INPCMP(J,'FSEC#ONDS').NE.0)THEN
                 SCALET=1E+9
            ELSEIF(INPCMP(J,'A#TTO-SEC#ONDS')+
     -           INPCMP(J,'ATTOSEC#ONDS')+
     -           INPCMP(J,'ASEC#ONDS').NE.0)THEN
                 SCALET=1E+12
            ELSEIF(INPCMP(J,'KI#LO-A#MPERES')+
     -           INPCMP(J,'KILOA#MPERES')+
     -           INPCMP(J,'KA#MPERES').NE.0)THEN
                 SCALEI=1E-9
            ELSEIF(INPCMP(J,'A#MPERES').NE.0)THEN
                 SCALEI=1E-6
            ELSEIF(INPCMP(J,'MIL#LI-A#MPERES')+
     -           INPCMP(J,'MILLIA#MPERES')+
     -           INPCMP(J,'MA#MPERES').NE.0)THEN
                 SCALEI=1E-3
            ELSEIF(INPCMP(J,'MIC#RO-A#MPERES')+
     -           INPCMP(J,'MICROA#MPERES')+
     -           INPCMP(J,'MUA#MPERES').NE.0)THEN
                 SCALEI=1
            ELSEIF(INPCMP(J,'N#ANO-A#MPERES')+
     -           INPCMP(J,'NANOA#MPERES')+
     -           INPCMP(J,'NA#MPERES').NE.0)THEN
                 SCALEI=1E+3
            ELSEIF(INPCMP(J,'P#ICO-A#MPERES')+
     -           INPCMP(J,'PICOA#MPERES')+
     -           INPCMP(J,'PA#MPERES').NE.0)THEN
                 SCALEI=1E+6
            ELSEIF(INPCMP(J,'F#EMTO-A#MPERES')+
     -           INPCMP(J,'F#EMTOA#MPERES')+
     -           INPCMP(J,'FA#MPERES').NE.0)THEN
                 SCALEI=1E+9
            ELSEIF(INPCMP(J,'A#TTO-A#MPERES')+
     -           INPCMP(J,'ATTOA#MPERES')+
     -           INPCMP(J,'AA#MPERES').NE.0)THEN
                 SCALEI=1E+12
            ELSE
                 CALL INPMSG(J,'Not a known unit.')
            ENDIF
30          CONTINUE
            INEXT=NWORD+1
*   Invalid keyword.
       ELSE
            CALL INPMSG(I,'Invalid as a keyword.          ')
       ENDIF
20     CONTINUE
**  Print error messages.
       CALL INPERR
**  Check the dataset name length, if such a name will be needed.
       IF(VALID)THEN
            IF(NCFILE.GT.MXNAME)PRINT *,' !!!!!! SIGWRT WARNING : File',
     -           ' name truncated to MXNAME (=',MXNAME,') characters.'
            IF(NCMEMB.GT.8)PRINT *,' !!!!!! SIGWRT WARNING : Member',
     -           ' name shortened to ',MEMBER,', first 8 characters.'
            IF(NCREM.GT.29)PRINT *,' !!!!!! SIGWRT WARNING : Remark',
     -           ' shortened to ',REMARK,', first 29 characters.'
            NCFILE=MIN(NCFILE,MXNAME)
            NCMEMB=MIN(NCMEMB,8)
            NCREM=MIN(NCREM,29)
       ELSE
            PRINT *,' !!!!!! SIGWRT WARNING : No dataset name found;'//
     -           ' signals not written.'
            RETURN
       ENDIF
*   Check whether the member already exists.
C       CALL DSNREM(FILE(1:NCFILE),MEMBER(1:NCMEMB),'SIGNAL',EXMEMB)
C       IF(JEXMEM.EQ.2.AND.EXMEMB)THEN
C            PRINT *,' ------ SIGWRT MESSAGE : A copy of the member'//
C     -           ' exists; new member will be appended.'
C       ELSEIF(JEXMEM.EQ.3.AND.EXMEMB)THEN
C            PRINT *,' !!!!!! SIGWRT WARNING : A copy of the member'//
C     -           ' exists already; member will not be written.'
C            RETURN
C       ENDIF            
*   Print some debugging output if requested.
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ SIGWRT DEBUG   : File= '',A,
     -      '', member='',A/26X,''remark='',A,'', format='',A)')
     -      FILE(1:NCFILE),MEMBER(1:NCMEMB),REMARK(1:NCREM),FORMAT
       IF(LDEBUG)WRITE(LUNOUT,'(26X,''Write condition: '',A)')
     -      FCNWRC(1:MAX(1,NCWRC))
*** Translate the write condition, if there is no entry point yet.
       IF(IENTRY.LE.0.AND.NCWRC.GT.0)THEN
            VARLIS(1)='TIME      '
            VARLIS(2)='SIGNAL    '
            VARLIS(3)='SAMPLE    '
            CALL ALGPRE(FCNWRC(1:NCWRC),NCWRC,VARLIS,3,
     -           NRES,USE,IENTRY,IFAIL)
*   Verify that the translation worked correctly.
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! SIGWRT WARNING : Write condition'//
     -                ' could not be translated ; set to True.'
                 CALL ALGCLR(IENTRY)
                 IENTRY=0
                 NCWRC=0
                 RETURN
*   Make sure that there is only one result coming back.
            ELSEIF(NRES.NE.1)THEN
                 PRINT *,' !!!!!! SIGWRT WARNING : The write'//
     -                ' condition does not return 1 result ;'//
     -                ' set to True.'
                 CALL ALGCLR(IENTRY)
                 IENTRY=0
                 NCWRC=0
                 RETURN
            ENDIF
       ENDIF
*** Format the description of the units.
       UNIT='time in '
       NCUNIT=8
       IF(NINT(LOG10(SCALET)).EQ.12)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='atto second'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALET)).EQ.9)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='femto second'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALET)).EQ.6)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='pico second'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALET)).EQ.3)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='nano second'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALET)).EQ.0)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='micro second'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALET)).EQ.-3)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='milli second'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALET)).EQ.-6)THEN
            UNIT(NCUNIT+1:NCUNIT+6)='second'
            NCUNIT=NCUNIT+6
       ELSE
            UNIT(NCUNIT+1:NCUNIT+16)='<unknown> second'
            NCUNIT=NCUNIT+16
       ENDIF
       UNIT(NCUNIT+1:NCUNIT+13)=', current in '
       NCUNIT=NCUNIT+13
       IF(NINT(LOG10(SCALEI)).EQ.12)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='atto Ampere'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALEI)).EQ.9)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='femto Ampere'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALEI)).EQ.6)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='pico Ampere'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALEI)).EQ.3)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='nano Ampere'
            NCUNIT=NCUNIT+11
       ELSEIF(NINT(LOG10(SCALEI)).EQ.0)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='micro Ampere'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALEI)).EQ.-3)THEN
            UNIT(NCUNIT+1:NCUNIT+12)='milli Ampere'
            NCUNIT=NCUNIT+12
       ELSEIF(NINT(LOG10(SCALEI)).EQ.-6)THEN
            UNIT(NCUNIT+1:NCUNIT+6)='Ampere'
            NCUNIT=NCUNIT+6
       ELSEIF(NINT(LOG10(SCALEI)).EQ.-9)THEN
            UNIT(NCUNIT+1:NCUNIT+11)='kilo Ampere'
            NCUNIT=NCUNIT+11
       ELSE
            UNIT(NCUNIT+1:NCUNIT+16)='<unknown> Ampere'
            NCUNIT=NCUNIT+16
       ENDIF
*** Write the information to the dataset, start opening it.
       IF(FORMAT.NE.'SORIN   ')THEN
            CALL DSNOPN(FILE,NCFILE,12,'WRITE-LIBRARY',IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! SIGWRT WARNING : Opening ',
     -                FILE(1:NCFILE),' failed ; no signal data written.'
                 RETURN
            ENDIF
            CALL DSNLOG(FILE,'Signals   ','Sequential','Write     ')
       ENDIF
*** Loop over all sense wires.
       DO 240 ISW=1,NSW
*   For single signal files, open now.
       IF(FORMAT.EQ.'SORIN   ')THEN
            CALL NUMSAV(REAL(ISW),'GROUP',IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! SIGWRT WARNING : Storing read-out ',
     -                ' group variable "GROUP" failed;',
     -                ' no signals written.'
                 RETURN
            ENDIF
            AUX=FILE
            NCAUX=NCFILE
            CALL INPSUB(AUX,NCAUX,IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! SIGWRT WARNING : Global variable ',
     -                ' substitution in "',AUX(1:NCAUX),'" failed;',
     -                ' no signals written.'
                 RETURN
            ENDIF
            CALL DSNOPN(AUX,NCAUX,12,'WRITE-FILE',IFAIL)
            CALL DSNLOG(AUX,'Signals   ','Sequential','Write     ')
*   Otherwise write a heading record to the already open file,
       ELSE
            CALL DATTIM(DATE,TIME)
            WRITE(STRING,'(''% Created '',A8,'' At '',A8,
     -           '' < none > SIGNAL   "Direct signal, group '',I3,
     -           ''     "'')') DATE,TIME,ISW
            IF(REMARK.NE.'none')STRING(51:79)=REMARK
            IF(MEMBER.NE.'< none >')STRING(32:39)=MEMBER
            WRITE(12,'(A80)',IOSTAT=IOS,ERR=2010) STRING
*   Inform the user about the conductors in this group.
            CALL CELPRC(12,ISW)
       ENDIF
*   Evaluate the function.
       NWRITE=0
       IF(IENTRY.NE.0)THEN
            DO 205 J=1,NTIME
            VAR(1)=TIMSIG(J)
            MODVAR(1)=2
            VAR(2)=SIGNAL(J,ISW,1)
            MODVAR(2)=2
            VAR(3)=REAL(J)
            MODVAR(3)=2
            CALL ALGEXE(IENTRY,VAR,MODVAR,3,RES,MODRES,1,IFAIL)
            IF(IFAIL.EQ.0.AND.MODRES(1).EQ.3)THEN
                 IF(ABS(RES(1)).LT.1E-3)THEN
                      IFWRT(J)=.FALSE.
                 ELSE
                      IFWRT(J)=.TRUE.
                      NWRITE=NWRITE+1
                 ENDIF
            ELSE
                 PRINT *,' !!!!!! SIGWRT WARNING : WRITE-IF does not'//
     -                ' evaluate to a valid logical; set to True.'
                 IFWRT(J)=.TRUE.
                 NWRITE=NWRITE+1
            ENDIF
205         CONTINUE
       ELSE
            DO 206 J=1,NTIME
            IFWRT(J)=.TRUE.
            NWRITE=NWRITE+1
206         CONTINUE
       ENDIF
*   Check there is something to be written.
       IF(NWRITE.LE.0)THEN
            WRITE(12,'('' No signal data selected by WRITE-IF'')')
       ELSEIF(FORMAT.NE.'SORIN   ')THEN
            WRITE(12,'('' Number of signal records: '',I5)') NWRITE
       ENDIF
*   Write the name of the units.
       IF(FORMAT.NE.'SORIN')
     -      WRITE(12,'('' Units used: '',A,''.'')') UNIT(1:NCUNIT)
*   Write the data at the end of the file.
       NOUT=0
       DO 210 J=1,NTIME
       IF(.NOT.IFWRT(J))GOTO 210
       NOUT=NOUT+1
       IF(FORMAT.EQ.'SPICE   ')THEN
            IF(NOUT.EQ.NWRITE.AND.NOUT.EQ.1)THEN
                 WRITE(12,'('' .STIMULUS signal PWL''/
     -                '' + TIME_SCALE_FACTOR = '',E10.3/
     -                '' + VALUE_SCALE_FACTOR = '',E10.3/
     -                '' + ( '',E15.8,2X,E15.8,'' )'')',
     -                IOSTAT=IOS,ERR=2010) 1.0E-6*SCALET,1.0E-6*SCALEI,
     -                TIMSIG(J)*SCALET,SIGNAL(J,ISW,1)*SCALEI
            ELSEIF(NOUT.EQ.1)THEN
                 WRITE(12,'('' .STIMULUS signal PWL''/
     -                '' + TIME_SCALE_FACTOR = '',E10.3/
     -                '' + VALUE_SCALE_FACTOR = '',E10.3/
     -                '' + ( '',E15.8,2X,E15.8)',IOSTAT=IOS,
     -                ERR=2010) 1.0E-6*SCALET,1.0E-6*SCALEI,
     -                TIMSIG(J)*SCALET,SIGNAL(J,ISW,1)*SCALEI
            ELSEIF(NOUT.GT.1.AND.NOUT.LT.NWRITE)THEN
                 WRITE(12,'('' +'',4X,E15.8,2X,E15.8)',IOSTAT=IOS,
     -                ERR=2010) 
     -                TIMSIG(J)*SCALET,SIGNAL(J,ISW,1)*SCALEI
            ELSEIF(NOUT.EQ.NWRITE)THEN
                 WRITE(12,'('' +'',4X,E15.8,2X,E15.8,'' )'')',
     -                IOSTAT=IOS,ERR=2010) 
     -                TIMSIG(J)*SCALET,SIGNAL(J,ISW,1)*SCALEI
            ENDIF
       ELSEIF(FORMAT.EQ.'SCEPTRE ')THEN
            WRITE(12,'(2X,E15.8,'' , '',E15.8)',IOSTAT=IOS,ERR=2010)
     -           TIMSIG(J)*SCALET,SIGNAL(J,ISW,1)*SCALEI
       ELSEIF(FORMAT.EQ.'SORIN   ')THEN
            WRITE(12,'(2X,E15.8,''  '',E15.8)',IOSTAT=IOS,ERR=2010)
     -           TIMSIG(J)*SCALET,
     -           (SIGNAL(J,ISW,1)+SIGNAL(J,ISW,2))*SCALEI
       ELSE
            PRINT *,' ###### SIGWRT ERROR   : Signal dataset'//
     -           ' format not known ('//FORMAT//'); respecify.'
            RETURN
       ENDIF
210    CONTINUE
**  Same procedure for the cross induced signals.
       IF(LCROSS.AND.FORMAT.NE.'SORIN   ')THEN
            WRITE(STRING,'(''% Created '',A8,'' At '',A8,
     -          '' < none > SIGNAL   "Cross-talk, group '',I3,
     -          ''        "'')') DATE,TIME,ISW
            IF(REMARK.NE.'none')STRING(51:79)=REMARK
            IF(MEMBER.NE.'< none >')STRING(32:39)=MEMBER
            WRITE(12,'(A80)',IOSTAT=IOS,ERR=2010) STRING
*   Inform the user about the wires in this group.
            CALL CELPRC(12,ISW)
*   Evaluate the function.
            NWRITE=0
            IF(IENTRY.NE.0)THEN
                 DO 270 J=1,NTIME
                 VAR(1)=TIMSIG(J)
                 MODVAR(1)=2
                 VAR(2)=SIGNAL(J,ISW,2)
                 MODVAR(2)=2
                 VAR(3)=REAL(J)
                 MODVAR(3)=2
                 CALL ALGEXE(IENTRY,VAR,MODVAR,3,RES,MODRES,1,IFAIL)
                 IF(IFAIL.EQ.0.AND.MODRES(1).EQ.3)THEN
                      IF(ABS(RES(1)).LT.1E-3)THEN
                           IFWRT(J)=.FALSE.
                      ELSE
                           IFWRT(J)=.TRUE.
                           NWRITE=NWRITE+1
                      ENDIF
                 ELSE
                      PRINT *,' !!!!!! SIGWRT WARNING : WRITE-IF does'//
     -                     ' not evaluate to a valid logical;'//
     -                     ' set to True.'
                      IFWRT(J)=.TRUE.
                      NWRITE=NWRITE+1
                 ENDIF
270              CONTINUE
            ELSE
                 DO 280 J=1,NTIME
                 IFWRT(J)=.TRUE.
                 NWRITE=NWRITE+1
280              CONTINUE
            ENDIF
*   Check there is something to be written.
            IF(NWRITE.LE.0)THEN
                 WRITE(12,'('' No signal data selected by WRITE-IF'')')
            ELSE
                 WRITE(12,'('' Number of signal records: '',I5)') NWRITE
            ENDIF
*   Write the name of the units.
            WRITE(12,'('' Units used: '',A,''.'')') UNIT(1:NCUNIT)
*   Write the data at the end of the file.
            NOUT=0
            DO 220 J=1,NTIME
            IF(.NOT.IFWRT(J))GOTO 220
            NOUT=NOUT+1
            IF(FORMAT.EQ.'SPICE   ')THEN
                 IF(NOUT.EQ.NWRITE.AND.NOUT.EQ.1)THEN
                      WRITE(12,'('' .STIMULUS signal PWL''/
     -                     '' + TIME_SCALE_FACTOR = '',E10.3/
     -                     '' + VALUE_SCALE_FACTOR = '',E10.3/
     -                     '' + ( '',E15.8,2X,E15.8,'' )'')',
     -                     IOSTAT=IOS,ERR=2010)
     -                     1.0E-6*SCALET,1.0E-6*SCALEI,
     -                     TIMSIG(J)*SCALET,SIGNAL(J,ISW,2)*SCALEI
                 ELSEIF(NOUT.EQ.1)THEN
                      WRITE(12,'('' .STIMULUS signal PWL''/
     -                     '' + TIME_SCALE_FACTOR = '',E10.3/
     -                     '' + VALUE_SCALE_FACTOR = '',E10.3/
     -                     '' + ( '',E15.8,2X,E15.8)',IOSTAT=IOS,
     -                     ERR=2010) 1.0E-6*SCALET,1.0E-6*SCALEI,
     -                     TIMSIG(J)*SCALET,SIGNAL(J,ISW,2)*SCALEI
                 ELSEIF(NOUT.GT.1.AND.NOUT.LT.NWRITE)THEN
                      WRITE(12,'('' +'',4X,E15.8,2X,E15.8)',IOSTAT=IOS,
     -                     ERR=2010) 
     -                     TIMSIG(J)*SCALET,SIGNAL(J,ISW,2)*SCALEI
                 ELSEIF(NOUT.EQ.NWRITE)THEN
                      WRITE(12,'('' +'',4X,E15.8,2X,E15.8,'' )'')',
     -                     IOSTAT=IOS,ERR=2010) 
     -                     TIMSIG(J)*SCALET,SIGNAL(J,ISW,2)*SCALEI
                 ENDIF
            ELSEIF(FORMAT.EQ.'SCEPTRE ')THEN
                 WRITE(12,'(2X,E15.8,'' , '',E15.8)',
     -                IOSTAT=IOS,ERR=2010) 
     -                TIMSIG(J)*SCALET,SIGNAL(J,ISW,2)*SCALEI
            ELSE
                 PRINT *,' ###### SIGWRT ERROR   : Signal dataset'//
     -                ' format not known ('//FORMAT//'); respecify.'
                 RETURN
            ENDIF
220         CONTINUE
       ENDIF
*** Signal group files.
       IF(FORMAT.EQ.'SORIN   ')
     -      CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
240    CONTINUE
*** Normal end of the routine, return after closing the file.
       IF(FORMAT.NE.'SORIN   ')
     -      CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       RETURN
*** Handle error conditions.
2010   CONTINUE
       PRINT *,' ###### SIGWRT ERROR   : Error while writing'//
     -         ' to the file ',FILE(1:NCFILE),' on unit 12.'
       CALL INPIOS(IOS)
       CLOSE(UNIT=12,STATUS='KEEP',IOSTAT=IOS,ERR=2030)
       RETURN
2030   CONTINUE
       PRINT *,' ###### SIGWRT ERROR   : '//FILE(1:NCFILE)//
     -      ' could not be closed properly ; results not predictable.'
       CALL INPIOS(IOS)
       END
CDECK  ID>, GASBMC.
      SUBROUTINE GASBMC(IFAIL)
*-----------------------------------------------------------------------
*   GASBMC - Interface routine for Magboltz 7 called from Garfield.
*   (Last changed on  4/ 4/08.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL MAGOK
       REAL ALFA,B0X,B0Y,B0Z,SUSWIR,SUSGAS,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX
       INTEGER MAGSRC,
     -      IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z
       CHARACTER*(MXCHAR) FUNB0X,FUNB0Y,FUNB0Z
       COMMON /MAGDAT/ ALFA,SUSWIR,SUSGAS,
     -      B0X,B0Y,B0Z,BSCALE,BFMIN,BFMAX,
     -      BFXMIN,BFYMIN,BFZMIN,BFXMAX,BFYMAX,BFZMAX,
     -      MAGSRC,IBXTYP,IBYTYP,IBZTYP,
     -      IRB0X,IRB0Y,IRB0Z,IRV0X,IRV0Y,IRV0Z,
     -      IENB0X,IENB0Y,IENB0Z,IBXDIR,IBYDIR,IBZDIR,
     -      NCB0X,NCB0Y,NCB0Z,
     -      MAGOK
       COMMON /MAGCHR/ FUNB0X,FUNB0Y,FUNB0Z
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL GLBVAL(MXVAR)
       INTEGER NGLB,GLBMOD(MXVAR)
       CHARACTER*10 GLBVAR(MXVAR)
       COMMON /GLBDAT/ GLBVAL,GLBMOD,NGLB
       COMMON /GLBCHR/ GLBVAR
       REAL MVEC(MXEMAT)
       INTEGER MSIZ(MXMAT,MXMDIM),MDIM(MXMAT),MREF(MXMAT+1),MMOD(MXMAT),
     -      MORG(MXMAT+1),MLEN(MXMAT+1),NREFL
       COMMON /MATDAT/ MVEC,MSIZ,MDIM,MMOD,MORG,MLEN,MREF,NREFL
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMPLEX ICONS
       REAL PI,CLOG2,EPS0,ECHARG,EMASS,CLIGHT,MEV2KG,BOLTZ,GRAV
       PARAMETER (PI=3.141592653589793238,
     -      CLOG2=0.693147180559945309417,
     -      ICONS=(0.0,1.0),
     -      EPS0=8.854187817E-14,
     -      ECHARG=1.60217733E-19,
     -      EMASS=9.1093897E-31,
     -      GRAV=9.80665,
     -      CLIGHT=2.99792458E4,
     -      MEV2KG = 1.782661845E-30,
     -      BOLTZ=1.380658E-23)
       DOUBLE PRECISION FRTOT
       REAL AUX,EPMIN,EPMAX,EPMINR,EPMAXR,SSTTHR,SSTHRR,
     -      BANGMN,BANGMX,BAMINR,BAMAXR,BTABMN,BTABMX,BTMINR,BTMAXR,
     -      VAR(MXVAR),RES(1),EFLDR,BFLDR,ANGR,
     -      VBOL,XBOL,YBOL,WBOL,DBOL,OBOL,ABOL,BBOL,SBOL(6),
     -      EXBOL(MXEXG),IOBOL(MXIOG)
       INTEGER INPTYP,INPCMP,MODVAR(MXVAR),MODRES(1),NCMOB,ISLOT,
     -      I,J,K,L,IFAIL,IFAIL1,IFAIL2,INEXT,NGASR,NBANGR,NBTABR,
     -      NWORD,NCOUT,NRES,NC,IENTRY,NNMAX,NMAXR,IGLB,NCSTR,
     -      MATSLT
       LOGICAL EPLOG,USE(MXVAR),OK,ESET,BSET,ASET
       CHARACTER*(MXCHAR) STRING
       CHARACTER*500 STR
       CHARACTER*20 OUTSTR
       CHARACTER*10 VARLIS(MXVAR)
       EXTERNAL INPTYP,INPCMP,MATSLT
*** Identify.
       IF(LIDENT)PRINT *,' /// ROUTINE GASBMC ///'
       PRINT *,' ------ GASBMC MESSAGE : Calling interfaced Magboltz'//
     -      ' version 7.08, last changed on 1/3/12.'
*** Initial values for the E/p scale.
       EPMIN=100.0/PGAS
       EPMAX=100000.0/PGAS
       EPLOG=.TRUE.
       NGAS=20
       ESET=.FALSE.
*   E-B angles.
       IF(MAGOK)THEN
            BANGMN=0
            BANGMX=PI/2
            NBANG=4
       ELSE
            BANGMN=PI/2
            BANGMX=PI/2
            NBANG=1
       ENDIF
       ASET=.FALSE.
*   B field magnitude.
       IF(MAGOK)THEN
            IF(ABS((BFMIN-BFMAX)*BSCALE).LT.0.0001)THEN
                 BTABMN=BFMIN*BSCALE
                 BTABMX=BFMAX*BSCALE
                 NBTAB=1
            ELSE
                 BTABMN=BFMIN*BSCALE
                 BTABMX=BFMAX*BSCALE
                 NBTAB=6
            ENDIF
       ELSE
            BTABMN=0
            BTABMX=0
            NBTAB=1
       ENDIF
       BSET=.FALSE.
*   Plotting distribution functions.
       LF0PLT=.FALSE.
*   Cross section plot.
       LCSPLT=.FALSE.
*   Saving cross section and energy distribution data.
       LGKEEP=.FALSE.
*   Printing Magboltz output.
       LBMCPR=.FALSE.
*   Mobility.
       VARLIS(1)='EP'
       NCMOB=0
*   MC accuracy parameters.
       NNMAX=2
*   SST threshold.
C       SSTTHR=60
*   Next line changed at the request of Steve Biagi (6/9/2007)
       SSTTHR=30.0D0
*** Prepare for progress printing.
       CALL PROINT('MAGBOLTZ',1,6)
*** Preset failure flag to 0: success.
       IFAIL=0
*** Preset the gas mixture fractions.
       DO 10 I=1,MXGNAM
       FRAMIX(I)=0.0
10     CONTINUE
*** Read the command line.
       CALL PROFLD(1,'Reading command',-1.0)
       CALL PROSTA(1,0.0)
       CALL INPNUM(NWORD)
       INEXT=2
*   Control of whether to proceed.
       OK=.TRUE.
       DO 20 I=2,NWORD
       IF(I.LT.INEXT)GOTO 20
*** Fractions, CF4 (current data).
       IF(INPCMP(I,'CF4')+
     -      INPCMP(I,'FREON-#14')+
     -      INPCMP(I,'TETRAFLUOROMETHANE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(1)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Argon (isotropic).
       ELSEIF(INPCMP(I,'AR#GON-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(2)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Helium 4 (isotropic).
       ELSEIF(INPCMP(I,'HE#LIUM-4-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(3)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Helium 3 (isotropic).
       ELSEIF(INPCMP(I,'HE#LIUM-3-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(4)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Neon (isotropic).
       ELSEIF(INPCMP(I,'NEON-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(5)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Krypton (isotropic).
       ELSEIF(INPCMP(I,'KR#YPTON-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(6)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Xenon (isotropic).
       ELSEIF(INPCMP(I,'XE#NON-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(7)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Methane (only version, isotropic).
       ELSEIF(INPCMP(I,'METHANE')+
     -      INPCMP(I,'CH4').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(8)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Ethane.
       ELSEIF(INPCMP(I,'ETHANE')+
     -      INPCMP(I,'C2H6').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(9)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Propane.
       ELSEIF(INPCMP(I,'PROPA#NE')+
     -      INPCMP(I,'C3H8').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(10)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Isobutane.
       ELSEIF(INPCMP(I,'ISO#BUTANE')+
     -      INPCMP(I,'IC4H10')+
     -      INPCMP(I,'ISO-C4H10')+
     -      INPCMP(I,'C4H10').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(11)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   CO2 (isotropic).
       ELSEIF(INPCMP(I,'CO2')+
     -      INPCMP(I,'CARB#ON-DIOX#IDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(12)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Neopentane (current data)
       ELSEIF(INPCMP(I,'NEOPENT#ANE')+
     -      INPCMP(I,'NEO-PENT#ANE')+
     -      INPCMP(I,'NEO-C5H12')+
     -      INPCMP(I,'C5H12').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(13)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Water (current data).
       ELSEIF(INPCMP(I,'WA#TER-#VAPOUR')+
     -      INPCMP(I,'H2O').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(14)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Oxygen (current data).
       ELSEIF(INPCMP(I,'OX#YGEN')+
     -      INPCMP(I,'O2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(15)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Nitrogen (isotropic).
       ELSEIF(INPCMP(I,'NI#TROGEN-ISO#TROPIC')+
     -      INPCMP(I,'N2-ISO#TROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(16)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Nitric oxide (NO).
       ELSEIF(INPCMP(I,'NITRI#C-OX#IDE')+
     -      INPCMP(I,'NITROGEN-MONOXIDE')+
     -      INPCMP(I,'NO').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(17)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Nitrous oxide (N2O).
       ELSEIF(INPCMP(I,'NITRO#US-OX#IDE')+
     -      INPCMP(I,'DINITROGEN-MONOXIDE')+
     -      INPCMP(I,'LAUGHING-GAS')+
     -      INPCMP(I,'N2O').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(18)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Ethene (C2H4).
       ELSEIF(INPCMP(I,'ETHE#NE')+
     -      INPCMP(I,'ETHYLENE')+
     -      INPCMP(I,'C2H4').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(19)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Acetylene (C2H2).
       ELSEIF(INPCMP(I,'ACETYL#ENE')+
     -      INPCMP(I,'ETHYNE')+
     -      INPCMP(I,'C2H2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(20)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Hydrogen.
       ELSEIF(INPCMP(I,'HYDROGEN')+
     -      INPCMP(I,'H2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(21)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Deuterium.
       ELSEIF(INPCMP(I,'DEUTERIUM')+
     -      INPCMP(I,'D2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(22)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Carbon monoxide (CO).
       ELSEIF(INPCMP(I,'CO')+
     -      INPCMP(I,'CARB#ON-MONOX#IDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(23)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Methylal (dimethoxymethane, CH3-O-CH2-O-CH3, "hot" version).
       ELSEIF(INPCMP(I,'METHY#LAL-#HOT')+
     -      INPCMP(I,'DIMETHOXYMETHANE-#HOT')+
     -      INPCMP(I,'DMM-#HOT')+
     -      INPCMP(I,'C3H8O2-#HOT').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(24)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   DME.
       ELSEIF(INPCMP(I,'DME')+
     -      INPCMP(I,'DIMETHYL-ETHER')+
     -      INPCMP(I,'METHOXYMETHANE')+
     -      INPCMP(I,'METHYL-ETHER')+
     -      INPCMP(I,'WOOD-ETHER')+
     -      INPCMP(I,'C2H6O').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(25)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Reid step.
       ELSEIF(INPCMP(I,'REID-STEP').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(26)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Maxwell model.
       ELSEIF(INPCMP(I,'MAXWELL-MODEL').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(27)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Reid ramp.
       ELSEIF(INPCMP(I,'REID-RAMP').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(28)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   C2F6.
       ELSEIF(INPCMP(I,'C2F6')+
     -      INPCMP(I,'FREON-116')+
     -      INPCMP(I,'ZYRON-116-#N5')+
     -      INPCMP(I,'HEXAFLUOROETHANE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(29)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   SF6.
       ELSEIF(INPCMP(I,'SF6')+
     -      INPCMP(I,'SULPHUR-HEXAFLUORIDE')+
     -      INPCMP(I,'SULFUR-HEXAFLUORIDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(30)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   NH3.
       ELSEIF(INPCMP(I,'AMMONIA')+
     -      INPCMP(I,'NH3').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(31)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Propene.
       ELSEIF(INPCMP(I,'PROPE#NE')+
     -      INPCMP(I,'PROPYLENE')+
     -      INPCMP(I,'C3H6').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(32)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Cyclopropane.
       ELSEIF(INPCMP(I,'C#YCLO-PROPA#NE')+
     -      INPCMP(I,'CYCLOPROPA#NE')+
     -      INPCMP(I,'C#YCLO-C3H6').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(33)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Methanol.
       ELSEIF(INPCMP(I,'METHANOL')+
     -      INPCMP(I,'METHYL-ALCOHOL')+
     -      INPCMP(I,'WOOD-ALCOHOL')+
     -      INPCMP(I,'CH3OH').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(34)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Ethanol.
       ELSEIF(INPCMP(I,'ETHANOL')+
     -      INPCMP(I,'ETHYL-ALCOHOL')+
     -      INPCMP(I,'GRAIN-ALCOHOL')+
     -      INPCMP(I,'C2H5OH').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(35)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Propanol.
       ELSEIF(INPCMP(I,'PROPANOL')+
     -      INPCMP(I,'2-PROP#ANOL')+
     -      INPCMP(I,'ISO-PROP#ANOL')+
     -      INPCMP(I,'ISOPROP#ANOL')+
     -      INPCMP(I,'ISOPROPYL-#ALCOHOL')+
     -      INPCMP(I,'C3H7OH').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(36)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Cesium / Caesium.
       ELSEIF(INPCMP(I,'CE#SIUM')+
     -      INPCMP(I,'CAE#SIUM')+
     -      INPCMP(I,'CS').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(37)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Fluorine.
       ELSEIF(INPCMP(I,'FLUOR#INE')+
     -      INPCMP(I,'F2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(38)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   CS2.
       ELSEIF(INPCMP(I,'CS2')+
     -      INPCMP(I,'C#ARBON-DISULPH#IDE')+
     -      INPCMP(I,'C#ARBON-DISULF#IDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(39)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   COS.
       ELSEIF(INPCMP(I,'COS')+
     -      INPCMP(I,'C#ARBONYL-SULPH#IDE')+
     -      INPCMP(I,'C#ARBONYL-SULF#IDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(40)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Deuterated methane.
       ELSEIF(INPCMP(I,'DEUT#ERIUM-METHANE')+
     -      INPCMP(I,'DEUT#ERATED-METHANE')+
     -      INPCMP(I,'CD4').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(41)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   BF3.
       ELSEIF(INPCMP(I,'BF3')+
     -      INPCMP(I,'BORON-TRIFLUORIDE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(42)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   C2HF5 and C2H2F4.
       ELSEIF(INPCMP(I,'C2HF5')+
     -      INPCMP(I,'C2H2F4')+
     -      INPCMP(I,'C2F5H')+
     -      INPCMP(I,'C2F4H2')+
     -      INPCMP(I,'FREON-134-#A')+
     -      INPCMP(I,'FREON-125')+
     -      INPCMP(I,'ZYRON-125')+
     -      INPCMP(I,'TETRAFLUOROETHANE')+
     -      INPCMP(I,'PENTAFLUOROETHANE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(43)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Helium 3 (anisotropic).
       ELSEIF(INPCMP(I,'HE#LIUM-3-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(44)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Helium 4 (anisotropic).
       ELSEIF(INPCMP(I,'HE#LIUM-#4-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(45)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Neon (anisotropic).
       ELSEIF(INPCMP(I,'NEON-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(46)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Argon (anisotropic).
       ELSEIF(INPCMP(I,'AR#GON-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(47)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Krypton (anisotropic).
       ELSEIF(INPCMP(I,'KR#YPTON-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(48)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Xenon (anisotropic).
       ELSEIF(INPCMP(I,'XE#NON-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(49)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   CHF3.
       ELSEIF(INPCMP(I,'CHF3')+
     -      INPCMP(I,'FREON-23')+
     -      INPCMP(I,'TRIFLUOROMETHANE').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(50)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   CF3Br.
       ELSEIF(INPCMP(I,'CF3BR')+
     -      INPCMP(I,'TRIFLUOROBROMOMETHANE')+
     -      INPCMP(I,'HALON-1301')+
     -      INPCMP(I,'FREON-13B1').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(51)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   C3F8.
       ELSEIF(INPCMP(I,'C3F8')+
     -      INPCMP(I,'OCTAFLUOROPROPANE')+
     -      INPCMP(I,'R218')+
     -      INPCMP(I,'FREON-218')+
     -      INPCMP(I,'PERFLUOROPROPANE')+
     -      INPCMP(I,'RC-218')+
     -      INPCMP(I,'PFC-218').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(52)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Ozone.
       ELSEIF(INPCMP(I,'OZONE')+
     -      INPCMP(I,'O3').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(53)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Mercury.
       ELSEIF(INPCMP(I,'MERCURY')+
     -      INPCMP(I,'HG')+
     -      INPCMP(I,'HG2').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(54)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   H2S.
       ELSEIF(INPCMP(I,'H2S')+
     -      INPCMP(I,'HYDROGEN-SULPHIDE')+
     -      INPCMP(I,'HYDROGEN-SULFIDE')+
     -      INPCMP(I,'HEPATIC-ACID')+
     -      INPCMP(I,'SEWER-GAS')+
     -      INPCMP(I,'SULFUR-HYDRIDE')+
     -      INPCMP(I,'DIHYDROGEN-MONOSULFIDE')+
     -      INPCMP(I,'DIHYDROGEN-MONOSULPHIDE')+
     -      INPCMP(I,'SULPHUR-HYDRIDE')+
     -      INPCMP(I,'STINK-DAMP')+
     -      INPCMP(I,'SULFURETED-HYDROGEN ').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(55)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   n-butane.
       ELSEIF(INPCMP(I,'N-BUTANE')+
     -      INPCMP(I,'N-C4H10').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(56)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   n-pentane.
       ELSEIF(INPCMP(I,'N-PENTANE')+
     -      INPCMP(I,'N-C5H12').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(57)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Nitrogen.
       ELSEIF(INPCMP(I,'NI#TROGEN-#ANISOTROPIC')+
     -      INPCMP(I,'N2-#ANISOTROPIC').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(58)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Germane, GeH4.
       ELSEIF(INPCMP(I,'GERM#ANE')+
     -      INPCMP(I,'GERMANIUM-HYDRIDE')+
     -      INPCMP(I,'GERMANIUM-TETRAHYDRIDE')+
     -      INPCMP(I,'GERMANOMETHANE')+
     -      INPCMP(I,'MONOGERMANE')+
     -      INPCMP(I,'GEH4').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(59)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Silane, SiH4.
       ELSEIF(INPCMP(I,'SIL#ANE')+
     -      INPCMP(I,'SILICON-HYDRIDE')+
     -      INPCMP(I,'SILICON-TETRAHYDRIDE')+
     -      INPCMP(I,'SILICANE')+
     -      INPCMP(I,'MONOSILANE')+
     -      INPCMP(I,'SIH4').NE.0)THEN
            IF(INPTYP(I+1).NE.1.AND.INPTYP(I+1).NE.2.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,AUX,0.0)
                 FRAMIX(60)=AUX
                 IF(IFAIL1.NE.0)OK=.FALSE.
            ENDIF
            INEXT=I+2
*   Range of E/p.
       ELSEIF(INPCMP(I,'E/P-RAN#GE').NE.0)THEN
            CALL INPCHK(I+1,2,IFAIL1)
            CALL INPCHK(I+2,2,IFAIL2)
            IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.NWORD.GE.I+2)THEN
                 CALL INPRDR(I+1,EPMINR,EPMIN)
                 CALL INPRDR(I+2,EPMAXR,EPMAX)
                 IF(EPMINR.NE.EPMAXR.AND.EPMINR.GT.0.0.AND.
     -                EPMAXR.GT.0.0)THEN
                      EPMIN=MIN(EPMINR,EPMAXR)
                      EPMAX=MAX(EPMINR,EPMAXR)
                 ELSE
                      CALL INPMSG(I+1,'Zero range and negative values')
                      CALL INPMSG(I+2,'are not permitted in RANGE.   ')
                      OK=.FALSE.
                 ENDIF
            ELSE
                 CALL INPMSG(I,'Missing or invalid arguments. ')
                 OK=.FALSE.
            ENDIF
            ESET=.FALSE.
            INEXT=I+3
*   Listed E/p values.
       ELSEIF(INPCMP(I,'E/P').NE.0)THEN
            IF(INPTYP(I+1).EQ.0)THEN
                 CALL INPSTR(I+1,I+1,STRING,NCSTR)
                 DO 250 IGLB=1,NGLB
                 IF(STRING(1:NCSTR).EQ.GLBVAR(IGLB))THEN
                      ISLOT=MATSLT(NINT(GLBVAL(IGLB)))
                      IF(GLBMOD(IGLB).NE.5)THEN
                           CALL INPMSG(I+1,'Not of type Matrix.')
                           OK=.FALSE.
                      ELSEIF(ISLOT.LE.0)THEN
                           CALL INPMSG(I+1,'Matrix inaccessible.')
                           OK=.FALSE.
                      ELSEIF(MLEN(ISLOT).GT.MXLIST)THEN
                           CALL INPMSG(I+1,'More than MXLIST elements.')
                           OK=.FALSE.
                      ELSE
                           NGAS=MLEN(ISLOT)
                           DO 270 J=1,NGAS
                           IF(MVEC(MORG(ISLOT)+J).LE.0)THEN
                                CALL INPMSG(I+1,'Contains values <= 0.')
                                OK=.FALSE.
                                GOTO 260
                           ELSE
                                EGAS(J)=MVEC(MORG(ISLOT)+J)
                           ENDIF
270                        CONTINUE
                           ESET=.TRUE.
                      ENDIF
                      GOTO 260
                 ENDIF
250              CONTINUE
                 CALL INPMSG(I+1,'Not a global variable.')
                 OK=.FALSE.
260              CONTINUE
                 INEXT=I+2
            ELSEIF(INPTYP(I+1).EQ.1.OR.INPTYP(I+1).EQ.2)THEN
                 NGAS=0
                 DO 280 J=I+1,NWORD
                 IF(INPTYP(J).NE.1.AND.INPTYP(J).NE.2)THEN
                      INEXT=J
                      GOTO 290
                 ELSEIF(NGAS+1.GT.MXLIST)THEN
                      CALL INPMSG(J,'Too many values, ignored.')
                      OK=.FALSE.
                      GOTO 280
                 ENDIF
                 CALL INPCHK(J,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(J,EFLDR,0.0)
                      IF(EFLDR.GT.0.0)THEN
                           NGAS=NGAS+1
                           EGAS(NGAS)=EFLDR
                      ELSE
                           CALL INPMSG(J,'Not strictly positive.')
                           OK=.FALSE.
                      ENDIF
                 ELSE
                      CALL INPMSG(J,'Invalid field value.')
                      OK=.FALSE.
                 ENDIF
280              CONTINUE
                 INEXT=NWORD+1
290              CONTINUE
                 ESET=.TRUE.
            ELSE
                 CALL INPMSG(I,'Invalid field specification.')
                 OK=.FALSE.
                 INEXT=I+2
            ENDIF
*   Range of E.
       ELSEIF(INPCMP(I,'E#LECTRIC-RAN#GE')+
     -      INPCMP(I,'E#LECTRIC-F#IELD-RAN#GE').NE.0)THEN
            CALL INPCHK(I+1,2,IFAIL1)
            CALL INPCHK(I+2,2,IFAIL2)
            IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.NWORD.GE.I+2)THEN
                 CALL INPRDR(I+1,EPMINR,EPMIN*PGAS)
                 CALL INPRDR(I+2,EPMAXR,EPMAX*PGAS)
                 IF(EPMINR.NE.EPMAXR.AND.EPMINR.GT.0.0.AND.
     -                EPMAXR.GT.0.0)THEN
                      EPMIN=MIN(EPMINR,EPMAXR)/PGAS
                      EPMAX=MAX(EPMINR,EPMAXR)/PGAS
                 ELSE
                      CALL INPMSG(I+1,'Zero range and negative values')
                      CALL INPMSG(I+2,'are not permitted in RANGE.   ')
                      OK=.FALSE.
                 ENDIF
            ELSE
                 CALL INPMSG(I,'Missing or invalid arguments. ')
                 OK=.FALSE.
            ENDIF
            ESET=.FALSE.
            INEXT=I+3
*   Listed values of E.
       ELSEIF(INPCMP(I,'E#LECTRIC-FIELD').NE.0)THEN
            IF(INPTYP(I+1).EQ.0)THEN
                 CALL INPSTR(I+1,I+1,STRING,NCSTR)
                 DO 200 IGLB=1,NGLB
                 IF(STRING(1:NCSTR).EQ.GLBVAR(IGLB))THEN
                      ISLOT=MATSLT(NINT(GLBVAL(IGLB)))
                      IF(GLBMOD(IGLB).NE.5)THEN
                           CALL INPMSG(I+1,'Not of type Matrix.')
                           OK=.FALSE.
                      ELSEIF(ISLOT.LE.0)THEN
                           CALL INPMSG(I+1,'Matrix inaccessible.')
                           OK=.FALSE.
                      ELSEIF(MLEN(ISLOT).GT.MXLIST)THEN
                           CALL INPMSG(I+1,'More than MXLIST elements.')
                           OK=.FALSE.
                      ELSE
                           NGAS=MLEN(ISLOT)
                           DO 220 J=1,NGAS
                           IF(MVEC(MORG(ISLOT)+J).LE.0)THEN
                                CALL INPMSG(I+1,'Contains values <= 0.')
                                OK=.FALSE.
                                GOTO 210
                           ELSE
                                EGAS(J)=MVEC(MORG(ISLOT)+J)/PGAS
                           ENDIF
220                        CONTINUE
                           ESET=.TRUE.
                      ENDIF
                      GOTO 210
                 ENDIF
200              CONTINUE
                 CALL INPMSG(I+1,'Not a global variable.')
                 OK=.FALSE.
210              CONTINUE
                 INEXT=I+2
            ELSEIF(INPTYP(I+1).EQ.1.OR.INPTYP(I+1).EQ.2)THEN
                 NGAS=0
                 DO 230 J=I+1,NWORD
                 IF(INPTYP(J).NE.1.AND.INPTYP(J).NE.2)THEN
                      INEXT=J
                      GOTO 240
                 ELSEIF(NGAS+1.GT.MXLIST)THEN
                      CALL INPMSG(J,'Too many values, ignored.')
                      OK=.FALSE.
                      GOTO 230
                 ENDIF
                 CALL INPCHK(J,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(J,EFLDR,0.0)
                      IF(EFLDR.GT.0.0)THEN
                           NGAS=NGAS+1
                           EGAS(NGAS)=EFLDR/PGAS
                      ELSE
                           CALL INPMSG(J,'Not strictly positive.')
                           OK=.FALSE.
                      ENDIF
                 ELSE
                      CALL INPMSG(J,'Invalid field value.')
                      OK=.FALSE.
                 ENDIF
230              CONTINUE
                 INEXT=NWORD+1
240              CONTINUE
                 ESET=.TRUE.
            ELSE
                 CALL INPMSG(I,'Invalid field specification.')
                 OK=.FALSE.
                 INEXT=I+2
            ENDIF
*   Plot distribution functions.
       ELSEIF(INPCMP(I,'PL#OT-DIST#RIBUTION-#FUNCTIONS').NE.0)THEN
            LF0PLT=.TRUE.
       ELSEIF(INPCMP(I,'NOPL#OT-DIST#RIBUTION-#FUNCTIONS').NE.0)THEN
            LF0PLT=.FALSE.
*   Plot cross sections.
       ELSEIF(INPCMP(I,'PL#OT-CR#OSS-#SECTIONS').NE.0)THEN
            LCSPLT=.TRUE.
       ELSEIF(INPCMP(I,'NOPL#OT-CR#OSS-#SECTIONS').NE.0)THEN
            LCSPLT=.FALSE.
*   Keep cross section and distribution functions.
       ELSEIF(INPCMP(I,'KEEP').NE.0)THEN
            LGKEEP=.TRUE.
       ELSEIF(INPCMP(I,'NOKEEP').NE.0)THEN
            LGKEEP=.FALSE.
*   Keep cross section and distribution functions.
       ELSEIF(INPCMP(I,'PRINT').NE.0)THEN
            LBMCPR=.TRUE.
       ELSEIF(INPCMP(I,'NOPRINT').NE.0)THEN
            LBMCPR=.FALSE.
*   Kind of E/p scale.
       ELSEIF(INPCMP(I,'LIN#EAR-#E/P-#SCALE')+
     -      INPCMP(I,'LIN#EAR-#ELECTRIC-#SCALE')+
     -      INPCMP(I,'LIN#EAR-#ELECTRIC-#FIELD-#SCALE').NE.0)THEN
            EPLOG=.FALSE.
            ESET=.FALSE.
       ELSEIF(INPCMP(I,'LOG#ARITHMIC-#E/P-#SCALE')+
     -      INPCMP(I,'LOG#ARITHMIC-#ELECTRIC-#SCALE')+
     -      INPCMP(I,'LOG#ARITHMIC-#ELECTRIC-#FIELD-#SCALE').NE.0)THEN
            EPLOG=.TRUE.
            ESET=.FALSE.
*   Number of points.
       ELSEIF(INPCMP(I,'N-E#/P')+
     -      INPCMP(I,'N-E#LECTRIC-#FIELD').NE.0)THEN
            IF(INPTYP(I+1).NE.1.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.NE.0)OK=.FALSE.
                 CALL INPRDI(I+1,NGASR,20)
                 IF(NGASR.LE.0.OR.NGASR.GT.MXLIST)THEN
                      CALL INPMSG(I+1,'Value is out of range.        ')
                      OK=.FALSE.
                 ELSE
                      NGAS=NGASR
                 ENDIF
            ENDIF
            ESET=.FALSE.
            INEXT=I+2
*   Range of E-B angle.
       ELSEIF(MAGOK.AND.INPCMP(I,'ANG#LE-RAN#GE').NE.0)THEN
            CALL INPCHK(I+1,2,IFAIL1)
            CALL INPCHK(I+2,2,IFAIL2)
            IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.NWORD.GE.I+2)THEN
                 CALL INPRDR(I+1,BAMINR,180*BANGMN/PI)
                 CALL INPRDR(I+2,BAMAXR,180*BANGMX/PI)
                 IF(BAMINR.LT.0.OR.BAMINR.GT.90.0.OR.
     -                BAMAXR.LT.0.OR.BAMAXR.GT.90.0)THEN
                      IF(BAMINR.LT.0.OR.BAMINR.GT.90.0)
     -                     CALL INPMSG(I+1,'Out of range [0,90].')
                      IF(BAMAXR.LT.0.OR.BAMAXR.GT.90.0)
     -                     CALL INPMSG(I+2,'Out of range [0,90].')
                      OK=.FALSE.
                 ELSEIF(BAMINR.NE.BAMAXR)THEN
                      BANGMN=PI*MIN(BAMINR,BAMAXR)/180
                      BANGMX=PI*MAX(BAMINR,BAMAXR)/180
                 ELSE
                      CALL INPMSG(I+1,'A zero range is not permitted ')
                      CALL INPMSG(I+2,'for the E-B angular range.    ')
                      OK=.FALSE.
                 ENDIF
            ELSE
                 CALL INPMSG(I,'Missing or invalid arguments. ')
                 OK=.FALSE.
            ENDIF
            ASET=.FALSE.
            INEXT=I+3
       ELSEIF(INPCMP(I,'ANG#LE-RAN#GE').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            CALL INPMSG(I+2,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+3
       ELSEIF(MAGOK.AND.INPCMP(I,'ANG#LES').NE.0)THEN
            IF(INPTYP(I+1).EQ.0)THEN
                 CALL INPSTR(I+1,I+1,STRING,NCSTR)
                 DO 350 IGLB=1,NGLB
                 IF(STRING(1:NCSTR).EQ.GLBVAR(IGLB))THEN
                      ISLOT=MATSLT(NINT(GLBVAL(IGLB)))
                      IF(GLBMOD(IGLB).NE.5)THEN
                           CALL INPMSG(I+1,'Not of type Matrix.')
                           OK=.FALSE.
                      ELSEIF(ISLOT.LE.0)THEN
                           CALL INPMSG(I+1,'Matrix inaccessible.')
                           OK=.FALSE.
                      ELSEIF(MLEN(ISLOT).GT.MXBANG)THEN
                           CALL INPMSG(I+1,'More than MXBANG elements.')
                           OK=.FALSE.
                      ELSE
                           NBANG=MLEN(ISLOT)
                           DO 370 J=1,NBANG
                           IF(MVEC(MORG(ISLOT)+J).LT.0.OR.
     -                          MVEC(MORG(ISLOT)+J).GT.90)THEN
                                CALL INPMSG(I+1,'Out of range [0,90].')
                                OK=.FALSE.
                                GOTO 360
                           ELSE
                                BANG(J)=PI*MVEC(MORG(ISLOT)+J)/180
                           ENDIF
370                        CONTINUE
                           ASET=.TRUE.
                      ENDIF
                      GOTO 360
                 ENDIF
350              CONTINUE
                 CALL INPMSG(I+1,'Not a global variable.')
                 OK=.FALSE.
360              CONTINUE
                 INEXT=I+2
            ELSEIF(INPTYP(I+1).EQ.1.OR.INPTYP(I+1).EQ.2)THEN
                 NBANG=0
                 DO 380 J=I+1,NWORD
                 IF(INPTYP(J).NE.1.AND.INPTYP(J).NE.2)THEN
                      INEXT=J
                      GOTO 390
                 ELSEIF(NBANG+1.GT.MXBANG)THEN
                      CALL INPMSG(J,'Too many values, ignored.')
                      OK=.FALSE.
                      GOTO 380
                 ENDIF
                 CALL INPCHK(J,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(J,ANGR,0.0)
                      IF(ANGR.GE.0.0.AND.ANGR.LE.90.0)THEN
                           NBANG=NBANG+1
                           BANG(NBANG)=PI*ANGR/180
                      ELSE
                           CALL INPMSG(J,'Out of range [0,90].')
                           OK=.FALSE.
                      ENDIF
                 ELSE
                      CALL INPMSG(J,'Invalid angle value.')
                      OK=.FALSE.
                 ENDIF
380              CONTINUE
                 INEXT=NWORD+1
390              CONTINUE
                 ASET=.TRUE.
            ELSE
                 CALL INPMSG(I,'Invalid angle specification.')
                 OK=.FALSE.
                 INEXT=I+2
            ENDIF
       ELSEIF(INPCMP(I,'ANG#LE').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+2
*   Number of points.
       ELSEIF(MAGOK.AND.INPCMP(I,'N-ANG#LES').NE.0)THEN
            IF(INPTYP(I+1).NE.1.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.NE.0)OK=.FALSE.
                 CALL INPRDI(I+1,NBANGR,NBANG)
                 IF(NBANGR.LE.0.OR.NBANGR.GT.MXBANG)THEN
                      CALL INPMSG(I+1,'Value is out of range.        ')
                      OK=.FALSE.
                 ELSEIF(NBANGR.GT.1.AND..NOT.MAGOK)THEN
                      CALL INPMSG(I+1,'Not meaningful since B=0.     ')
                      OK=.FALSE.
                 ELSE
                      NBANG=NBANGR
                 ENDIF
            ENDIF
            ASET=.FALSE.
            INEXT=I+2
       ELSEIF(INPCMP(I,'N-ANG#LES').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+2
*   Range of B field.
       ELSEIF(MAGOK.AND.INPCMP(I,'B-RAN#GE')+
     -      INPCMP(I,'MAG#NETIC-F#IELD-RAN#GE')+
     -      INPCMP(I,'B-F#IELD-RAN#GE').NE.0)THEN
            CALL INPCHK(I+1,2,IFAIL1)
            CALL INPCHK(I+2,2,IFAIL2)
            IF(IFAIL1.EQ.0.AND.IFAIL2.EQ.0.AND.NWORD.GE.I+2)THEN
                 CALL INPRDR(I+1,BTMINR,BTABMN/100)
                 CALL INPRDR(I+2,BTMAXR,BTABMX/100)
                 IF(BTMINR.LT.0.OR.BTMAXR.LT.0)THEN
                      IF(BTMINR.LT.0)CALL INPMSG(I+1,'Is not > 0.')
                      IF(BTMAXR.LT.0)CALL INPMSG(I+1,'Is not > 0.')
                      OK=.FALSE.
                 ELSEIF(BTMINR.NE.BTMAXR)THEN
                      BTABMN=100*MIN(BTMINR,BTMAXR)
                      BTABMX=100*MAX(BTMINR,BTMAXR)
                 ELSE
                      CALL INPMSG(I+1,'A zero range is not permitted')
                      CALL INPMSG(I+2,'for the B field range.')
                      OK=.FALSE.
                 ENDIF
            ELSE
                 CALL INPMSG(I,'Missing or invalid arguments. ')
                 OK=.FALSE.
            ENDIF
            INEXT=I+3
       ELSEIF(INPCMP(I,'B-RAN#GE')+INPCMP(I,'B-FIELD-RAN#GE').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            CALL INPMSG(I+2,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+3
*   Listed B fields.
       ELSEIF(MAGOK.AND.INPCMP(I,'B-FIELD').NE.0)THEN
            IF(INPTYP(I+1).EQ.0)THEN
                 CALL INPSTR(I+1,I+1,STRING,NCSTR)
                 DO 300 IGLB=1,NGLB
                 IF(STRING(1:NCSTR).EQ.GLBVAR(IGLB))THEN
                      ISLOT=MATSLT(NINT(GLBVAL(IGLB)))
                      IF(GLBMOD(IGLB).NE.5)THEN
                           CALL INPMSG(I+1,'Not of type Matrix.')
                           OK=.FALSE.
                      ELSEIF(ISLOT.LE.0)THEN
                           CALL INPMSG(I+1,'Matrix inaccessible.')
                           OK=.FALSE.
                      ELSEIF(MLEN(ISLOT).GT.MXBTAB)THEN
                           CALL INPMSG(I+1,'More than MXBTAB elements.')
                           OK=.FALSE.
                      ELSE
                           NBTAB=MLEN(ISLOT)
                           DO 320 J=1,NBTAB
                           IF(MVEC(MORG(ISLOT)+J).LE.0)THEN
                                CALL INPMSG(I+1,'Contains values <= 0.')
                                OK=.FALSE.
                                GOTO 310
                           ELSE
                                BTAB(J)=100*MVEC(MORG(ISLOT)+J)
                           ENDIF
320                        CONTINUE
                           BSET=.TRUE.
                      ENDIF
                      GOTO 310
                 ENDIF
300              CONTINUE
                 CALL INPMSG(I+1,'Not a global variable.')
                 OK=.FALSE.
310              CONTINUE
                 INEXT=I+2
            ELSEIF(INPTYP(I+1).EQ.1.OR.INPTYP(I+1).EQ.2)THEN
                 NBTAB=0
                 DO 330 J=I+1,NWORD
                 IF(INPTYP(J).NE.1.AND.INPTYP(J).NE.2)THEN
                      INEXT=J
                      GOTO 340
                 ELSEIF(NBTAB+1.GT.MXBTAB)THEN
                      CALL INPMSG(J,'Too many values, ignored.')
                      OK=.FALSE.
                      GOTO 330
                 ENDIF
                 CALL INPCHK(J,2,IFAIL1)
                 IF(IFAIL1.EQ.0)THEN
                      CALL INPRDR(J,BFLDR,0.0)
                      IF(BFLDR.GE.0.0)THEN
                           NBTAB=NBTAB+1
                           BTAB(NBTAB)=100*BFLDR
                      ELSE
                           CALL INPMSG(J,'Negative values not allowed.')
                           OK=.FALSE.
                      ENDIF
                 ELSE
                      CALL INPMSG(J,'Invalid field value.')
                      OK=.FALSE.
                 ENDIF
330              CONTINUE
                 INEXT=NWORD+1
340              CONTINUE
                 BSET=.TRUE.
            ELSE
                 CALL INPMSG(I,'Invalid field specification.')
                 OK=.FALSE.
                 INEXT=I+2
            ENDIF
       ELSEIF(INPCMP(I,'B-FIELD').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+2
*   Number of points.
       ELSEIF(MAGOK.AND.INPCMP(I,'N-B-#FIELD')+
     -      INPCMP(I,'N-MAG#NETIC-#FIELD').NE.0)THEN
            IF(INPTYP(I+1).NE.1.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.NE.0)OK=.FALSE.
                 CALL INPRDI(I+1,NBTABR,NBTAB)
                 IF(NBTABR.LE.0.OR.NBTABR.GT.MXBTAB)THEN
                      CALL INPMSG(I+1,'Value is out of range.        ')
                      OK=.FALSE.
                 ELSEIF(NBTABR.GT.1.AND..NOT.MAGOK)THEN
                      CALL INPMSG(I+1,'Not meaningful since B=0.     ')
                      OK=.FALSE.
                 ELSE
                      NBTAB=NBTABR
                 ENDIF
            ENDIF
            INEXT=I+2
       ELSEIF(INPCMP(I,'N-B-#FIELD')+
     -      INPCMP(I,'N-MAG#NETIC-#FIELD').NE.0)THEN
            CALL INPMSG(I,'Not meaningful since B=0.')
            CALL INPMSG(I+1,'Has been ignored.')
            OK=.FALSE.
            INEXT=I+2
*   Threshold setting.
       ELSEIF(INPCMP(I,'SST-THRESHOLD').NE.0)THEN
            IF(INPTYP(I+1).EQ.1.OR.INPTYP(I+1).EQ.2)THEN
                 CALL INPCHK(I+1,2,IFAIL1)
                 CALL INPRDR(I+1,SSTHRR,SSTTHR)
                 IF(IFAIL1.EQ.0.AND.SSTHRR.LE.0)THEN
                      CALL INPMSG(I+1,'Should be > 0.')
                      OK=.FALSE.
                 ELSEIF(IFAIL1.EQ.0)THEN
                      SSTTHR=SSTHRR
                 ENDIF
                 INEXT=I+2
            ELSE
                 CALL INPMSG(I,'Takes a numeric argument.')
                 OK=.FALSE.
            ENDIF
*   Number of MC collisions.
       ELSEIF(INPCMP(I,'COLL#ISIONS').NE.0)THEN
            IF(INPTYP(I+1).NE.1.OR.I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPCHK(I+1,1,IFAIL1)
                 IF(IFAIL1.NE.0)OK=.FALSE.
                 CALL INPRDI(I+1,NMAXR,5)
                 IF(NMAXR.LE.0)THEN
                      CALL INPMSG(I+1,'Value is out of range.        ')
                      OK=.FALSE.
                 ELSE
                      NNMAX=NMAXR
                 ENDIF
            ENDIF
            INEXT=I+2
*   Mobility.
       ELSEIF(INPCMP(I,'ION-MOB#ILITY')+
     -      INPCMP(I,'MOB#ILITY').NE.0)THEN
            IF(I.GE.NWORD)THEN
                 CALL INPMSG(I,'Argument invalid or missing.  ')
                 OK=.FALSE.
            ELSE
                 CALL INPSTR(I+1,I+1,STRING,NCMOB)
            ENDIF
            INEXT=I+2
*   Other options are not known.
       ELSE
            CALL INPMSG(I,'Not a recognised keyword.     ')
            OK=.FALSE.
       ENDIF
20     CONTINUE
*** Dump error messages.
       CALL INPERR
*** Check whether we have to continue or not.
       IF(JFAIL.EQ.2.AND..NOT.OK)THEN
            PRINT *,' ###### GASBMC ERROR   : Magboltz not called'//
     -           ' because of the above errors.'
            IFAIL=1
            NGAS=0
            CALL PROEND
            RETURN
       ELSEIF(JFAIL.EQ.3.AND..NOT.OK)THEN
            PRINT *,' ###### GASBMC ERROR   : Program terminated'//
     -           ' because of the above errors.'
            IFAIL=1
            NGAS=0
            CALL PROEND
            CALL QUIT
            RETURN
       ENDIF
*** Progress printing.
       CALL PROFLD(1,'Initialisation',-1.0)
       CALL PROSTA(1,0.0)
*** Set the scale of the E/p points.
       IF(NGAS.GT.1.AND..NOT.ESET)THEN
            DO 30 I=1,NGAS
            IF(EPLOG)THEN
                 EGAS(I)=EPMIN*(EPMAX/EPMIN)**
     -                (REAL(I-1)/REAL(MAX(1,NGAS-1)))
            ELSE
                 EGAS(I)=EPMIN+(EPMAX-EPMIN)*
     -                (REAL(I-1)/REAL(MAX(1,NGAS-1)))
            ENDIF
30          CONTINUE
       ELSEIF(.NOT.ESET)THEN
            IF(EPLOG)THEN
                 EGAS(1)=SQRT(EPMIN*EPMAX)
            ELSE
                 EGAS(1)=(EPMIN+EPMAX)/2
            ENDIF
       ENDIF
*** Compute the E-B angles.
       IF(NBANG.GT.1.AND..NOT.ASET)THEN
            DO 40 J=1,NBANG
            BANG(J)=BANGMN+REAL(J-1)*(BANGMX-BANGMN)/REAL(NBANG-1)
40          CONTINUE
       ELSEIF(.NOT.ASET)THEN
            BANG(1)=(BANGMN+BANGMX)/2
       ENDIF
*** Compute the B field strengths.
       IF(NBTAB.GT.1.AND..NOT.BSET)THEN
            DO 50 J=1,NBTAB
            BTAB(J)=(BTABMN+REAL(J-1)*(BTABMX-BTABMN)/REAL(NBTAB-1))
50          CONTINUE
       ELSEIF(.NOT.BSET)THEN
            BTAB(1)=(BTABMN+BTABMX)/2
       ENDIF
*** Renormalise the fractions.
       FRTOT=0.0
       DO 60 I=1,MXGNAM
       IF(FRAMIX(I).LT.0)FRAMIX(I)=0.0
       FRTOT=FRTOT+FRAMIX(I)
60     CONTINUE
       IF(FRTOT.LE.0.0)THEN
            PRINT *,' !!!!!! GASBMC WARNING : Please have at least'//
     -           ' one gas in your mixture; nothing done.'
            NGAS=0
            IFAIL=1
            RETURN
       ELSE
            DO 70 I=1,MXGNAM
            FRAMIX(I)=100*FRAMIX(I)/FRTOT
            GASFRM(I)=FRAMIX(I)
70          CONTINUE
       ENDIF
*** Name of the mixture.
       STR=' '
       NC=0
*   Loop over the gases.
       DO 80 I=1,MXGNAM
*   Skip gases that are absent.
       IF(FRAMIX(I).LE.0)GOTO 80
*   Format the percentage.
       CALL OUTFMT(REAL(FRAMIX(I)),2,OUTSTR,NCOUT,'LEFT')
*   Hydrogen and Deuterium.
       IF(I.EQ.21)THEN
            STR(NC+1:NC+6+NCOUT)='H2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
       ELSEIF(I.EQ.22)THEN
            STR(NC+1:NC+6+NCOUT)='D2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Helium 3 and 4.
       ELSEIF(I.EQ.3)THEN
            STR(NC+1:NC+18+NCOUT)='isotropic He-4 '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+18+NCOUT
       ELSEIF(I.EQ.4)THEN
            STR(NC+1:NC+18+NCOUT)='isotropic He-3 '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+18+NCOUT
       ELSEIF(I.EQ.45)THEN
            STR(NC+1:NC+8+NCOUT)='He-4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
       ELSEIF(I.EQ.44)THEN
            STR(NC+1:NC+8+NCOUT)='He-3 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Neon.
       ELSEIF(I.EQ.5)THEN
            STR(NC+1:NC+16+NCOUT)='isotropic Ne '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.46)THEN
            STR(NC+1:NC+6+NCOUT)='Ne '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Argon.
       ELSEIF(I.EQ.2)THEN
            STR(NC+1:NC+16+NCOUT)='isotropic Ar '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.47)THEN
            STR(NC+1:NC+6+NCOUT)='Ar '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Krypton.
       ELSEIF(I.EQ.6)THEN
            STR(NC+1:NC+16+NCOUT)='isotropic Kr '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.48)THEN
            STR(NC+1:NC+6+NCOUT)='Kr '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Xenon.
       ELSEIF(I.EQ.7)THEN
            STR(NC+1:NC+16+NCOUT)='isotropic Xe '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.49)THEN
            STR(NC+1:NC+6+NCOUT)='Xe '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Methane.
       ELSEIF(I.EQ.8)THEN
            STR(NC+1:NC+7+NCOUT)='CH4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   Deuterium methane, silane and germane.
       ELSEIF(I.EQ.41)THEN
            STR(NC+1:NC+7+NCOUT)='CD4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ELSEIF(I.EQ.59)THEN
            STR(NC+1:NC+8+NCOUT)='GeH4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
       ELSEIF(I.EQ.60)THEN
            STR(NC+1:NC+8+NCOUT)='SiH4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Ethane.
       ELSEIF(I.EQ.9)THEN
            STR(NC+1:NC+8+NCOUT)='C2H6 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Ethene.
       ELSEIF(I.EQ.19)THEN
            STR(NC+1:NC+8+NCOUT)='C2H4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Acetylene.
       ELSEIF(I.EQ.20)THEN
            STR(NC+1:NC+8+NCOUT)='C2H2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Propane.
       ELSEIF(I.EQ.10)THEN
            STR(NC+1:NC+8+NCOUT)='C3H8 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Propene.
       ELSEIF(I.EQ.32)THEN
            STR(NC+1:NC+9+NCOUT)='C3H6 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   n-Butane and Isobutane.
       ELSEIF(I.EQ.11)THEN
            STR(NC+1:NC+10+NCOUT)='iC4H10 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
       ELSEIF(I.EQ.56)THEN
            STR(NC+1:NC+10+NCOUT)='nC4H10 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
*   neo-Pentane and n-Pentane.
       ELSEIF(I.EQ.13)THEN
            STR(NC+1:NC+12+NCOUT)='neoC5H12 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+12+NCOUT
       ELSEIF(I.EQ.57)THEN
            STR(NC+1:NC+10+NCOUT)='nC5H12 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
*   Nitrogen.
       ELSEIF(I.EQ.16)THEN
            STR(NC+1:NC+16+NCOUT)='isotropic N2 '//OUTSTR(1:NCOUT)//
     -           '%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.58)THEN
            STR(NC+1:NC+6+NCOUT)='N2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Water vapour.
       ELSEIF(I.EQ.14)THEN
            STR(NC+1:NC+7+NCOUT)='H2O '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   Carbon monoxide and dioxide.
       ELSEIF(I.EQ.23)THEN
            STR(NC+1:NC+6+NCOUT)='CO '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
       ELSEIF(I.EQ.12)THEN
            STR(NC+1:NC+7+NCOUT)='CO2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   Methylal.
       ELSEIF(I.EQ.24)THEN
            STR(NC+1:NC+10+NCOUT)='C3H8O2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
*   Sulphur compounds.
       ELSEIF(I.EQ.39)THEN
            STR(NC+1:NC+7+NCOUT)='CS2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ELSEIF(I.EQ.40)THEN
            STR(NC+1:NC+7+NCOUT)='COS '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ELSEIF(I.EQ.55)THEN
            STR(NC+1:NC+7+NCOUT)='H2S '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   SF6.
       ELSEIF(I.EQ.30)THEN
            STR(NC+1:NC+7+NCOUT)='SF6 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   NH3.
       ELSEIF(I.EQ.31)THEN
            STR(NC+1:NC+7+NCOUT)='NH3 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   Freons (Freon 14, 23, Zyron 116N5) and related compounds.
       ELSEIF(I.EQ.1)THEN
            STR(NC+1:NC+7+NCOUT)='CF4 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ELSEIF(I.EQ.29)THEN
            STR(NC+1:NC+8+NCOUT)='C2F6 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
       ELSEIF(I.EQ.42)THEN
            STR(NC+1:NC+7+NCOUT)='BF3 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ELSEIF(I.EQ.43)THEN
            STR(NC+1:NC+16+NCOUT)=
     -           'C2F4H2/C2HF5 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+16+NCOUT
       ELSEIF(I.EQ.50)THEN
            STR(NC+1:NC+8+NCOUT)='CHF3 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
       ELSEIF(I.EQ.51)THEN
            STR(NC+1:NC+9+NCOUT)='CF3Br '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+9+NCOUT
       ELSEIF(I.EQ.52)THEN
            STR(NC+1:NC+8+NCOUT)='C3F8 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+8+NCOUT
*   Cesium and Mercury.
       ELSEIF(I.EQ.37)THEN
            STR(NC+1:NC+6+NCOUT)='Cs '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Cesium and Mercury.
       ELSEIF(I.EQ.54)THEN
            STR(NC+1:NC+6+NCOUT)='Hg '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Oxygen and Ozone.
       ELSEIF(I.EQ.15)THEN
            STR(NC+1:NC+6+NCOUT)='O2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
       ELSEIF(I.EQ.53)THEN
            STR(NC+1:NC+6+NCOUT)='O3 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Fluorine.
       ELSEIF(I.EQ.38)THEN
            STR(NC+1:NC+6+NCOUT)='F2 '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
*   Nitrous and nitric oxide.
       ELSEIF(I.EQ.17)THEN
            STR(NC+1:NC+6+NCOUT)='NO '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+6+NCOUT
       ELSEIF(I.EQ.18)THEN
            STR(NC+1:NC+7+NCOUT)='N2O '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   DME.
       ELSEIF(I.EQ.25)THEN
            STR(NC+1:NC+7+NCOUT)='DME '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
*   Alcohols.
       ELSEIF(I.EQ.34)THEN
            STR(NC+1:NC+9+NCOUT)='CH3OH '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+9+NCOUT
       ELSEIF(I.EQ.35)THEN
            STR(NC+1:NC+10+NCOUT)='C2H5OH '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
       ELSEIF(I.EQ.36)THEN
            STR(NC+1:NC+10+NCOUT)='C3H7OH '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+10+NCOUT
*   Reid step, Reid ramp and Maxwell model.
       ELSEIF(I.EQ.26)THEN
            STR(NC+1:NC+13+NCOUT)='Reid-step '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+13+NCOUT
       ELSEIF(I.EQ.28)THEN
            STR(NC+1:NC+13+NCOUT)='Reid-ramp '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+13+NCOUT
       ELSEIF(I.EQ.27)THEN
            STR(NC+1:NC+11+NCOUT)='Maxwell '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+11+NCOUT
*   Obsolete components.
       ELSE
            STR(NC+1:NC+7+NCOUT)='??? '//OUTSTR(1:NCOUT)//'%, '
            NC=NC+7+NCOUT
       ENDIF
*   Next component.
80     CONTINUE
*   Gas temperature.
       CALL OUTFMT(TGAS,2,OUTSTR,NCOUT,'LEFT')
       STR(NC+1:NC+NCOUT+6)='T='//OUTSTR(1:NCOUT)//' K, '
       NC=NC+NCOUT+6
*   Gas pressure.
       CALL OUTFMT(PGAS/760.0,2,OUTSTR,NCOUT,'LEFT')
       STR(NC+1:NC+NCOUT+6)='p='//OUTSTR(1:NCOUT)//' atm'
       NC=NC+NCOUT+6
*   Copy to the gas identifier.
       IF(NC.GT.LEN(GASID))THEN
            GASID=STR(1:NC-2)//'...'
            NC=LEN(GASID)
       ELSE
            GASID=STR(1:NC)
       ENDIF
*** Debugging output.
       IF(LDEBUG)THEN
            WRITE(LUNOUT,'(''  ++++++ GASBMC DEBUG   : Mixing the'',
     -           '' following gases:''//
     -           ''       CF4        '',F6.3,''  Argon      '',F6.3/
     -           ''       Helium 4   '',F6.3,''  Helium 3   '',F6.3/
     -           ''       Neon       '',F6.3,''  Krypton    '',F6.3/
     -           ''       Xenon      '',F6.3,''  CH4        '',F6.3/
     -           ''       C2H6       '',F6.3,''  C3H8       '',F6.3/
     -           ''       iso-C4H10  '',F6.3,''  CO2        '',F6.3/
     -           ''       neo-C5H12  '',F6.3,''  H2O        '',F6.3/
     -           ''       Oxygen     '',F6.3,''  Nitrogen   '',F6.3/
     -           ''       NO         '',F6.3,''  N2O        '',F6.3/
     -           ''       C2H4       '',F6.3,''  C2H2       '',F6.3/
     -           ''       Hydrogen   '',F6.3,''  Deuterium  '',F6.3/
     -           ''       CO         '',F6.3,''  Methylal   '',F6.3/
     -           ''       DME        '',F6.3,''  Reid step  '',F6.3/
     -           ''       Maxwell    '',F6.3,''  Reid ramp  '',F6.3/
     -           ''       C2F6       '',F6.3,''  SF6        '',F6.3/
     -           ''       NH3        '',F6.3,''  C3H6       '',F6.3/
     -           ''       cyclo-C3H6 '',F6.3,''  CH3OH      '',F6.3/
     -           ''       C2H5OH     '',F6.3,''  C3H7OH     '',F6.3/
     -           ''       Cs         '',F6.3,''  F          '',F6.3/
     -           ''       CS2        '',F6.3,''  COS        '',F6.3/
     -           ''       CD4        '',F6.3,''  BF3        '',F6.3/
     -           ''       C2F4H2     '',F6.3,''  He 3 aniso '',F6.3/
     -           ''       He 4 aniso '',F6.3,''  Ne aniso   '',F6.3/
     -           ''       Ar aniso   '',F6.3,''  Kr aniso   '',F6.3/
     -           ''       Xe aniso   '',F6.3,''  CHF3       '',F6.3/
     -           ''       CF3Br      '',F6.3,''  C3F8       '',F6.3/
     -           ''       O3         '',F6.3,''  Mercury    '',F6.3/
     -           ''       H2S        '',F6.3,''  n-C4H10    '',F6.3/
     -           ''       n-C5H12    '',F6.3,''  N2         '',F6.3/
     -           ''       GeH4       '',F6.3,''  SiH4       '',F6.3)')
     -           (0.01*REAL(FRAMIX(I)),I=1,60)
            WRITE(LUNOUT,'(''  With the following parameters:''//
     -           ''       E/p range:                '',2F10.3,
     -           '' V/cm.Torr''/
     -           ''       Number of E/p points:     '',I6/
     -           ''       Magnetic field range:     '',2F10.3,'' T''/
     -           ''       Number of B field points: '',I6/
     -           ''       angle(E,B) range:         '',2F10.3,
     -           '' degrees''/
     -           ''       Number of (E,B) points:   '',I6/
     -           ''       Pressure of the gas:      '',F10.3,'' Torr''/
     -           ''       Temperature of the gas:   '',F10.3,'' K'')')
     -           EPMIN,EPMAX,NGAS,BTABMN/100,BTABMX/100,NBTAB,
     -           180*BANGMN/PI,180*BANGMX/PI,NBANG,PGAS,TGAS
            WRITE(LUNOUT,'(''  Accuracy settings: '')')
            WRITE(LUNOUT,'(''       SST threshold: '',F10.3,'' 1/cm'')')
     -           SSTTHR
            WRITE(LUNOUT,'(''       MC iterations: '',I5)') NNMAX
            WRITE(LUNOUT,'(''  Identifier: '',A)') GASID(1:NC)
       ENDIF
*** Compute the mobilities for the various points.
       IF(NCMOB.GT.0)THEN
            CALL PROFLD(1,'Adding mobility',-1.0)
            CALL PROSTA(1,0.0)
*   Call editor of specified as @.
            IF(INDEX(STRING(1:NCMOB),'@').NE.0)THEN
                 NRES=1
                 CALL ALGEDT(VARLIS,1,IENTRY,USE,NRES)
                 IFAIL1=0
*   Usual function translation if not.
            ELSE
                 CALL ALGPRE(STRING,NCMOB,VARLIS,1,NRES,USE,IENTRY,
     -                IFAIL1)
            ENDIF
*   Check return code of translation.
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! GASBMC WARNING : Ion mobility'//
     -                ' function rejected; no ion mobility in table.'
                 CALL ALGCLR(IENTRY)
                 NCMOB=0
            ENDIF
*   Check number of results returned by the function.
            IF(NRES.NE.1)THEN
                 PRINT *,' !!!!!! GASBMC WARNING : Number of'//
     -                ' results returned by the mobility function'//
     -                ' is not 1; rejected.'
                 CALL ALGCLR(IENTRY)
                 NCMOB=0
            ENDIF
*   Evaluate.
            DO 90 I=1,NGAS
            VAR(1)=EGAS(I)
            MODVAR(1)=2
            CALL ALGEXE(IENTRY,VAR,MODVAR,1,RES,MODRES,1,IFAIL1)
            MGAS(I)=RES(1)
            DO 100 J=1,NBANG
            DO 110 K=1,NBTAB
            MGAS2(I,J,K)=RES(1)
110         CONTINUE
100         CONTINUE
90          CONTINUE
*   Clear the mobility entry point - no longer needed.
            CALL ALGCLR(IENTRY)
*   Dump algebra error messages.
            CALL ALGERR
       ENDIF
*** Reset frequencies
       NEXGAS=0
       NIOGAS=0
*** Fill the gas tables, first with a magnetic field.
       IF(MAGOK)THEN
*   Header.
            TAB2D = .TRUE.
            IF(LDEBUG)PRINT *,' ++++++ GASBMC DEBUG   : Preparing a'//
     -           ' 3D table.'
*   Loop over the B fields.
            CALL PRORED(3)
            CALL PROFLD(1,'B-field',REAL(NBTAB))
            DO 120 K=1,NBTAB
            CALL PROSTA(1,REAL(K))
*   Loop over the angles.
            CALL PROFLD(2,'angle(E,B)',REAL(NBANG))
            DO 130 J=1,NBANG
            CALL PROSTA(2,REAL(J))
**  Loop over the electric field.
            CALL PROFLD(3,'E-field',REAL(NGAS))
            DO 140 I=1,NGAS
*   Progress printing.
            CALL PROSTA(3,REAL(I))
C      print *,' Starting for:'
C      print *,' E     = ',EGAS(I)*PGAS
C      print *,' B     = ',BTAB(K)/100,' T'
C      print *,' angle = ',180*BANG(J)/PI,' degrees'
*   Run Magboltz.
            CALL GASB7(DBLE(EGAS(I)*PGAS),DBLE(BTAB(K)/10),
     -           DBLE(180*BANG(J)/PI),DBLE(TGAS),DBLE(PGAS),
     -           DBLE(SSTTHR),NNMAX,IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! GASBMC WARNING : Running'//
     -                ' Magboltz 7 for E/p=',EGAS(I),
     -                ' angle=',180*BANG(J)/PI,' failed; no gas tables.'
                 IFAIL=1
                 NGAS=0
                 RETURN
            ENDIF
*   Plot distribution function if requested.
            IF(LF0PLT)CALL F0PLT7(GASID)
*   Plot cross sections if requested.
            IF(LCSPLT)CALL GASPCS(GASID)
*   Keep cross sections and distribution function if requested.
            IF(LGKEEP)CALL GASSAV
*   Output the transport results.
            CALL OUTB7(VBOL,XBOL,YBOL,WBOL,DBOL,OBOL,ABOL,BBOL,SBOL)
            VGAS2(I,J,K)=VBOL
            XGAS2(I,J,K)=XBOL
            YGAS2(I,J,K)=YBOL
            WGAS2(I,J,K)=WBOL
            DGAS2(I,J,K)=DBOL
            OGAS2(I,J,K)=OBOL
            AGAS2(I,J,K)=ABOL
            AORIG2(I,J,K)=ABOL
            BGAS2(I,J,K)=BBOL
            DO 150 L=1,6
            SGAS2(I,J,K,L)=SBOL(L)
150         CONTINUE
*   Output the frequencies
            CALL OUTEI7(EXBOL,IOBOL)
            DO 151 L=1,NEXGAS
            EXGAS2(I,J,K,L)=EXBOL(L)
151         CONTINUE
            DO 152 L=1,NIOGAS
            IOGAS2(I,J,K,L)=IOBOL(L)
152         CONTINUE
*   Next E field.
140         CONTINUE
*   Next angle.
130         CONTINUE
*   Next B field
120         CONTINUE
*   Transfer the data from the VGAS2 etc to VGAS.
            IF(NBANG.EQ.1.AND.NBTAB.EQ.1)THEN
                 PRINT *,' ------ GASBMC MESSAGE : The table is'//
     -                ' 1-dimensional even though B/=0.'
                 TAB2D=.FALSE.
                 DO 160 I=1,NGAS
                 VGAS(I)=VGAS2(I,1,1)
                 XGAS(I)=XGAS2(I,1,1)
                 YGAS(I)=YGAS2(I,1,1)
                 DGAS(I)=DGAS2(I,1,1)
                 AGAS(I)=AGAS2(I,1,1)
                 AORIG(I)=AGAS2(I,1,1)
                 BGAS(I)=BGAS2(I,1,1)
                 OGAS(I)=OGAS2(I,1,1)
                 WGAS(I)=WGAS2(I,1,1)
                 DO 170 L=1,6
                 SGAS(I,L)=SGAS2(I,1,1,L)
170              CONTINUE
160              CONTINUE
            ENDIF
**  If there is no magnetic field.
       ELSE
            CALL PRORED(1)
            CALL PROFLD(1,'Electric field',REAL(NGAS))
*   First fill the 2 dimensional arrays as for the B field case.
            NBANG=1
            IF(LDEBUG)PRINT *,' ++++++ GASBMC DEBUG   : Preparing a'//
     -           ' 1D table.'
*   Loop over the electric field.
            CALL PROFLD(1,'Electric field',REAL(NGAS))
            DO 180 I=1,NGAS
*   Progress printing.
            CALL PROSTA(1,REAL(I))
*   Run Magboltz.
C      print *,' Starting for:'
C      print *,' E     = ',EGAS(I)*PGAS
            CALL GASB7(DBLE(EGAS(I)*PGAS),0.0D0,0.0D0,DBLE(TGAS),
     -           DBLE(PGAS),DBLE(SSTTHR),NNMAX,IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! GASBMC WARNING : Running'//
     -                ' Magboltz 7 for E/p=',EGAS(I),' failed;'//
     -                ' no gas tables.'
                 IFAIL=1
                 NGAS=0
                 RETURN
            ENDIF
*   Plot distribution function if requested.
            IF(LF0PLT)CALL F0PLT7(GASID)
*   Plot cross sections if requested.
            IF(LCSPLT)CALL GASPCS(GASID)
*   Keep cross sections and distribution function if requested.
            IF(LGKEEP)CALL GASSAV
*   Output the results.
            CALL OUTB7(VBOL,XBOL,YBOL,WBOL,DBOL,OBOL,ABOL,BBOL,SBOL)
            VGAS(I)=VBOL
            XGAS(I)=XBOL
            YGAS(I)=YBOL
            WGAS(I)=WBOL
            DGAS(I)=DBOL
            OGAS(I)=OBOL
            AGAS(I)=ABOL
            AORIG(I)=ABOL
            BGAS(I)=BBOL
            DO 190 L=1,6
            SGAS(I,L)=SBOL(L)
190         CONTINUE
*   Output the frequencies
            CALL OUTEI7(EXBOL,IOBOL)
            DO 191 L=1,MXEXG
            EXGAS(I,L)=EXBOL(L)
191         CONTINUE
            DO 192 L=1,MXIOG
            IOGAS(I,L)=IOBOL(L)
192         CONTINUE
*   Next E field.
180         CONTINUE
*   Declare the table to be 1-dimensional.
            TAB2D=.FALSE.
       ENDIF
*   End of progress printing.
       CALL PROEND
*   Check error flags.
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! GASBMC WARNING : Computing the transport'//
     -           ' properties failed ; no gas tables.'
            RETURN
       ENDIF
*** Set the GASOK flags.
       GASOK(1)=.TRUE.
       IF(NCMOB.GT.0)THEN
            GASOK(2)=.TRUE.
       ELSE
            GASOK(2)=.FALSE.
       ENDIF
       GASOK(3)=.TRUE.
       GASOK(4)=.TRUE.
       GASOK(6)=.TRUE.
       IF(MAGOK)THEN
            GASOK(7)=.TRUE.
            GASOK(9)=.TRUE.
            GASOK(10)=.TRUE.
       ELSE
            GASOK(7)=.FALSE.
            GASOK(9)=.FALSE.
            GASOK(10)=.FALSE.
       ENDIF
       GASOK(8)=.TRUE.
       GASOK(11)=.TRUE.
       GASOK(15)=.TRUE.
       GASOK(16)=.TRUE.
*** Interpolation flags.
       IVMETH=2
       IMMETH=2
       IDMETH=2
       IOMETH=2
       IAMETH=2
       IBMETH=2
       IWMETH=2
       IEMETH=2
       IZMETH=2
*** Extrapolation flags.
       IF(NGAS.LE.1)THEN
            IVEXTR=0
            IMEXTR=0
            IDEXTR=0
            IAEXTR=0
            IBEXTR=0
            IWEXTR=0
            IOEXTR=0
            IEEXTR=0
            IZEXTR=0
            JVEXTR=0
            JMEXTR=0
            JDEXTR=0
            JAEXTR=0
            JBEXTR=0
            JWEXTR=0
            JOEXTR=0
            JEEXTR=0
            JZEXTR=0
       ENDIF
*** Record CPU time used.
       CALL TIMLOG('Magboltz gas mixing:                    ')
       END
CDECK  ID>, GASIDE.
       SUBROUTINE GASIDE(IEXC,ID,IFAIL)
*-----------------------------------------------------------------------
*   GASIDE - Returns the excitation number for a string.
*   (Last changed on  2/ 8/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IEXC,IFAIL,I,J,K
       CHARACTER*45 ID
*** See whether we already have this one
       DO 10 I=1,NEXGAS
       IF(DSCEXG(I).EQ.ID)THEN
            IEXC=I
            IFAIL=0
            RETURN
       ENDIF
10     CONTINUE
*** Otherwise try and add
       IF(NEXGAS.LT.MXEXG)THEN
            NEXGAS=NEXGAS+1
            DSCEXG(NEXGAS)=ID
            PENPRB(NEXGAS)=0
            PENRMS(NEXGAS)=0
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASIDE DEBUG   :'',
     -           '' Added excitation '',A,''.'')') ID
            IEXC=NEXGAS
            DO 140 K=1,MXBTAB
            DO 130 J=1,MXBANG
            DO 120 I=1,MXLIST
            EXGAS2(I,J,K,IEXC)=0
120         CONTINUE
130         CONTINUE
140         CONTINUE
            DO 150 I=1,MXLIST
            EXGAS(I,IEXC)=0
150         CONTINUE
            IFAIL=0
       ELSE
            PRINT *,' !!!!!! GASIDE WARNING : No room to store an'//
     -           ' excitation level; increase MXEXG.'
            IEXC=0
            IFAIL=1
       ENDIF
       END
CDECK  ID>, GASIDI.
       SUBROUTINE GASIDI(IION,ID,IFAIL)
*-----------------------------------------------------------------------
*   GASIDI - Returns the ionisation number for a string.
*   (Last changed on 25/ 6/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IION,IFAIL,I,J,K
       CHARACTER*45 ID
*** See whether we already have this one
       DO 10 I=1,NIOGAS
       IF(DSCIOG(I).EQ.ID)THEN
            IION=I
            IFAIL=0
            RETURN
       ENDIF
10     CONTINUE
*** Otherwise try and add
       IF(NIOGAS.LT.MXIOG)THEN
            NIOGAS=NIOGAS+1
            DSCIOG(NIOGAS)=ID
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASIDI DEBUG   :'',
     -           '' Added ionisation '',A,''.'')') ID
            IION=NIOGAS
            DO 140 K=1,MXBTAB
            DO 130 J=1,MXBANG
            DO 120 I=1,MXLIST
            IOGAS2(I,J,K,IION)=0
120         CONTINUE
130         CONTINUE
140         CONTINUE
            DO 150 I=1,MXLIST
            IOGAS(I,IION)=0
150         CONTINUE
            IFAIL=0
       ELSE
            PRINT *,' !!!!!! GASIDI WARNING : No room to store an'//
     -           ' ionisation level; increase MXIOG.'
            IION=0
            IFAIL=1
       ENDIF
       END
CDECK  ID>, GASIDO.
       SUBROUTINE GASIDO(IEXC,ID,ITYPE,DE,IFAIL)
*-----------------------------------------------------------------------
*   GASIDO - Returns the cross section number for a string composed of
*            the gas name and the Magboltz description.
*   (Last changed on 29/ 6/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       INTEGER IEXC,IFAIL,ITYPE,I
       REAL DE
       CHARACTER*45 ID
*** Look to see whether we already have this one
       DO 10 I=1,NCSGAS
       IF(DSCCSG(I).EQ.ID)THEN
            IEXC=I
            IFAIL=0
            RETURN
       ENDIF
10     CONTINUE
*** If not, see whether we've room to add it.
       IF(NCSGAS.LT.MXCSG)THEN
            NCSGAS=NCSGAS+1
            DSCCSG(NCSGAS)=ID
            ICSTYP(NCSGAS)=ITYPE
            ELOSCS(NCSGAS)=DE
            IEXC=NCSGAS
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASIDO DEBUG   :'',
     -           '' Cross section "'',A,''" of type '',I1,'' is given'',
     -           '' reference '',I3,''.'')') ID,ITYPE,IEXC
            IFAIL=0
       ELSE
            PRINT *,' !!!!!! GASIDO WARNING : Ran out of storage'//
     -           ' for cross section terms.'
            IEXC=0
            IFAIL=1
       ENDIF
       END
CDECK  ID>, GASEXU.
       SUBROUTINE GASEXU(ITYPE,IGAS,ISTATE,
     -      XPOS,YPOS,ZPOS,ENERGY,TIME,
     -      ADDNEW,XNEW,YNEW,ZNEW,DELAY,ENEW)
*-----------------------------------------------------------------------
*   GASEXU - User procedure to deal with excitations.
*   (Last changed on  2/ 8/10.)
*-----------------------------------------------------------------------
       implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
*   Changed name of common from /NAMES/ to /MBGNAM/ for Mac OS X
       CHARACTER*15 NAMEG
       COMMON /MBGNAM/ NAMEG(mxngas)
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       DOUBLE PRECISION CLSDIS,CLSAVE
       REAL EGAS,VGAS,XGAS,YGAS,DGAS,AGAS,BGAS,HGAS,MGAS,WGAS,OGAS,SGAS,
     -      EXGAS,IOGAS,
     -      CVGAS,CXGAS,CYGAS,CDGAS,CAGAS,CBGAS,CHGAS,CMGAS,CWGAS,COGAS,
     -      CSGAS,CEXGAS,CIOGAS,
     -      VGAS2,XGAS2,YGAS2,DGAS2,AGAS2,BGAS2,HGAS2,MGAS2,WGAS2,OGAS2,
     -      SGAS2,EXGAS2,IOGAS2,
     -      AORIG,AORIG2,PENPRB,PENRMS,PENDT,ENIOG,ENEXG,
     -      BANG,BTAB,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1,SEXTR2,SEXTR3,SEXTR4,
     -      EEXTR1,EEXTR2,EEXTR3,EEXTR4,
     -      ZEXTR1,ZEXTR2,ZEXTR3,ZEXTR4,
     -      GASRNG,
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,GASFRM,ELOSCS
       LOGICAL GASOK,TAB2D,GASOPT,HEEDOK,SRIMOK,TRIMOK,GASSET
       INTEGER NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP
       CHARACTER*80 GASID
       CHARACTER*(MXCHAR) FCNTAB,FCNCLS
       CHARACTER*10 CLSTYP
       CHARACTER*45 DSCEXG(MXEXG),DSCIOG(MXIOG),DSCCSG(MXCSG)
       COMMON /GASDAT/ CLSDIS(MXPAIR),CLSAVE,
     -      EGAS(MXLIST),
     -      VGAS(MXLIST),XGAS(MXLIST),YGAS(MXLIST),WGAS(MXLIST),
     -      DGAS(MXLIST),OGAS(MXLIST),AGAS(MXLIST),BGAS(MXLIST),
     -      HGAS(MXLIST),MGAS(MXLIST),SGAS(MXLIST,6),
     -      EXGAS(MXLIST,MXEXG),IOGAS(MXLIST,MXIOG),
     -      CVGAS(MXLIST),CXGAS(MXLIST),CYGAS(MXLIST),CWGAS(MXLIST),
     -      CDGAS(MXLIST),COGAS(MXLIST),CAGAS(MXLIST),CBGAS(MXLIST),
     -      CHGAS(MXLIST),CMGAS(MXLIST),CSGAS(MXLIST,6),
     -      CEXGAS(MXLIST,MXEXG),CIOGAS(MXLIST,MXIOG),
     -      VGAS2(MXLIST,MXBANG,MXBTAB),WGAS2(MXLIST,MXBANG,MXBTAB),
     -      XGAS2(MXLIST,MXBANG,MXBTAB),YGAS2(MXLIST,MXBANG,MXBTAB),
     -      AGAS2(MXLIST,MXBANG,MXBTAB),BGAS2(MXLIST,MXBANG,MXBTAB),
     -      DGAS2(MXLIST,MXBANG,MXBTAB),OGAS2(MXLIST,MXBANG,MXBTAB),
     -      HGAS2(MXLIST,MXBANG,MXBTAB),MGAS2(MXLIST,MXBANG,MXBTAB),
     -      SGAS2(MXLIST,MXBANG,MXBTAB,6),
     -      EXGAS2(MXLIST,MXBANG,MXBTAB,MXEXG),
     -      IOGAS2(MXLIST,MXBANG,MXBTAB,MXIOG),
     -      AORIG(MXLIST),AORIG2(MXLIST,MXBANG,MXBTAB),
     -      PENPRB(MXEXG),PENRMS(MXEXG),PENDT(MXEXG),
     -      ENIOG(MXIOG),ENEXG(MXEXG),
     -      BANG(MXBANG),BTAB(MXBTAB),
     -      GASRNG(20,2),GASFRM(MXNBMC),ELOSCS(MXCSG),
     -      Z,A,RHO,CMEAN,EMPROB,EPAIR,PGAS,TGAS,GASDEN,
     -      DTION,DLION,
     -      VEXTR1,VEXTR2,VEXTR3,VEXTR4,
     -      XEXTR1,XEXTR2,XEXTR3,XEXTR4,
     -      YEXTR1,YEXTR2,YEXTR3,YEXTR4,
     -      DEXTR1,DEXTR2,DEXTR3,DEXTR4,
     -      AEXTR1,AEXTR2,AEXTR3,AEXTR4,
     -      BEXTR1,BEXTR2,BEXTR3,BEXTR4,
     -      HEXTR1,HEXTR2,HEXTR3,HEXTR4,
     -      MEXTR1,MEXTR2,MEXTR3,MEXTR4,
     -      WEXTR1,WEXTR2,WEXTR3,WEXTR4,
     -      OEXTR1,OEXTR2,OEXTR3,OEXTR4,
     -      SEXTR1(6),SEXTR2(6),SEXTR3(6),SEXTR4(6),
     -      EEXTR1(MXEXG),EEXTR2(MXEXG),EEXTR3(MXEXG),EEXTR4(MXEXG),
     -      ZEXTR1(MXIOG),ZEXTR2(MXIOG),ZEXTR3(MXIOG),ZEXTR4(MXIOG),
     -      IVMETH,IXMETH,IYMETH,IDMETH,IAMETH,IBMETH,IHMETH,IMMETH,
     -      IWMETH,IOMETH,ISMETH,IEMETH,IZMETH,
     -      IVEXTR,IXEXTR,IYEXTR,IDEXTR,IAEXTR,IBEXTR,IHEXTR,IMEXTR,
     -      IWEXTR,IOEXTR,ISEXTR,IEEXTR,IZEXTR,
     -      JVEXTR,JXEXTR,JYEXTR,JDEXTR,JAEXTR,JBEXTR,JHEXTR,JMEXTR,
     -      JWEXTR,JOEXTR,JSEXTR,JEEXTR,JZEXTR,
     -      NGAS,NCLS,NBANG,NBTAB,NFTAB,NFCLS,
     -      IATHR,IBTHR,IHTHR,
     -      NEXGAS,NIOGAS,NCSGAS,ICSTYP(MXCSG),
     -      GASOK(20),GASOPT(20,4),
     -      TAB2D,HEEDOK,SRIMOK,TRIMOK,GASSET
       COMMON /GASCHR/ FCNTAB,FCNCLS,CLSTYP,GASID,DSCEXG,DSCIOG,DSCCSG
       LOGICAL ADDNEW
       INTEGER ITYPE,IGAS,ISTATE,IREF,IFAIL1,I,IION
       REAL XPOS,YPOS,ZPOS,ENERGY,TIME,ELOSS,XNEW,YNEW,ZNEW,DELAY,
     -      RNDUNI,RNDNOR,RNDEXP,ENEW
       CHARACTER*45 NEWID
       EXTERNAL RNDUNI,RNDNOR,RNDEXP
*** Initial value.
       ADDNEW=.FALSE.
*** Skip inelastic collisions (vibrations, rotations, polyads)
       IF(DSCRPT(ISTATE)(1:4).NE.' EXC')RETURN
*** Identify the cross section.
C       print *,' ### Excitation: ',NAMEG(IGAS)//DSCRPT(ISTATE)
       CALL GASTTR(NAMEG(IGAS)//DSCRPT(ISTATE),NEWID,ELOSS)
       CALL GASIDE(IREF,NEWID,IFAIL1)
C       print *,'     Short name: ',NEWID,', Reference: ',IREF
       IF(IFAIL1.NE.0.OR.IREF.LE.0.OR.IREF.GT.NEXGAS)THEN
            PRINT *,' !!!!!! GASEXU WARNING : Lookup for excitation '//
     -           NAMEG(IGAS)//DSCRPT(ISTATE)//' failed; not processed.'
            RETURN
       ENDIF
*** Decide whether to add electrons.
       IF(PENPRB(IREF).GE.RNDUNI(1.0))THEN
C       print *,'     Penning rate: ',penprb(iref)
            ADDNEW=.TRUE.
            XNEW=RNDNOR(XPOS,PENRMS(IREF))
            YNEW=RNDNOR(YPOS,PENRMS(IREF))
            ZNEW=RNDNOR(ZPOS,PENRMS(IREF))
            DELAY=RNDEXP(PENDT(IREF))
*   Identify a suitable component to ionise
            IION=-1.0
            DO 10 I=1,NIOGAS
            IF(ENIOG(I).LT.ELOSS)THEN
                 IF(IION.GT.0)THEN
                      PRINT *,' !!!!!! GASEXU WARNING : More than one'//
     -                     ' ionisation candidate; picking '//
     -                     DSCIOG(IION)//' and ignoring '//DSCIOG(I)
                 ELSE
                      ENEW=ELOSS-ENIOG(I)
                      IION=I
C                      print *,'     Candidate recipient: ',DSCIOG(I),
C     -                     ' Ionisation energy: ',eniog(i),
C     -                     ' Excitation energy: ',eloss
                 ENDIF
            ENDIF
10          CONTINUE
       ENDIF
       END
CDECK  ID>, GASLEX.
      SUBROUTINE GASLEX(IFAIL)
*-----------------------------------------------------------------------
*   GASLEX - Extracts all excitations and ionisations.
*   (Last changed on 29/ 6/09.)
*-----------------------------------------------------------------------
       implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       DOUBLE PRECISION PIR2,ECHARG,EMASS,AMU,BOLTZ,BOLTZJ,
     -      AWB,ALOSCH,ABZERO,ATMOS
       PARAMETER(PIR2=8.79735534D-17)
       PARAMETER(ECHARG=1.602176462D-19)
       PARAMETER(EMASS=9.10938188D-31)
       PARAMETER(AMU=1.66053873D-27)
       PARAMETER(BOLTZ=8.617342D-5)
       PARAMETER(BOLTZJ=1.3806503D-23)
       PARAMETER(AWB=1.758820174D10)
       PARAMETER(ALOSCH=2.6867775D19)
       PARAMETER(ABZERO=273.15D0)
       PARAMETER(ATMOS=760.0D0)
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
*   Changed name of common from /NAMES/ to /MBGNAM/ for Mac OS X
       CHARACTER*15 NAMEG
       COMMON /MBGNAM/ NAMEG(mxngas)
*   Grouped AN1 ... AN6 in ANn
       DOUBLE PRECISION ANn,AN,FRAC
       COMMON /RATIO/ ANn(mxngas),AN,FRAC(mxngas)
       INTEGER NGASN
       COMMON /GASN/ NGASN(mxngas)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       CHARACTER*15 NAME
       CHARACTER*30 SCRPT(226)
       CHARACTER*80 GASID
       DOUBLE PRECISION Q(6,2048),QIN(220,2048),E(6),EI(220),
     -      PEQEL(6,2048),PEQIN(220,2048),VIRIAL,EB
       REAL PGAS,TGAS,GASFRM(MXGNAM),GASSUM
       INTEGER KIN(220),KEL(6),NIN,I,J,IFAIL,IREF,IFAIL1,IFAIL2,
     -      IFAIL3,IFAIL4,IFAIL5,IFAIL6
*** Retrieve pressure and temperature.
       CALL GASINF(PGAS,TGAS,GASID,GASFRM)
*** Loop over all gases
       GASSUM=0
       DO 10 I=1,MXGNAM
       IF(GASFRM(I).LE.0)GOTO 10
       GASSUM=GASSUM+GASFRM(I)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   : Gas '',I3,
     -      '' has fraction '',F10.3)') I,GASFRM(I)
*   Pressure and temperature.
       TEMPC=20.0
       TORR=760.0
*   Set a final energy such that all excitations are present.
       EFINAL=1000.0
*   Density correction factors.
       AKT=(ABZERO+TEMPC)*BOLTZ
*   Store the gas mixing data.
       NGAS=1
       FRAC(1)=100.0
       NGASN(1)=I
*   Retrieve the gas data (1 is not a specific cross section).
       CALL GETGAS(I,Q,QIN,NIN,E,EI,NAME,VIRIAL,EB,PEQEL,PEQIN,
     -     KEL,KIN,SCRPT)
*   The elastic term is entry 2.
       CALL GASIDO(IREF,NAME//SCRPT(2),1,REAL(E(2)),IFAIL1)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -      '' Elastic:       '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -      SCRPT(2),E(2)
*   The ionisation is at entry 3.
       CALL GASIDO(IREF,NAME//SCRPT(3),2,REAL(E(3)),IFAIL2)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -      '' Ionisation:    '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -      SCRPT(3),E(3)
*   The attachment is at entry 4.
       CALL GASIDO(IREF,NAME//SCRPT(4),3,REAL(E(4)),IFAIL3)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -      '' Attachment:    '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -      SCRPT(4),E(4)
*   The inelastic, super-elastic + excitations are in 6+I, I=1,NIN.
       DO 20 J=1,NIN
       IF(SCRPT(6+J)(1:4).NE.' EXC'.AND.EI(J).GT.0)THEN
            CALL GASIDO(IREF,NAME//SCRPT(6+J),4,REAL(EI(J)),IFAIL4)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -           '' Inelastic:     '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -           SCRPT(6+J),EI(J)
       ELSEIF(SCRPT(6+J)(1:4).NE.' EXC')THEN
            CALL GASIDO(IREF,NAME//SCRPT(6+J),5,REAL(EI(J)),IFAIL5)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -           '' Super-elastic: '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -           SCRPT(6+J),EI(J)
       ELSE
            CALL GASIDO(IREF,NAME//SCRPT(6+J),6,REAL(EI(J)),IFAIL6)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ GASLEX DEBUG   :'',
     -           '' Excitation:    '',A,'' (Eloss = '',E12.5,'' eV)'')')
     -           SCRPT(6+J),EI(J)
       ENDIF
20     CONTINUE
*   Check error flags.
       IF(IFAIL1.NE.0.OR.IFAIL2.NE.0.OR.IFAIL3.NE.0.OR.IFAIL4.NE.0.OR.
     -      IFAIL5.NE.0.OR.IFAIL6.NE.0)THEN
            PRINT *,' !!!!!! GASLEX WARNING : Error storing a cross'//
     -           ' section term; abandoning.'
            IFAIL=1
            RETURN
       ENDIF
*   Next gas
10     CONTINUE
*** Check that there is a gas.
       IF(GASSUM.LE.0)THEN
            PRINT *,' !!!!!! GASLEX WARNING : Gas composition does'//
     -           ' not contain a single element; table empty.'
            IFAIL=1
       ELSE
            IFAIL=0
       ENDIF
       END
CDECK  ID>, OUTEI7.
       SUBROUTINE OUTEI7(EXBOL,IOBOL)
*-----------------------------------------------------------------------
*   OUTEI7 - Extracts the ionisation/excitation rates from Magboltz.
*   (Last changed on 25/ 8/09.)
*-----------------------------------------------------------------------
       implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       DOUBLE PRECISION TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX,RSTART,
     -      EMAG
       INTEGER NMAX
       COMMON/SETP/TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX(8),RSTART,
     -      EMAG,NMAX
       DOUBLE PRECISION ZTOT,TTOT,ZTOTS,TTOTS
       COMMON/TTRM/ZTOT,TTOT,ZTOTS,TTOTS
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
*   Adjusted size of ICOLL
       DOUBLE PRECISION TIME,SPEC,TMAX1,AVE,DEN,XID,X,Y,Z,ST
       INTEGER ICOLL,NNULL,ICOLN
       COMMON/OUTPT/TIME(300),ICOLL(5*mxngas),SPEC(2048),TMAX1,
     -      AVE,DEN,XID,X,Y,Z,ST,NNULL,ICOLN(512)
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
*   Changed name of common from /NAMES/ to /MBGNAM/ for Mac OS X
       CHARACTER*15 NAMEG
       COMMON /MBGNAM/ NAMEG(mxngas)
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       REAL EXBOL(MXEXG),IOBOL(MXIOG),FREQ,FRELV,ERRFRE
       INTEGER NREAL,I,J,IEXC,IION,IFAIL
*** Initialise the vectors
       DO 30 I=1,MXEXG
       EXBOL(I)=0
30     CONTINUE
       DO 40 I=1,MXIOG
       IOBOL(I)=0
40     CONTINUE
*** Number of collisions and frequency scaling factor.
       IF(TTOTS.EQ.0.0D0) THEN
            NREAL=NMAX
            TTOTS=ST
       ELSE
            NREAL=INT(XID)
       ENDIF
       FREQ=REAL(NREAL)/TTOTS
*** Loop over the gases and states, selecting
       DO 10 I=1,NGAS
       DO 20 J=1,IPLAST
       IF(IARRY(J).LE.5*I .AND. IARRY(J).GT.5*(I-1))THEN
**  Compute the rates.
            FRELV=FREQ*ICOLN(J)/NREAL
            IF(ICOLN(J).EQ.0) THEN
                 ERRFRE=0.0
            ELSE
                 ERRFRE=100.0/SQRT(REAL(ICOLN(J)))
            ENDIF
**  Select the excitation frequencies
            IF(DSCRPT(J)(1:4).EQ.' EXC')THEN
*   Identify and store the rate.
                 CALL GASIDE(IEXC,NAMEG(I)//DSCRPT(J),IFAIL)
                 IF(IFAIL.NE.0)THEN
                      PRINT *,' !!!!!! OUTEI7 WARNING: Excitation'//
     -                     ' buffer is full; unable to add '//
     -                     NAMEG(I)//DSCRPT(J)
                 ELSE
                      EXBOL(IEXC)=FRELV/TORR
                 ENDIF
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ OUTEI7 DEBUG   :'',
     -                '' Gas '',A,'', state '',A,'', exc id '',I3,
     -                '', rate: '',E12.5,'' +/- '',F8.4,'' %'')')
     -                NAMEG(I),DSCRPT(J),IEXC,FRELV,ERRFRE
**  Select the ionisation frequencies
            ELSEIF(DSCRPT(J)(1:4).EQ.' ION')THEN
*   Identify and store the rate.
                 CALL GASIDI(IION,NAMEG(I)//DSCRPT(J),IFAIL)
                 IF(IFAIL.NE.0)THEN
                      PRINT *,' !!!!!! OUTEI7 WARNING: Ionisation'//
     -                     ' buffer is full; unable to add '//
     -                     NAMEG(I)//DSCRPT(J)
                 ELSE
                      IOBOL(IION)=FRELV/TORR
                 ENDIF
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ OUTEI7 DEBUG   :'',
     -                '' Gas '',A,'', state '',A,'', ion id '',I3,
     -                '', rate: '',E12.5,'' +/- '',F8.4,'' %'')')
     -                NAMEG(I),DSCRPT(J),IION,FRELV,ERRFRE
            ENDIF
       ENDIF
20     CONTINUE
10     CONTINUE
       END
CDECK  ID>, DLCMIC.
       SUBROUTINE DLCMIC(X1,Y1,Z1,OPTION,NCOPT,EF,ES,DIRX,DIRY,DIRZ,
     -      IRCS,IHF)
*-----------------------------------------------------------------------
*   DLCMIC - Microscopic MC tracking front-end
*            NSTATL(IPT): 1=elastic, 2=ionise, 3=attach, 4=excitation,
*                         5=super-elastic, 6=inelastic
*            NSTATN(I)  : individual level described in DSCRPT(I)
*   (Last changed on 25/ 5/09.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL MVEC(MXEMAT)
       INTEGER MSIZ(MXMAT,MXMDIM),MDIM(MXMAT),MREF(MXMAT+1),MMOD(MXMAT),
     -      MORG(MXMAT+1),MLEN(MXMAT+1),NREFL
       COMMON /MATDAT/ MVEC,MSIZ,MDIM,MMOD,MORG,MLEN,MREF,NREFL
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
*   Changed name of common from /NAMES/ to /MBGNAM/ for Mac OS X
       CHARACTER*15 NAMEG
       COMMON /MBGNAM/ NAMEG(mxngas)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       REAL X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,DNORM
       INTEGER IFAIL,NSTATL(5*MXNGAS),NSTATN(512),I,IPT,IGAS,ITYPE,
     -      IREF,IHF,ISIZ(1),MATSLT,IRCS,ISCS,NCOPT
       LOGICAL LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,
     -      lheinrich
       CHARACTER*(*) OPTION
       EXTERNAL MATSLT
*** Check the energy
       IF(ES.LT.0)THEN
            PRINT *,' !!!!!! DLCMIC WARNING : Starting energy is'//
     -           ' negative; abandoned.'
            NU=0
            ISTAT=-3
            RETURN
       ELSEIF(EF.LE.0)THEN
            PRINT *,' !!!!!! DLCMIC WARNING : Final energy is'//
     -           ' non-positive; abandoned.'
            NU=0
            ISTAT=-3
            RETURN
       ENDIF
*** Initialise the gas
       CALL DLCMII(EF,NSTATL,NSTATN,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! DLCMIC WARNING : Initialisation failed'//
     -           ' ; no calculation performed.'
            RETURN
       ENDIF
*** Decode the options: Magboltz print option.
       LBMCPR=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOPRINT').NE.0)THEN
            LBMCPR=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'PRINT').NE.0)THEN
            LBMCPR=.TRUE.
       ENDIF
*   Mark ionisations
       LPLION=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-ION').NE.0)THEN
            LPLION=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-ION').NE.0)THEN
            LPLION=.TRUE.
       ENDIF
*   Mark excitations
       LPLEXC=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-EXC').NE.0)THEN
            LPLEXC=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-EXC').NE.0)THEN
            LPLEXC=.TRUE.
       ENDIF
*   Mark inelastic
       LPLINE=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-INEL').NE.0)THEN
            LPLINE=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-INEL').NE.0)THEN
            LPLINE=.TRUE.
       ENDIF
*   Mark elastic
       LPLELA=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-ELAS').NE.0)THEN
            LPLELA=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-ELAS').NE.0)THEN
            LPLELA=.TRUE.
       ENDIF
*   Mark super-elastic
       LPLSUP=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-SUP').NE.0)THEN
            LPLSUP=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-SUP').NE.0)THEN
            LPLSUP=.TRUE.
       ENDIF
*   Mark attachment
       LPLATT=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOMARK-ATT').NE.0)THEN
            LPLATT=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'MARK-ATT').NE.0)THEN
            LPLATT=.TRUE.
       ENDIF
*   Heinrich options
       lheinrich=.FALSE.
       IF(INDEX(OPTION(1:NCOPT),'NOHEINRICH').NE.0)THEN
            lheinrich=.FALSE.
       ELSEIF(INDEX(OPTION(1:NCOPT),'HEINRICH').NE.0)THEN
            lheinrich=.TRUE.
       ENDIF
*** Book an histogram for the energy distribution, if needed.
       IF(IHF.LT.0)THEN
            CALL HISADM('ALLOCATE',IHF,100,0.0,EF,.FALSE.,IFAIL)
            IF(IFAIL.NE.0)THEN
                 PRINT *,' !!!!!! DLCMIC WARNING : Unable to obtain'//
     -                ' matrix storage; energy not histogrammed.'
                 IHF=0
            ENDIF
       ENDIF
*** Normalise the initial vector.
       IF(DIRX**2+DIRY**2+DIRZ**2.LE.0)THEN
            PRINT *,' !!!!!! DLCMIC WARNING : Initial direction'//
     -           ' vector has zero norm; no calculation.'
            RETURN
       ELSE
            DNORM=SQRT(DIRX**2+DIRY**2+DIRZ**2)
            DIRX=DIRX/DNORM
            DIRY=DIRY/DNORM
            DIRZ=DIRZ/DNORM
       ENDIF
*** Step.
       CALL DLCMST(X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,NSTATL,NSTATN,IHF,
     -      LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,lheinrich)
*** Extract the statistics: first initialise the counters.
       IF(IRCS.GT.0)THEN
*   Loop over the levels.
            DO 10 I=1,IPLAST
            IPT=IARRY(I)
            IGAS=1+(IPT-1)/5
            ITYPE=IPT-5*(IGAS-1)
            IF(ITYPE.EQ.4.AND.DSCRPT(I)(1:4).NE.' EXC')ITYPE=6
            CALL GASIDO(IREF,NAMEG(IGAS)//DSCRPT(I),ITYPE,0.0,IFAIL)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMIC DEBUG   :'',
     -           '' Gas '',I3,'', cs type '',I1,'', cs "'',A,''",'',
     -           '' count '',I6,'', ref '',I3)') IGAS,ITYPE,DSCRPT(I),
     -           NSTATN(I),IREF
            IF(IFAIL.NE.0)PRINT *,' !!!!!! DLCMIC WARNING : Unable'//
     -           ' to store a rate.'
10          CONTINUE
*** Store the matrices: elastic.
            ISIZ(1)=IPLAST
            CALL MATADM('ALLOCATE',IRCS,1,ISIZ,2,IFAIL)
            ISCS=MATSLT(IRCS)
            DO 20 I=1,IPLAST
            MVEC(MORG(ISCS)+I)=NSTATN(I)
20          CONTINUE
       ENDIF
       END
       SUBROUTINE DLCMII(EF,NSTATL,NSTATN,IFAIL)
*-----------------------------------------------------------------------
*   DLCMII - Initialisation for microscopic MC tracking.
*   (Last changed on  3/ 4/08.)
*-----------------------------------------------------------------------
       implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
       INTEGER I,IFAIL,NMAX,NSTATL(5*MXNGAS),NSTATN(512)
       DOUBLE PRECISION E,B,BTH,T,P
       REAL EF,PGAS,TGAS,FRASUM,GASFRM(MXGNAM)
       CHARACTER*80 GASID
*** Retrieve pressure and temperature.
       CALL GASINF(PGAS,TGAS,GASID,GASFRM)
*** Set the gas mixture.
       FRASUM=0
       DO 10 I=1,MXGNAM
       FRAMIX(I)=GASFRM(I)
       FRASUM=FRASUM+FRAMIX(I)
10     CONTINUE
       IF(FRASUM.LE.0)THEN
            PRINT *,' !!!!!! DLCMII WARNING : Sum of gas fractions'//
     -           ' less or equal to 0; no calculation.'
            IFAIL=1
            RETURN
       ENDIF
*** Set E, B and angle: dummy values
       E=1000.0
       B=0.0
       BTH=0.0
*   Set the pressure and temperature.
       T=TGAS
       P=PGAS
*   Number of collisions: dummy value
       NMAX=2
*** Establish the parameters.
       CALL SETB7(E,B,BTH,T,P,NMAX,IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! DLCMII WARNING : Setting Magboltz'//
     -           ' parameters failed.'
            IFAIL=1
            RETURN
       ENDIF      
*   Overrrule the energy limit
       EFINAL=DBLE(EF)
*** Mix the gases
       CALL MIXER7(IFAIL)
       IF(IFAIL.NE.0)THEN
            PRINT *,' !!!!!! DLCMII WARNING : Setting Magboltz'//
     -           ' cross section tables failed.'
            IFAIL=1
            RETURN
       ENDIF      
*** Plot the cross sections
C      call gaspcs('DLCMIC')
*** Initial statistics.
       DO 20 I=1,5*MXNGAS
       NSTATL(I)=0
20     CONTINUE
       DO 30 I=1,512
       NSTATN(I)=0
30     CONTINUE
*** Has worked.
       IFAIL=0
       END
       SUBROUTINE DLCMST(X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,
     -      NSTATL,NSTATN,IHF,
     -      LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,lheinrich)
*-----------------------------------------------------------------------
*   DLCMST - Microscopic MC tracking, derived from MONTE
*   (Last changed on  2/ 8/10.)
*-----------------------------------------------------------------------
      implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
       DOUBLE PRECISION PIR2,ECHARG,EMASS,AMU,BOLTZ,BOLTZJ,
     -      AWB,ALOSCH,ABZERO,ATMOS
       PARAMETER(PIR2=8.79735534D-17)
       PARAMETER(ECHARG=1.602176462D-19)
       PARAMETER(EMASS=9.10938188D-31)
       PARAMETER(AMU=1.66053873D-27)
       PARAMETER(BOLTZ=8.617342D-5)
       PARAMETER(BOLTZJ=1.3806503D-23)
       PARAMETER(AWB=1.758820174D10)
       PARAMETER(ALOSCH=2.6867775D19)
       PARAMETER(ABZERO=273.15D0)
       PARAMETER(ATMOS=760.0D0)
       DOUBLE PRECISION CONST1,CONST2,CONST3,CONST4,CONST5
       COMMON/CNSTS1/CONST1,CONST2,CONST3,CONST4,CONST5
       DOUBLE PRECISION TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX,RSTART,
     -      EMAG
       INTEGER NMAX
       COMMON/SETP/TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX(8),RSTART,
     -      EMAG,NMAX
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
*   Is in effect the old ANCT common.
       DOUBLE PRECISION PSCT,ANGCT
       INTEGER INDEX,NISO
       COMMON/ANIS/PSCT(2048,512),ANGCT(2048,512),INDEX(512),NISO
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       DOUBLE PRECISION X,Y,Z,ST,RDUM,E1,E,EX,EY,EZ,
     -      CONST6,CONST7,CONST9,TDASH,TLIM,T,T2,
     -      DCX1,DCY1,DCZ1,DCX2,DCY2,DCZ2,THETA0,PHI0,
     -      AP,BP,A,F3,F4,F5,F6,F8,F9,R1,R2,R3,R4,R5,R9,R31,
     -      S1,S2,EXTRA,EI,D,Q,ARG1,ARGZ,CSQD,DELTAE,U,
     -      DRAND48,EMAX,XPL(1),YPL(1),ZPL(1),
     -      xold, yold, zold, eold
       REAL X1,Y1,Z1,ES,EF,XS,YS,ZS,EXS,EYS,EZS,ETOTS,VOLTS,
     -      DIRX,DIRY,DIRZ,XNEW,YNEW,ZNEW,DELAY,ENEW
       INTEGER INTEM,J1,NCOL,NNULL,I,IE,IPT,ILOC,IGAS,ITYPE,
     -      NSTATL(5*MXNGAS),NSTATN(512),IHF
       LOGICAL LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,lheinrich,
     -      ADDNEW
       EXTERNAL DRAND48
      integer ioncount
*** Debugging
       IF(LDEBUG)WRITE(LUNOUT,*) '  ++++++ DLCMST DEBUG   : Start: ',
     -      X1,Y1,Z1,', energy start/max: ',ES,EF
*** Initialise the steps
       NU=1
       XU(NU)=DBLE(X1)
       YU(NU)=DBLE(Y1)
       ZU(NU)=DBLE(Z1)
       TU(NU)=0
       CALL DLCSTA(-1.0,1)
       IF(ISTAT.NE.0)RETURN
*** Heinrich options.
       if(lheinrich)then
            open(unit=38,file='heinrich.dump')
       endif
*** Set technique and particle labels
       IPTYPE=1
       QPCHAR=-1.0
       IPTECH=4
*** Starting point.
       X=X1/1.0D2
       Y=Y1/1.0D2
       Z=Z1/1.0D2
*   Starting time.
       ST=0.0D0
*   Starting energy and keeping track of energy
       E1=DBLE(ES)
       EMAX=E1
*   Various parameters.
       SMALL=1.0D-20
       RDUM=RSTART
       CONST9=CONST3*0.01D0
       INTEM=8
       NCOL=0
       NNULL=0
*   Number of collisions for de-correlation ?
       TDASH=0.0D0
*** Initial direction cosines
       DCX1=DBLE(DIRX)
       DCY1=DBLE(DIRY)
       DCZ1=DBLE(DIRZ)
*   Parameters to compute position after step
       F4=2.0D0*ACOS(-1.0D0)
       DELTAE=EFINAL/DBLE(INTEM)
*** Main loop
       DO 210 J1=1,100000000
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   : Step '',
     -      I3,'', iteration '',I5,'', collision '',I5)') NU,J1,NCOL
*** Get the electric and magnetic field
       XS=REAL(X*100.0)
       YS=REAL(Y*100.0)
       ZS=REAL(Z*100.0)
       CALL EFIELD(XS,YS,ZS,EXS,EYS,EZS,ETOTS,VOLTS,0,ILOC)
       EX=-DBLE(EXS)
       EY=-DBLE(EYS)
       EZ=-DBLE(EZS)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   : At ('',
     -      3E15.8,''), E = ('',3E15.8,''), loc = '',I5,'', nu = '',
     -      I5)') X,Y,Z,EX,EY,EZ,ILOC,NU
*   If this is not in the drift medium, stop now.
       IF(ILOC.NE.0.OR.
     -      XS.LT.DDXMIN.OR.XS.GT.DDXMAX.OR.
     -      YS.LT.DDYMIN.OR.YS.GT.DDYMAX.OR.
     -      ZS.LT.DDZMIN.OR.ZS.GT.DDZMAX)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
            ENDIF
            IF(ILOC.EQ.-5.OR.ILOC.EQ.-6)THEN
                 CALL DLCFMP(XU(NU),YU(NU),ZU(NU),
     -                X*1.0D2,Y*1.0D2,Z*1.0D2,
     -                T*1.0D-6,ILOC,QPCHAR,IPTECH)
            ELSE
                 NU=NU+1
                 XU(NU)=X*1.0D2
                 YU(NU)=Y*1.0D2
                 ZU(NU)=Z*1.0D2
                 TU(NU)=ST*1.0D-6
                 CALL DLCSTA(-1.0,1)
            ENDIF
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -           '' loc = '',I5,'', istat = '',I5,'', e_max = '',E15.8,
     -           '' eV, nu = '',I4,'', ncol = '',I5)')
     -           ILOC,ISTAT,EMAX,NU,NCOL
*   Heinrich options.
            if(lheinrich)close(unit=38)
            RETURN
       ENDIF
*** Determine free time
    1  R1=drand48(RDUM)
       I=INT(E1/DELTAE)+1
       I=MIN(I,INTEM)
       TLIM=TCFMAX(I)
       T=-LOG(R1)/TLIM+TDASH
       t = dtfact*t
       TDASH=T
       AP=CONST3*(DCX1*EX+DCY1*EY+DCZ1*EZ)*SQRT(E1)
       BP=(EX**2+EY**2+EZ**2)*CONST1
       E=E1+(AP+BP*T)*T
*   Keep track of the highest energy
       EMAX=MAX(E,EMAX)
       IF(E.GT.EFINAL)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -           '' Energy '',E15.8,'' eV exceeds e_maximum '',E15.8,
     -           '' eV; abandoned at nu = '',I4,'', ncol = '',I5)')
     -           E,EFINAL,NU,NCOL
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
            ENDIF
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
            ISTAT=-9
*   Heinrich options.
            if(lheinrich)close(unit=38)
            RETURN
       ENDIF
       IF(IHF.GT.0)CALL HISENT(IHF,REAL(E),1.0)
*   Check null collisions
       IE=INT(E/ESTEP)+1
       IE=MIN(IE,2048)
       IF(TCF(IE).GT.TLIM) THEN
            TDASH=TDASH+LOG(R1)/TLIM
            TCFMAX(I)=1.05D0*TCFMAX(I)
            IF(LBMCPR)WRITE(LUNOUT,996)
996         FORMAT(/,5X,' WARNING NULL COLLISION TIME INCREASED',/)
            GO TO 1
       ENDIF
*   Test for real or null collision
       R5=drand48(RDUM)
       TLIM=TCF(IE)/TLIM
       IF(R5.GT.TLIM) THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -           '' Null collision.'')')
            NNULL=NNULL+1
            GO TO 1
       ENDIF
*** Direction cosines and positions at instant before collision
       T2=T*T
       TDASH=0.0D0
       CONST6=SQRT(E1/E)
       DCX2=DCX1*CONST6+EX*T*CONST5/SQRT(E)
       DCY2=DCY1*CONST6+EY*T*CONST5/SQRT(E)
       DCZ2=DCZ1*CONST6+EZ*T*CONST5/SQRT(E)
*   const7: velocity [m/psec], a: velocity time [m]
       CONST7=CONST9*SQRT(E1)
       A=T*CONST7
       NCOL=NCOL+1
       xold=x
       yold=y
       zold=z
       eold=e1
       X=X+DCX1*A+T2*EX*CONST2
       Y=Y+DCY1*A+T2*EY*CONST2
       Z=Z+DCZ1*A+T2*EZ*CONST2
       ST=ST+T
*** Add new point
       IF(NMC*(NCOL/NMC).EQ.NCOL)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
            ENDIF
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
       ENDIF
*** Determination of real collision type
       R2=drand48(RDUM)
*   Find location within 4 units in collision array
       CALL SORT(I,R2,IE)
  140  I=I+1
       IF(CF(IE,I).LT.R2) GO TO 140
       S1=RGAS(I)
       EI=EIN(I)
*   Use flat distribution of  electron energy between E-EION and 0.0 eV
       IF(IPN(I).GT.0)THEN
            R9=drand48(RDUM)
            EXTRA=R9*(E-EI)
            EI=EXTRA+EI
       ENDIF
*** Generate scattering angles, update lab cosines, type of collision.
       IPT=IARRY(I)
       IGAS=1+(IPT-1)/5
       ITYPE=IPT-5*(IGAS-1)
*   NSTATL(IPT): 1=elastic, 2=ionise, 3=attach, 4=inelastic, 5=super
       NSTATL(IPT)=NSTATL(IPT)+1
*   NSTATN(I): individual level described in DSCRPT(I)
       NSTATN(I)=NSTATN(I)+1
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   : Gas '',I3,
     -      '' type '',I1,'' level '',A)') IGAS,ITYPE,DSCRPT(I)
*   Elastic.
       XPL(1)=X*1.0D2
       YPL(1)=Y*1.0D2
       ZPL(1)=Z*1.0D2
       IF(ITYPE.EQ.1.AND.LPLELA)THEN
            CALL GRATTS('ELASTIC','POLYMARKER')
            CALL PLAGPM(1,XPL,YPL,ZPL)
*   Ionisation.
       ELSEIF(ITYPE.EQ.2.AND.LPLION)THEN
            CALL GRATTS('IONISATION','POLYMARKER')
            CALL PLAGPM(1,XPL,YPL,ZPL)
*   Heinrich update
            if(lheinrich)ioncount=ioncount+1
*   Electron ends due to attachment.
       ELSEIF(ITYPE.EQ.3)THEN
            IF(LPLATT)THEN
                 CALL GRATTS('ATTACHMENT','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ENDIF
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
*   Heinrich options.
                if(lheinrich)close(unit=38)
                RETURN
            ENDIF
            IF(ABS(TU(NU)-ST*1.0D-6).GT.1.0D-6)THEN
                 NU=NU+1
                 XU(NU)=X*1.0D2
                 YU(NU)=Y*1.0D2
                 ZU(NU)=Z*1.0D2
                 TU(NU)=ST*1.0D-6
            ENDIF
            ISTAT=-7
*   Heinrich options.
            if(lheinrich)close(unit=38)
            RETURN
*   Inelastic and excitation.
       ELSEIF(ITYPE.EQ.4.AND.(LPLINE.OR.LPLEXC))THEN
            IF(LPLEXC.AND.DSCRPT(I)(1:4).EQ.' EXC')THEN
                 CALL GRATTS('EXCITATION','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ELSEIF(LPLINE.AND.DSCRPT(I)(1:4).NE.' EXC')THEN
                 CALL GRATTS('INELASTIC','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ENDIF
*   Super-elastic
       ELSEIF(ITYPE.EQ.5.AND.LPLSUP)THEN
            CALL GRATTS('SUPER-ELASTIC','POLYMARKER')
            CALL PLAGPM(1,XPL,YPL,ZPL)
       ENDIF
*   Call a user procedure to dealing with excitations.
       CALL GASEXU(ITYPE,IGAS,I,
     -      REAL(X*100),REAL(Y*100),REAL(Z*100),
     -      REAL(E),REAL(ST*1.0D-6),
     -      ADDNEW,XNEW,YNEW,ZNEW,DELAY,ENEW)
*   Write a Heinrich record
       if(lheinrich)then
            write(38,'(1x,I5,2X,i5,8(e20.13,2x),a)') itype,ioncount,
     -           x*100,y*100,z*100,e,
     -           xold*100,yold*100,zold*100,eold,dscrpt(i)
       endif
*** Fix energy loss smaller than incident energy if error occurs
       IF(E.LT.EI) THEN
            IF(LBMCPR)WRITE(LUNOUT,994) E,EI,J1
994         FORMAT(2X,' WARNING ENERGY =',F10.5,
     -           ' LESS THAN ENERGY LOSS EI=',F10.5,' AT ITER=',I12,
     -           ' DUE TO BINNING ERROR')
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMST DEBUG   : Gas '',I3,
     -           '' type '',I1,'' level '',A)') IGAS,ITYPE,DSCRPT(I)
            EI=E-0.0001D0
       ENDIF
*   Scatter
       S2=(S1*S1)/(S1-1.0D0)
*   Anisotropic scattering to obtain theta
       IF(INDEX(I).NE.0) THEN
            R31=drand48(RDUM)
            R3=drand48(RDUM)
            F3=1.0D0-R3*ANGCT(IE,I)
            IF(R31.GT.PSCT(IE,I)) F3=-F3
*   Isotropic scattering
       ELSE
            R3=drand48(RDUM)
            F3=1.0D0-2.0D0*R3
       ENDIF
       THETA0=ACOS(F3)
*   Obtain phi
       R4=drand48(RDUM)
       PHI0=F4*R4
*   Work out the new direction
       F8=SIN(PHI0)
       F9=COS(PHI0)
       ARG1=1.0D0-S1*EI/E
       ARG1=MAX(ARG1,SMALL)
       D=1.0D0-F3*SQRT(ARG1)
       E1=E*(1.0D0-EI/(S1*E)-2.0D0*D/S2)
       E1=MAX(E1,SMALL)
       Q=SQRT((E/E1)*ARG1)/S1
       Q=MIN(Q,1.0D0)
       THETA=ASIN(Q*SIN(THETA0))
       F6=COS(THETA)
       U=(S1-1.0D0)*(S1-1.0D0)/ARG1
       CSQD=F3*F3
       IF(F3.LT.0.0D0.AND.CSQD.GT.U) F6=-1.0D0*F6
       F5=SIN(THETA)
       DCZ2=MIN(DCZ2,1.0D0)
       ARGZ=SQRT(DCX2*DCX2+DCY2*DCY2)
       IF(ARGZ.EQ.0.0D0) THEN
            IF(LBMCPR)WRITE(LUNOUT,9232) J1,E1
9232        FORMAT(3X,'WARNING ARGZ= 0.0 AT J1 =',I10,' E1=',E12.3)
            DCZ1=F6
            DCX1=F9*F5
            DCY1=F8*F5
       ELSE
            DCZ1=DCZ2*F6+ARGZ*F5*F8
            DCY1=DCY2*F6+(F5/ARGZ)*(DCX2*F9-DCY2*DCZ2*F8)
            DCX1=DCX2*F6-(F5/ARGZ)*(DCY2*F9+DCX2*DCZ2*F8)
       ENDIF
 210   CONTINUE
*** End of loop.
       PRINT *,' !!!!!! DLCMST WARNING : Reached end of loop, should'//
     -      ' not happen; returning ISTAT = -2.'
       ISTAT=-2
*   Heinrich options.
       if(lheinrich)close(unit=38)
       END
       SUBROUTINE DLCMIA(X1,Y1,Z1,OPTION,EF,ES,DIRX,DIRY,DIRZ,IRCS,IHF,
     -      TOFF,NETOT,NITOT,IFAIL)
*-----------------------------------------------------------------------
*   DLCMIA - Microscopic MC tracking front-end
*            NSTATL(IPT): 1=elastic, 2=ionise, 3=attach, 4=excitation,
*                         5=super-elastic, 6=inelastic
*            NSTATN(I)  : individual level described in DSCRPT(I)
*   (Last changed on 15/12/10.)
*-----------------------------------------------------------------------
       implicit none
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       REAL MVEC(MXEMAT)
       INTEGER MSIZ(MXMAT,MXMDIM),MDIM(MXMAT),MREF(MXMAT+1),MMOD(MXMAT),
     -      MORG(MXMAT+1),MLEN(MXMAT+1),NREFL
       COMMON /MATDAT/ MVEC,MSIZ,MDIM,MMOD,MORG,MLEN,MREF,NREFL
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
*   Changed name of common from /NAMES/ to /MBGNAM/ for Mac OS X
       CHARACTER*15 NAMEG
       COMMON /MBGNAM/ NAMEG(mxngas)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       LOGICAL FPERX,FPERY,LCROSS,TRASET,TRAFLG,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       INTEGER NPAIR,ICLUST,NFOUR,MFEXP,MXMIN,MXMAX,
     -      MYMIN,MYMAX,NTRBNK,ITRMAJ,NTIME,NORIA,
     -      NASIMP,JIORD,NISIMP,NMQUAD,NCANG,IENANG
       REAL TIMSIG,SIGNAL,TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,
     -      AVALAN,TSTART,TDEV,PRSTHR,
     -      TRABNK,TRAVEC
       CHARACTER*(MXCHAR) FCNANG
       CHARACTER*12 AVATYP
       CHARACTER*3 FCELTP
       COMMON /SIGDAT/ TIMSIG(MXLIST),SIGNAL(MXLIST,MXSW,2),
     -      AVALAN(2),TRAVEC(MXLIST),
     -      TRABNK(MXLIST,9),TSTART,TDEV,PRSTHR,
     -      TCLUST,SCLUST,ACLUST,BCLUST,FCLUST,ICLUST,NPAIR,
     -      NFOUR,ITRMAJ,JIORD,NISIMP,NMQUAD,IENANG,NTIME,NORIA,
     -      MFEXP,MXMIN,MXMAX,MYMIN,MYMAX,NTRBNK,NASIMP,NCANG,
     -      TRASET,TRAFLG(9),FPERX,FPERY,LCROSS,LITAIL,LDTAIL,LRTAIL,
     -      LEPULS,LIPULS,SIGSET,RESSET
       COMMON /SIGCHR/ FCELTP,AVATYP,FCNANG
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       REAL X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,DNORM,TOFF
       INTEGER IFAIL1,IFAIL,NSTATL(5*MXNGAS),NSTATN(512),I,IPT,IGAS,
     -      ITYPE,IREF,IHF,ISIZ(1),MATSLT,IRCS,ISCS,NETOT,NITOT,NEMAX
       LOGICAL LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,LELEPL,LIONPL,
     -      lheinrich,LSIGAD
       CHARACTER*(*) OPTION
       EXTERNAL MATSLT
*** Assume this will fail.
       IFAIL=1
*** Check the energy
       IF(ES.LT.0)THEN
            PRINT *,' !!!!!! DLCMIA WARNING : Starting energy is'//
     -           ' negative; abandoned.'
            NU=0
            ISTAT=-3
            RETURN
       ELSEIF(EF.LE.0)THEN
            PRINT *,' !!!!!! DLCMIA WARNING : Final energy is'//
     -           ' non-positive; abandoned.'
            NU=0
            ISTAT=-3
            RETURN
       ENDIF
*** Initialise the gas
       CALL DLCMII(EF,NSTATL,NSTATN,IFAIL1)
       IF(IFAIL1.NE.0)THEN
            PRINT *,' !!!!!! DLCMIA WARNING : Initialisation failed'//
     -           ' ; no calculation performed.'
            RETURN
       ENDIF
*** Decode the options: Magboltz print option.
       LBMCPR=.FALSE.
       IF(INDEX(OPTION,'NOPRINT').NE.0)THEN
            LBMCPR=.FALSE.
       ELSEIF(INDEX(OPTION,'PRINT').NE.0)THEN
            LBMCPR=.TRUE.
       ENDIF
*   Mark ionisations
       LPLION=.FALSE.
       IF(INDEX(OPTION,'NOMARK-ION').NE.0)THEN
            LPLION=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-ION').NE.0)THEN
            LPLION=.TRUE.
       ENDIF
*   Mark excitations
       LPLEXC=.FALSE.
       IF(INDEX(OPTION,'NOMARK-EXC').NE.0)THEN
            LPLEXC=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-EXC').NE.0)THEN
            LPLEXC=.TRUE.
       ENDIF
*   Mark inelastic
       LPLINE=.FALSE.
       IF(INDEX(OPTION,'NOMARK-INEL').NE.0)THEN
            LPLINE=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-INEL').NE.0)THEN
            LPLINE=.TRUE.
       ENDIF
*   Mark elastic
       LPLELA=.FALSE.
       IF(INDEX(OPTION,'NOMARK-ELAS').NE.0)THEN
            LPLELA=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-ELAS').NE.0)THEN
            LPLELA=.TRUE.
       ENDIF
*   Mark super-elastic
       LPLSUP=.FALSE.
       IF(INDEX(OPTION,'NOMARK-SUP').NE.0)THEN
            LPLSUP=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-SUP').NE.0)THEN
            LPLSUP=.TRUE.
       ENDIF
*   Mark attachment
       LPLATT=.FALSE.
       IF(INDEX(OPTION,'NOMARK-ATT').NE.0)THEN
            LPLATT=.FALSE.
       ELSEIF(INDEX(OPTION,'MARK-ATT').NE.0)THEN
            LPLATT=.TRUE.
       ENDIF
*   Heinrich options
       lheinrich=.FALSE.
       IF(INDEX(OPTION,'NOHEINRICH').NE.0)THEN
            lheinrich=.FALSE.
       ELSEIF(INDEX(OPTION,'HEINRICH').NE.0)THEN
            lheinrich=.TRUE.
       ENDIF
*   Signal
       LSIGAD=.FALSE.
       IF(INDEX(OPTION,'NOSIGNAL').NE.0)THEN
            LSIGAD=.FALSE.
       ELSEIF(INDEX(OPTION,'SIGNAL').NE.0)THEN
            LSIGAD=.TRUE.
       ENDIF
*** Electron and ion tracking, avalanche limit
       LELEPL=.FALSE.
       LIONPL=.FALSE.
       NEMAX=0
*   Decode the options.
       IF(INDEX(OPTION,'NOPLOT-ELECTRON').NE.0)THEN
            LELEPL=.FALSE.
       ELSEIF(INDEX(OPTION,'PLOT-ELECTRON').NE.0)THEN
            LELEPL=.TRUE.
       ENDIF
       IF(INDEX(OPTION,'NOPLOT-ION').NE.0)THEN
            LIONPL=.FALSE.
       ELSEIF(INDEX(OPTION,'PLOT-ION').NE.0)THEN
            LIONPL=.TRUE.
       ENDIF
       IF(INDEX(OPTION,'ABORT-100000').NE.0)THEN
            NEMAX=100000
       ELSEIF(INDEX(OPTION,'ABORT-10000').NE.0)THEN
            NEMAX=10000
       ELSEIF(INDEX(OPTION,'ABORT-1000').NE.0)THEN
            NEMAX=1000
       ELSEIF(INDEX(OPTION,'ABORT-100').NE.0)THEN
            NEMAX=100
       ELSEIF(INDEX(OPTION,'ABORT-10').NE.0)THEN
            NEMAX=10
       ENDIF
*** Book an histogram for the energy distribution, if needed.
       IF(IHF.LT.0)THEN
            CALL HISADM('ALLOCATE',IHF,100,0.0,EF,.FALSE.,IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCMIA WARNING : Unable to obtain'//
     -                ' matrix storage; energy not histogrammed.'
                 IHF=0
            ENDIF
       ENDIF
*** Normalise the initial vector.
       IF(DIRX**2+DIRY**2+DIRZ**2.LE.0)THEN
            PRINT *,' !!!!!! DLCMIA WARNING : Initial direction'//
     -           ' vector has zero norm; no calculation.'
            RETURN
       ELSE
            DNORM=SQRT(DIRX**2+DIRY**2+DIRZ**2)
            DIRX=DIRX/DNORM
            DIRY=DIRY/DNORM
            DIRZ=DIRZ/DNORM
       ENDIF
*** Initialise signal calculations if not yet done.
       IF(LSIGAD.AND..NOT.SIGSET)THEN
            CALL SIGINI(IFAIL1)
            IF(IFAIL1.NE.0)THEN
                 PRINT *,' !!!!!! DLCMIA WARNING : Initialisation of'//
     -                ' signal calculation failed; no avalanche.'
                 RETURN
            ENDIF
       ENDIF
*** Step.
       CALL DLCMSA(X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,
     -      NSTATL,NSTATN,IHF,TOFF,NETOT,NITOT,
     -      LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,
     -      LELEPL,LIONPL,lheinrich,LSIGAD,NEMAX,IFAIL1)
*   Check error condition.
       IF(IFAIL1.NE.0)RETURN
*** Extract the statistics: first initialise the counters.
       IF(IRCS.GT.0)THEN
*   Loop over the levels.
            DO 10 I=1,IPLAST
            IPT=IARRY(I)
            IGAS=1+(IPT-1)/5
            ITYPE=IPT-5*(IGAS-1)
            IF(ITYPE.EQ.4.AND.DSCRPT(I)(1:4).NE.' EXC')ITYPE=6
            CALL GASIDO(IREF,NAMEG(IGAS)//DSCRPT(I),ITYPE,0.0,IFAIL1)
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMIA DEBUG   :'',
     -           '' Gas '',I3,'', cs type '',I1,'', cs "'',A,''",'',
     -           '' count '',I6,'', ref '',I3)') IGAS,ITYPE,DSCRPT(I),
     -           NSTATN(I),IREF
            IF(IFAIL1.NE.0)PRINT *,' !!!!!! DLCMIA WARNING : Unable'//
     -           ' to store a rate.'
10          CONTINUE
*** Store the matrices: elastic.
            ISIZ(1)=IPLAST
            CALL MATADM('ALLOCATE',IRCS,1,ISIZ,2,IFAIL1)
            ISCS=MATSLT(IRCS)
            DO 20 I=1,IPLAST
            MVEC(MORG(ISCS)+I)=NSTATN(I)
20          CONTINUE
       ENDIF
*** Success
       IFAIL=0
       END
       SUBROUTINE DLCMSA(X1,Y1,Z1,EF,ES,DIRX,DIRY,DIRZ,
     -      NSTATL,NSTATN,IHF,TOFF,NETOT,NITOT,
     -      LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,
     -      LELEPL,LIONPL,lheinrich,LSIGAD,NEMAX,IFAIL)
*-----------------------------------------------------------------------
*   DLCMSA - Microscopic MC tracking, with avalanche derived from MONTE.
*   (Last changed on  2/ 8/10.)
*-----------------------------------------------------------------------
      implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
       DOUBLE PRECISION PIR2,ECHARG,EMASS,AMU,BOLTZ,BOLTZJ,
     -      AWB,ALOSCH,ABZERO,ATMOS
       PARAMETER(PIR2=8.79735534D-17)
       PARAMETER(ECHARG=1.602176462D-19)
       PARAMETER(EMASS=9.10938188D-31)
       PARAMETER(AMU=1.66053873D-27)
       PARAMETER(BOLTZ=8.617342D-5)
       PARAMETER(BOLTZJ=1.3806503D-23)
       PARAMETER(AWB=1.758820174D10)
       PARAMETER(ALOSCH=2.6867775D19)
       PARAMETER(ABZERO=273.15D0)
       PARAMETER(ATMOS=760.0D0)
       DOUBLE PRECISION CONST1,CONST2,CONST3,CONST4,CONST5
       COMMON/CNSTS1/CONST1,CONST2,CONST3,CONST4,CONST5
       DOUBLE PRECISION TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX,RSTART,
     -      EMAG
       INTEGER NMAX
       COMMON/SETP/TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX(8),RSTART,
     -      EMAG,NMAX
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
*   Is in effect the old ANCT common.
       DOUBLE PRECISION PSCT,ANGCT
       INTEGER INDEX,NISO
       COMMON/ANIS/PSCT(2048,512),ANGCT(2048,512),INDEX(512),NISO
       CHARACTER*30 DSCRPT
       COMMON/SCRIP/DSCRPT(512)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       REAL XLIST(MXMCA),YLIST(MXMCA),ZLIST(MXMCA),TLIST(MXMCA),
     -      ELIST(MXMCA),
     -      XELIST(MXMCA),YELIST(MXMCA),ZELIST(MXMCA),TELIST(MXMCA)
       INTEGER NLIST(MXMCA),ISLIST(MXMCA),NMCA
       COMMON /MCAMAT/ XLIST,YLIST,ZLIST,TLIST,ELIST,
     -      XELIST,YELIST,ZELIST,TELIST,NLIST,ISLIST,NMCA
       INTEGER NCOLM
       PARAMETER(NCOLM=1000000)
       DOUBLE PRECISION X,Y,Z,ST,RDUM,E1,E,EX,EY,EZ,
     -      CONST6,CONST7,CONST9,TDASH,TLIM,T,T2,
     -      DCX1,DCY1,DCZ1,DCX2,DCY2,DCZ2,THETA0,PHI0,
     -      AP,BP,A,F3,F4,F5,F6,F8,F9,R1,R2,R3,R4,R5,R9,R31,
     -      S1,S2,EXTRA,EI,D,Q,ARG1,ARGZ,CSQD,DELTAE,U,
     -      DRAND48,EMAX,XPL(1),YPL(1),ZPL(1),ESEC
       REAL X1,Y1,Z1,ES,EF,XS,YS,ZS,EXS,EYS,EZS,ETOTS,VOLTS,
     -      DIRX,DIRY,DIRZ,XNEW,YNEW,ZNEW,DELAY,ENEW,TOFF
C     -      ,exs2,eys2,ezs2,etots2
       INTEGER INTEM,J1,NCOL,NNULL,I,IE,IPT,ILOC,IGAS,ITYPE,NEMAX,
     -      NSTATL(5*MXNGAS),NSTATN(512),IHF,NETOT,NITOT,IMCA,IFAIL1,
     -      IFAIL
       LOGICAL LPLION,LPLEXC,LPLINE,LPLELA,LPLSUP,LPLATT,LELEPL,LIONPL,
     -      lheinrich,LSIGAD,ADDNEW
       EXTERNAL DRAND48
      integer ioncount
*** By default, failure.
       IFAIL=1
C      print *,' Microscopic avalanche'
C      print *,' Position: ',x1,y1,z1
C      print *,' Energy: at start ',es,' eV, maximal ',ef,' eV'
C      print *,' Velocity vector: ',dirx,diry,dirz
*** Initialise the avalanche table.
       NMCA=1
       XLIST(1)=X1/1.0D2
       YLIST(1)=Y1/1.0D2
       ZLIST(1)=Z1/1.0D2
       TLIST(1)=TOFF/1.0D-6
       ELIST(1)=ES
       EMAX=ELIST(1)
       NETOT=1
       NITOT=0
*** Heinrich options.
       if(lheinrich)then
            open(unit=38,file='heinrich.ions')
       endif
*** Loop over the table.
       IMCA=0
100    CONTINUE
       IMCA=IMCA+1
*   Check we are still in the table.
       IF(IMCA.GT.NMCA)THEN
*   Release memory.
            CALL BOOK('RELEASE','MCAMAT','MCA',IFAIL1)
*   This was a success
            IFAIL=0
*   Heinrich options.
            if(lheinrich)close(unit=38)
*   Return
            RETURN
       ENDIF
*** Starting point.
       X=XLIST(IMCA)
       Y=YLIST(IMCA)
       Z=ZLIST(IMCA)
*   Starting time.
       ST=TLIST(IMCA)
*   Starting energy.
       E1=DBLE(ELIST(IMCA))
*** Initialise the steps
       NU=1
       XU(NU)=100.0*X
       YU(NU)=100.0*Y
       ZU(NU)=100.0*Z
       TU(NU)=1.0D-6*ST
*** Set technique and particle labels
       IPTYPE=1
       QPCHAR=-1.0
       IPTECH=4
*** Restart ionisation counter
       ioncount=0
*** Get the electric and magnetic field for the starting point.
       XS=REAL(X*100.0)
       YS=REAL(Y*100.0)
       ZS=REAL(Z*100.0)
       CALL EFIELD(XS,YS,ZS,EXS,EYS,EZS,ETOTS,VOLTS,0,ILOC)
       EX=-DBLE(EXS)
       EY=-DBLE(EYS)
       EZ=-DBLE(EZS)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   : At ('',
     -      3E15.8,''), E = ('',3E15.8,''), loc = '',I5,'', nu = '',
     -      I5)') X,Y,Z,EX,EY,EZ,ILOC,NU
*   If this is not in the drift medium, stop now.
       IF(ILOC.EQ.-5.OR.ILOC.EQ.-6)THEN
            ISTAT=ILOC
            XELIST(IMCA)=REAL(XU(NU))/100.0
            YELIST(IMCA)=REAL(YU(NU))/100.0
            ZELIST(IMCA)=REAL(ZU(NU))/100.0
            TELIST(IMCA)=REAL(TU(NU))*1.0E6
            ISLIST(IMCA)=ISTAT
*   Add the signal.
            IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
            GOTO 100
       ENDIF
*   Start status checking.
       CALL DLCSTA(-1.0,1)
*   Check that we are inside the area, terminate if not.
       IF(ISTAT.NE.0.OR.ILOC.NE.0)THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -           '' loc = '',I5,'', istat = '',I5,'', e_max = '',E15.8,
     -           '' eV, nu = '',I4,'', ncol = '',I5)')
     -           ILOC,ISTAT,EMAX,NU,NCOL
*   End of drift line processing.
            XELIST(IMCA)=REAL(XU(NU))/100.0
            YELIST(IMCA)=REAL(YU(NU))/100.0
            ZELIST(IMCA)=REAL(ZU(NU))/100.0
            TELIST(IMCA)=REAL(TU(NU))*1.0E6
            ISLIST(IMCA)=ISTAT
*   Add the signal.
            IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
            GOTO 100
       ENDIF
*** Various parameters.
       SMALL=1.0D-20
       RDUM=RSTART
       CONST9=CONST3*0.01D0
       NCOL=0
       NNULL=0
*   Number of collisions for de-correlation ?
       TDASH=0.0D0
*   Parameters to compute position after step
       INTEM=8
       F4=2.0D0*ACOS(-1.0D0)
       DELTAE=EFINAL/DBLE(INTEM)
*** Initial direction cosines: first electron is specified
       IF(IMCA.EQ.1)THEN
            DCX1=DBLE(DIRX)
            DCY1=DBLE(DIRY)
            DCZ1=DBLE(DIRZ)
*   The secondary electrons are isotropic
       ELSE
            THETA0=ACOS(MIN(1.0,MAX(-1.0,1.0-2.0*DRAND48(RDUM))))
            PHI0=F4*DRAND48(RDUM)
            DCX1=COS(PHI0)*SIN(THETA0)
            DCY1=SIN(PHI0)*SIN(THETA0)
            DCZ1=COS(THETA0)
       ENDIF
*** Main loop
       DO 210 J1=1,100000000
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   : Step '',
     -      I3,'', iteration '',I5,'', collision '',I5)') NU,J1,NCOL
*** Get the electric and magnetic field (check only).
C       xs=real(x*100.0)
C       ys=real(y*100.0)
C       zs=real(z*100.0)
C       call efield(xs,ys,zs,exs2,eys2,ezs2,etots2,volts,0,iloc)
C       if(abs(exs-exs2).gt.1.0e-5*(1+abs(exs)+abs(exs2)).or.
C     -    abs(eys-eys2).gt.1.0e-5*(1+abs(eys)+abs(eys2)).or.
C     -    abs(ezs-ezs2).gt.1.0e-5*(1+abs(ezs)+abs(ezs2)).or.
C     -    abs(etots-etots2).gt.1.0e-5*(1+abs(etots)+abs(etots2)))then
C            print *,' Step ',j1,' field clash:'
C            print *,'             e = ',exs2,eys2,ezs2,etots2
C            print *,'             o = ',exs,eys,ezs,etots
C       endif
*** Determine free time
    1  R1=drand48(RDUM)
       I=INT(E1/DELTAE)+1
       I=MIN(I,INTEM)
       TLIM=TCFMAX(I)
       T=-LOG(R1)/TLIM+TDASH
       t = dtfact*t
       TDASH=T
       AP=CONST3*(DCX1*EX+DCY1*EY+DCZ1*EZ)*SQRT(E1)
       BP=(EX**2+EY**2+EZ**2)*CONST1
       E=E1+(AP+BP*T)*T
*   Keep track of the highest energy
       EMAX=MAX(E,EMAX)
       IF(E.GT.EFINAL)THEN
            PRINT *,' !!!!!! DLCMSA WARNING : Instantaneous electron'//
     -           ' energy ',E,' eV exceeds E_maximum ',EFINAL,' eV;'//
     -           ' avalanche tracking stopped.'
C            print *,' E1 = ',E1,', AP = ',AP,', BP = ',BP,', T = ',T
*   Too many points.
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
                 IF(LELEPL)CALL DLCPLT
                 XELIST(IMCA)=X
                 YELIST(IMCA)=Y
                 ZELIST(IMCA)=Z
                 TELIST(IMCA)=ST
                 ISLIST(IMCA)=ISTAT
*   Add the signal.
                 IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
            ENDIF
*   Add the point.
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
*   Record the problem.
            ISTAT=-9
*   Plot it.
            IF(LELEPL)CALL DLCPLT
*   Record the end point.
            XELIST(IMCA)=REAL(XU(NU))/100.0
            YELIST(IMCA)=REAL(YU(NU))/100.0
            ZELIST(IMCA)=REAL(ZU(NU))/100.0
            TELIST(IMCA)=REAL(TU(NU))*1.0E6
            ISLIST(IMCA)=ISTAT
*   Add the signal.
            IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
*   Heinrich options.
            if(lheinrich)close(unit=38)
            RETURN
       ENDIF
       IF(IHF.GT.0)CALL HISENT(IHF,REAL(E),1.0)
*   Check null collisions
       IE=INT(E/ESTEP)+1
       IE=MIN(IE,2048)
       IF(TCF(IE).GT.TLIM) THEN
            TDASH=TDASH+LOG(R1)/TLIM
            TCFMAX(I)=1.05D0*TCFMAX(I)
            IF(LBMCPR)WRITE(LUNOUT,996)
996         FORMAT(/,5X,' WARNING NULL COLLISION TIME INCREASED',/)
            GO TO 1
       ENDIF
*   Test for real or null collision
       R5=drand48(RDUM)
       TLIM=TCF(IE)/TLIM
       IF(R5.GT.TLIM) THEN
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -           '' Null collision.'')')
            NNULL=NNULL+1
            GO TO 1
       ENDIF
*** Direction cosines and positions at instant before collision
       T2=T*T
       TDASH=0.0D0
       CONST6=SQRT(E1/E)
       DCX2=DCX1*CONST6+EX*T*CONST5/SQRT(E)
       DCY2=DCY1*CONST6+EY*T*CONST5/SQRT(E)
       DCZ2=DCZ1*CONST6+EZ*T*CONST5/SQRT(E)
*   const7: velocity [m/psec], a: velocity time [m]
       CONST7=CONST9*SQRT(E1)
       A=T*CONST7
       NCOL=NCOL+1
       X=X+DCX1*A+T2*EX*CONST2
       Y=Y+DCY1*A+T2*EY*CONST2
       Z=Z+DCZ1*A+T2*EZ*CONST2
       ST=ST+T
*** Check the location: first compute the E field.
       XS=REAL(X*100.0)
       YS=REAL(Y*100.0)
       ZS=REAL(Z*100.0)
       CALL EFIELD(XS,YS,ZS,EXS,EYS,EZS,ETOTS,VOLTS,0,ILOC)
       EX=-DBLE(EXS)
       EY=-DBLE(EYS)
       EZ=-DBLE(EZS)
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   : At ('',
     -      3E15.8,''), E = ('',3E15.8,''), loc = '',I5,'', nu = '',
     -      I5)') X,Y,Z,EX,EY,EZ,ILOC,NU
*   Then verify status and position wrt box.
       IF(ILOC.NE.0.OR.
     -      XS.LT.DDXMIN.OR.XS.GT.DDXMAX.OR.
     -      YS.LT.DDYMIN.OR.YS.GT.DDYMAX.OR.
     -      ZS.LT.DDZMIN.OR.ZS.GT.DDZMAX)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
                 IF(LELEPL)CALL DLCPLT
                 XELIST(IMCA)=X
                 YELIST(IMCA)=Y
                 ZELIST(IMCA)=Z
                 TELIST(IMCA)=ST
                 ISLIST(IMCA)=ISTAT
*   Add the signal.
                 IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
                 GOTO 100
            ENDIF
            IF(ILOC.EQ.-5.OR.ILOC.EQ.-6)THEN
                 CALL DLCFMP(XU(NU),YU(NU),ZU(NU),
     -                X*1.0D2,Y*1.0D2,Z*1.0D2,
     -                T*1.0D-6,ILOC,QPCHAR,IPTECH)
                 ISTAT=ILOC
            ELSE
                 NU=NU+1
                 XU(NU)=X*1.0D2
                 YU(NU)=Y*1.0D2
                 ZU(NU)=Z*1.0D2
                 TU(NU)=ST*1.0D-6
                 CALL DLCSTA(-1.0,1)
            ENDIF
            IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -           '' loc = '',I5,'', istat = '',I5,'', e_max = '',E15.8,
     -           '' eV, nu = '',I4,'', ncol = '',I5)')
     -           ILOC,ISTAT,EMAX,NU,NCOL
            IF(LELEPL)CALL DLCPLT
            XELIST(IMCA)=REAL(XU(NU))/100.0
            YELIST(IMCA)=REAL(YU(NU))/100.0
            ZELIST(IMCA)=REAL(ZU(NU))/100.0
            TELIST(IMCA)=REAL(TU(NU))*1.0E6
            ISLIST(IMCA)=ISTAT
*   Add the signal.
            IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
            GOTO 100
       ENDIF
*** Add the new point.
       IF(NMC*(NCOL/NMC).EQ.NCOL)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
                 IF(LELEPL)CALL DLCPLT
                 XELIST(IMCA)=X
                 YELIST(IMCA)=Y
                 ZELIST(IMCA)=Z
                 TELIST(IMCA)=ST
                 ISLIST(IMCA)=ISTAT
*   Add the signal.
                 IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
                 GOTO 100
            ENDIF
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
       ENDIF
*** Determination of real collision type
       R2=drand48(RDUM)
*   Find location within 4 units in collision array
       CALL SORT(I,R2,IE)
  140  I=I+1
       IF(CF(IE,I).LT.R2) GO TO 140
       S1=RGAS(I)
       EI=EIN(I)
*   Use flat distribution of  electron energy between E-EION and 0.0 eV
       IF(IPN(I).GT.0)THEN
            R9=drand48(RDUM)
            EXTRA=R9*(E-EI)
            EI=EXTRA+EI
       ENDIF
*** Generate scattering angles, update lab cosines, type of collision.
       IPT=IARRY(I)
       IGAS=1+(IPT-1)/5
       ITYPE=IPT-5*(IGAS-1)
*   NSTATL(IPT): 1=elastic, 2=ionise, 3=attach, 4=inelastic, 5=super
       NSTATL(IPT)=NSTATL(IPT)+1
*   NSTATN(I): individual level described in DSCRPT(I)
       NSTATN(I)=NSTATN(I)+1
       IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   : Gas '',I3,
     -      '' type '',I1,'' level '',A)') IGAS,ITYPE,DSCRPT(I)
**  Common
       XPL(1)=X*1.0D2
       YPL(1)=Y*1.0D2
       ZPL(1)=Z*1.0D2
**  Elastic.
       IF(ITYPE.EQ.1.AND.LPLELA)THEN
            CALL GRATTS('ELASTIC','POLYMARKER')
            CALL PLAGPM(1,XPL,YPL,ZPL)
**  Ionisation.
       ELSEIF(ITYPE.EQ.2)THEN
*   Plot if asked.
            IF(LPLION)THEN
                 CALL GRATTS('IONISATION','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ENDIF
*   Use OPAL Peterson and Beaty splitting factor.
            R9=drand48(RDUM)
C           ESEC=R9*(E-EI)
            ESEC=WPL(I)*TAN(R9*ATAN((E-EI)/(2.0D0*WPL(I))))
            EI=ESEC+EI
*   Ensure the energy is not negative
            IF(ESEC.LT.0)THEN
                 PRINT *,' !!!!!! DLCMSA WARNING : Secondary'//
     -                ' electron energy ',ESEC,' eV < 0; set'//
     -                ' to "small".'
                 ESEC=SMALL
            ENDIF
*   Ensure we do not pass the maximum permitted avalanche size.
            IF(NMCA+1.GT.NEMAX.AND.NEMAX.GT.0)THEN
                 PRINT *,' !!!!!! DLCMSA WARNING : Avalanche exceeds'//
     -                ' maximum permitted size; avalanche ended.'
                 CALL BOOK('RELEASE','MCAMAT','MCA',IFAIL1)
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
*   Ensure there is still space in the table.
            ELSEIF(NMCA+1.GT.MXMCA)THEN
                 PRINT *,' !!!!!! DLCMSA WARNING : Overflow of'//
     -                ' secondary electron table; avalanche ended.'
                 CALL BOOK('RELEASE','MCAMAT','MCA',IFAIL1)
*   Heinrich options.
                 if(lheinrich)close(unit=38)
                 RETURN
            ENDIF
*   Add the point to the table,
            NMCA=NMCA+1
*   Store position, energy and time
            XLIST(NMCA)=X
            YLIST(NMCA)=Y
            ZLIST(NMCA)=Z
            TLIST(NMCA)=ST
            ELIST(NMCA)=ESEC
*   Increment the electron counter
            NETOT=NETOT+1
            NITOT=NITOT+1
*   Write a Heinrich record
            if(lheinrich)then
                 ioncount=ioncount+1
                 write(38,'(1x,i5,2x,i5,8(2x,e12.5))')
     -                itype,ioncount,
     -                xlist(imca),ylist(imca),zlist(imca),elist(imca),
     -                xlist(nmca),ylist(nmca),zlist(nmca),elist(nmca)
            endif
**  Electron ends due to attachment.
       ELSEIF(ITYPE.EQ.3)THEN
*   Plot position if requested.
            IF(LPLATT)THEN
                 CALL GRATTS('ATTACHMENT','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ENDIF
*   See whether we still have room.
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 IF(LDEBUG)WRITE(LUNOUT,'(''  ++++++ DLCMSA DEBUG   :'',
     -                '' Too many steps, istat = -2, e_max = '',E15.8,
     -                '' eV, nu = '',I4,'', ncol = '',I5)') EMAX,NU,NCOL
                 IF(LELEPL)CALL DLCPLT
                 XELIST(IMCA)=X
                 YELIST(IMCA)=Y
                 ZELIST(IMCA)=Z
                 TELIST(IMCA)=ST
                 ISLIST(IMCA)=ISTAT
*   Add the signal.
                 IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
                 GOTO 100
            ENDIF
*   Add point if we still have room.
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
            ISTAT=-7
*   Decrement the electron counter
            NETOT=NETOT-1
*   Plot and take next electron.
            IF(LELEPL)CALL DLCPLT
            XELIST(IMCA)=REAL(XU(NU))/100.0
            YELIST(IMCA)=REAL(YU(NU))/100.0
            ZELIST(IMCA)=REAL(ZU(NU))/100.0
            TELIST(IMCA)=REAL(TU(NU))*1.0E6
            ISLIST(IMCA)=ISTAT
*   Add the signal.
            IF(LSIGAD)CALL SIGADM(0.0, .TRUE., 1.0, IFAIL)
            GOTO 100
**  Inelastic and excitation.
       ELSEIF(ITYPE.EQ.4)THEN
*   Plot excitations.
            IF(LPLEXC.AND.DSCRPT(I)(1:4).EQ.' EXC')THEN
                 CALL GRATTS('EXCITATION','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
*   Plot other inelastic states.
            ELSEIF(LPLINE.AND.DSCRPT(I)(1:4).NE.' EXC')THEN
                 CALL GRATTS('INELASTIC','POLYMARKER')
                 CALL PLAGPM(1,XPL,YPL,ZPL)
            ENDIF
*   Call a user procedure to dealing with excitations.
            CALL GASEXU(ITYPE,IGAS,I,
     -           REAL(X*100),REAL(Y*100),REAL(Z*100),
     -           REAL(E),REAL(ST*1.0D-6),
     -           ADDNEW,XNEW,YNEW,ZNEW,DELAY,ENEW)
            IF(ADDNEW)THEN
*   Ensure we do not pass the maximum permitted avalanche size.
                 IF(NMCA+1.GT.NEMAX.AND.NEMAX.GT.0)THEN
                      PRINT *,' !!!!!! DLCMSA WARNING : Avalanche'//
     -                     ' exceeds maximum permitted size;'//
     -                     ' avalanche ended.'
                      CALL BOOK('RELEASE','MCAMAT','MCA',IFAIL1)
                      RETURN
*   Ensure there is still space in the table.
                 ELSEIF(NMCA+1.GT.MXMCA)THEN
                      PRINT *,' !!!!!! DLCMSA WARNING : Overflow of'//
     -                     ' secondary electron table; avalanche ended.'
                      CALL BOOK('RELEASE','MCAMAT','MCA',IFAIL1)
                      RETURN
                 ENDIF
*   Add the point to the table,
                 NMCA=NMCA+1
*   Store position, energy and time
                 XLIST(NMCA)=XNEW/100.0
                 YLIST(NMCA)=YNEW/100.0
                 ZLIST(NMCA)=ZNEW/100.0
                 TLIST(NMCA)=ST+DELAY/1.0D-6
                 ELIST(NMCA)=ENEW
C       print *,' Adding an electron at ',xnew,ynew,znew,
C     -      ' with delay ',delay,' energy: ',enew
*   Increment the electron counter
                 NETOT=NETOT+1
                 NITOT=NITOT+1
            ENDIF
*   Write a Heinrich record
       if(lheinrich)then
            write(38,'(1x,I5,2X,i5,5(2x,e20.13),2x,a)') itype,ioncount,
     -           x*100,y*100,z*100,e,st*1.0d-6,dscrpt(i)
       endif
**  Super-elastic
       ELSEIF(ITYPE.EQ.5.AND.LPLSUP)THEN
            CALL GRATTS('SUPER-ELASTIC','POLYMARKER')
            CALL PLAGPM(1,XPL,YPL,ZPL)
       ENDIF
*** Fix energy loss smaller than incident energy if error occurs
       IF(E.LT.EI) THEN
            IF(LBMCPR)WRITE(LUNOUT,994) E,EI,J1
994         FORMAT(2X,' WARNING ENERGY =',F8.3,
     -           ' LESS THAN ENERGY LOSS EI=',F8.3,' AT ITER=',I12,
     -           ' DUE TO BINNING ERROR')
            EI=E-0.0001D0
       ENDIF
*   Scatter
       S2=(S1*S1)/(S1-1.0D0)
*   Anisotropic scattering to obtain theta
       IF(INDEX(I).NE.0) THEN
            R31=drand48(RDUM)
            R3=drand48(RDUM)
            F3=1.0D0-R3*ANGCT(IE,I)
            IF(R31.GT.PSCT(IE,I)) F3=-F3
*   Isotropic scattering
       ELSE
            R3=drand48(RDUM)
            F3=1.0D0-2.0D0*R3
       ENDIF
       THETA0=ACOS(F3)
*   Obtain phi
       R4=drand48(RDUM)
       PHI0=F4*R4
*   Work out the new direction
       F8=SIN(PHI0)
       F9=COS(PHI0)
       ARG1=1.0D0-S1*EI/E
       ARG1=MAX(ARG1,SMALL)
       D=1.0D0-F3*SQRT(ARG1)
       E1=E*(1.0D0-EI/(S1*E)-2.0D0*D/S2)
       E1=MAX(E1,SMALL)
       Q=SQRT((E/E1)*ARG1)/S1
       Q=MIN(Q,1.0D0)
       THETA=ASIN(Q*SIN(THETA0))
       F6=COS(THETA)
       U=(S1-1.0D0)*(S1-1.0D0)/ARG1
       CSQD=F3*F3
       IF(F3.LT.0.0D0.AND.CSQD.GT.U) F6=-1.0D0*F6
       F5=SIN(THETA)
       DCZ2=MIN(DCZ2,1.0D0)
       ARGZ=SQRT(DCX2*DCX2+DCY2*DCY2)
       IF(ARGZ.EQ.0.0D0) THEN
            IF(LBMCPR)WRITE(LUNOUT,9232) J1,E1
9232        FORMAT(3X,'WARNING ARGZ= 0.0 AT J1 =',I10,' E1=',E12.3)
            DCZ1=F6
            DCX1=F9*F5
            DCY1=F8*F5
       ELSE
            DCZ1=DCZ2*F6+ARGZ*F5*F8
            DCY1=DCY2*F6+(F5/ARGZ)*(DCX2*F9-DCY2*DCZ2*F8)
            DCX1=DCX2*F6-(F5/ARGZ)*(DCY2*F9+DCX2*DCZ2*F8)
       ENDIF
  210  CONTINUE
*** Should not reach this point.
       PRINT *,' !!!!!! DLCMSA WARNING : Should not reach end of'//
     -      ' loop - please report.'
       IFAIL=0
       END
      SUBROUTINE DLCMIR(X1,Y1,Z1,ES,EF,NSTATL,NSTATN)
*-----------------------------------------------------------------------
*   DLCMIR - Microscopic MC tracking, minimal variation on MONTE
*   (Last changed on 25/ 3/08.)
*-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
       DOUBLE PRECISION PIR2,ECHARG,EMASS,AMU,BOLTZ,BOLTZJ,
     -      AWB,ALOSCH,ABZERO,ATMOS
       PARAMETER(PIR2=8.79735534D-17)
       PARAMETER(ECHARG=1.602176462D-19)
       PARAMETER(EMASS=9.10938188D-31)
       PARAMETER(AMU=1.66053873D-27)
       PARAMETER(BOLTZ=8.617342D-5)
       PARAMETER(BOLTZJ=1.3806503D-23)
       PARAMETER(AWB=1.758820174D10)
       PARAMETER(ALOSCH=2.6867775D19)
       PARAMETER(ABZERO=273.15D0)
       PARAMETER(ATMOS=760.0D0)
       DOUBLE PRECISION CONST1,CONST2,CONST3,CONST4,CONST5
       COMMON/CNSTS1/CONST1,CONST2,CONST3,CONST4,CONST5
       DOUBLE PRECISION TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX,RSTART,
     -      EMAG
       INTEGER NMAX
       COMMON/SETP/TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX(8),RSTART,
     -      EMAG,NMAX
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
*   Is in effect the old ANCT common.
       DOUBLE PRECISION PSCT,ANGCT
       INTEGER INDEX,NISO
       COMMON/ANIS/PSCT(2048,512),ANGCT(2048,512),INDEX(512),NISO
       DOUBLE PRECISION ALPHA,ATT
       COMMON /CTOWNS/ ALPHA,ATT
       DOUBLE PRECISION ALPER,ATTER
       COMMON /CTWNER/ ALPER,ATTER
       DOUBLE PRECISION DXXER,DYYER,DZZER,DYZER,DXYER,DXZER
       COMMON /DIFERB/ DXXER,DYYER,DZZER,DYZER,DXYER,DXZER
       DOUBLE PRECISION DFLER,DFTER
       COMMON /DIFERL/ DFLER,DFTER
       DOUBLE PRECISION DIFXX,DIFYY,DIFZZ,DIFYZ,DIFXY,DIFXZ
       COMMON /DIFLAB/ DIFXX,DIFYY,DIFZZ,DIFYZ,DIFXY,DIFXZ
       DOUBLE PRECISION DIFLN,DIFTR
       COMMON /DIFVEL/ DIFLN,DIFTR
       DOUBLE PRECISION WX,WY,WZ
       COMMON /VEL/ WX,WY,WZ
       DOUBLE PRECISION DWX,DWY,DWZ
       COMMON /VELERR/ DWX,DWY,DWZ
       DOUBLE PRECISION CON
       INTEGER ITHRM
       COMMON /THRM/ CON,ITHRM
*   Adjusted size of ICOLL
       DOUBLE PRECISION TIME,SPEC,TMAX1,AVE,DEN,XID,X,Y,Z,ST
       INTEGER ICOLL,NNULL,ICOLN
       COMMON/OUTPT/TIME(300),ICOLL(5*mxngas),SPEC(2048),TMAX1,
     -      AVE,DEN,XID,X,Y,Z,ST,NNULL,ICOLN(512)
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       INTEGER MXWIRE,MXSW,MXLIST,MXCHA,MXGRID,MXMATT,MXPOLE,MX3D,
     -         MXPSTR,
     -         MXPAIR,MXPART,MXFOUR,MXCLUS,
     -         MXLINE,MXEQUT,
     -         MXRECL,MXINCH,MXWORD,MXCHAR,MXNAME,MXLUN,
     -         MXINS,MXREG,MXARG,MXCONS,MXVAR,MXALGE,
     -         MXZERO,MXSTCK,MXFPNT,MXFPAR,MXWKLS,
     -         MXHLEV,MXHLRL,MXSUBT,
     -         MXDLVL,MXILVL,MXDLIN,
     -         MXHIST,MXFRAC,MXBANG,MXBTAB,
     -         MXEXG,MXIOG,MXCSG,
     -         MXORIA,
     -         MXMAT,MXEMAT,MXMDIM,
     -         MXSHOT,MXZPAR,
     -         MXMAP,MXEPS,MXWMAP,MXSOLI,MXSBUF,
     -         MXPLAN,MXPOIN,MXEDGE,
     -         MXMCA
       PARAMETER (MXWIRE=  2000,MXSW  =  200)
       PARAMETER (MXMATT=    10)
       PARAMETER (MX3D  =   100)
       PARAMETER (MXPOLE=    10)
       PARAMETER (MXPSTR=   100)
       PARAMETER (MXLIST=  1000)
       PARAMETER (MXHIST=   200, MXCHA = MXLIST/2)
       PARAMETER (MXGRID=    50)
       PARAMETER (MXNAME=   200, MXLUN =    30)
       PARAMETER (MXCLUS=   500, MXPAIR=  2000, MXPART= 10000)
       PARAMETER (MXLINE=   150, MXEQUT=    50)
       PARAMETER (MXFOUR=    16)
       PARAMETER (MXRECL= 10000)
       PARAMETER (MXINCH=  2000, MXWORD=   200, MXCHAR=MXINCH)
       PARAMETER (MXINS =  1000, MXREG =   500, MXCONS=  -500,
     -            MXVAR =   500, MXALGE=   500, MXARG =   100)
       PARAMETER (MXMAT =   500, MXEMAT=200000, MXMDIM=   10)
       PARAMETER (MXZERO=MXWIRE)
       PARAMETER (MXSTCK=     5)
       PARAMETER (MXFPNT= 20000, MXFPAR=    10)
       PARAMETER (MXWKLS=    10)
       PARAMETER (MXHLEV=     9, MXSUBT=   200, MXHLRL=  860)
       PARAMETER (MXDLVL=    10, MXILVL=    20, MXDLIN= 2500)
       PARAMETER (MXFRAC=    13)
       PARAMETER (MXBANG=    20, MXBTAB=    25)
       PARAMETER (MXEXG =    50, MXIOG =    10, MXCSG =  200)
       PARAMETER (MXORIA=  1000)
       PARAMETER (MXSHOT=    10, MXZPAR=4*MXSHOT+2)
       PARAMETER (MXMAP =350000,MXEPS =   10)
       PARAMETER (MXWMAP=     5)
       PARAMETER (MXSOLI=  1000)
       PARAMETER (MXPLAN= 50000, MXPOIN=100000,MXEDGE=100)
       PARAMETER (MXSBUF= 20000)
       PARAMETER (MXMCA = 50000)
*   The parameter MXNBMC must equal MXGNAM (sequence MAGBPARM) !
       INTEGER MXNBMC
       PARAMETER(MXNBMC=60)
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION XU,YU,ZU,TU,XTARG,YTARG,TMC,DMC
       REAL DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,DTARG,EPSDFI,EPSTWI,
     -      EPSATI,RDF2,DSCMIN,DSCMAX,DTFACT,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,EPSDIF,RTRAP,
     -      STMAX,EQTTHR,EQTASP,EQTCLS,QPCHAR
       INTEGER NU,ISTAT,ITARG,MXDIFS,MXTWNS,MXATTS,MDF2,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,
     -      IPTYPE,IPTECH
       LOGICAL LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
       COMMON /DRFDAT/ XU(MXLIST),YU(MXLIST),ZU(MXLIST),TU(MXLIST),
     -      XTARG,YTARG,TMC,DMC,DTARG,
     -      DXMIN,DYMIN,DZMIN,DXMAX,DYMAX,DZMAX,
     -      DDXMIN,DDXMAX,DDYMIN,DDYMAX,DDZMIN,DDZMAX,
     -      EQTTHR,EQTASP,EQTCLS,QPCHAR,
     -      RTRAP,STMAX,EPSDIF,EPSDFI,EPSTWI,EPSATI,RDF2,DSCMIN,DSCMAX,
     -      DTFACT,MDF2,
     -      MXDIFS,MXTWNS,MXATTS,
     -      NU,ISTAT,ITARG,
     -      ISTAT1,ISTAT2,ISTAT3,ISTAT4,ISTAT5,ISTAT6,NMC,MCMETH,IPTYPE,
     -      IPTECH,LREPSK,LKINK,LSTMAX,LEQSRT,LEQCRS,LEQMRK,LAVPRO
      REAL QCHARGE
      DIMENSION XST(100000),YST(100000),ZST(100000),STO(100000)
      DIMENSION WZST(10),AVEST(10)
      DIMENSION DFZZST(10),DFYYST(10),DFXXST(10)
      real X1,Y1,Z1,ES,EF
      integer ifail,NSTATL(5*MXNGAS),NSTATN(512)
*** Initialise the gas
       call dlcmii(ef,NSTATL,NSTATN,ifail)
       lbmcpr=.true.
*** Initialise the steps
       NU=1
       XU(NU)=X1
       YU(NU)=Y1
       ZU(NU)=Z1
       TU(NU)=0
*** Set technique and particle labels
       IPTYPE=1
       QPCHAR=QCHARGE
       IPTECH=4
C -------------------------------------------------------------------
C   CALCULATES COLLISION EVENTS AND UPDATES DIFFUSION AND VELOCITY.
C   USED WITH MAGNETIC FIELD B =0.0   ELECTRIC FIELD IN Z DIRECTION.
C -------------------------------------------------------------------
      WX=0.0D0
      WY=0.0D0
      DWX=0.0D0
      DWY=0.0D0
      DIFYZ=0.0D0
      DIFXY=0.0D0
      DIFXZ=0.0D0
      DYZER=0.0D0
      DXYER=0.0D0
      DXZER=0.0D0
      X=x1
      Y=y1
      Z=z1
      ST=0.0D0
      ST1=0.0D0
      ST2=0.0D0
      SUME2=0.0D0
      SUMXX=0.0D0
      SUMYY=0.0D0
      SUMZZ=0.0D0
      SUMVX=0.0D0
      SUMVY=0.0D0
      ZOLD=0.0D0
      STOLD=0.0D0
      ST1OLD=0.0D0
      ST2OLD=0.0D0
      SZZOLD=0.0D0
      SXXOLD=0.0D0
      SYYOLD=0.0D0
      SVXOLD=0.0D0
      SVYOLD=0.0D0
      SME2OLD=0.0D0
      SMALL=1.0D-20
      TMAX1=0.0D0
      RDUM=RSTART
      E1=ESTART
      CONST9=CONST3*0.01D0
      ARAT=EMASS/AMU
      INTEM=8
      ITMAX=10
      ID=0
      NCOL=0
      NNULL=0
C  NUMBER OF COLLISIONS FOR DE-CORRELATION
      NCOLM=100000
      TDASH=0.0D0
C
C     INITIAL DIRECTION COSINES
C
      DCZ1=COS(THETA)
      DCX1=SIN(THETA)*COS(PHI)
      DCY1=SIN(THETA)*SIN(PHI)
C
      BP=EMAG*EMAG*CONST1
      F1=EMAG*CONST2
      F2=EMAG*CONST3
      F4=2.0D0*ACOS(-1.0D0)
      DELTAE=EFINAL/DBLE(INTEM)
      J2M=NMAX/ITMAX
C MAIN LOOP
      DO 210 J1=1,1
      DO 133 J2=1,10000000
    1 R1=drand48(RDUM)
      I=INT(E1/DELTAE)+1
      I=MIN(I,INTEM)
      TLIM=TCFMAX(I)
      T=-LOG(R1)/TLIM+TDASH
      TDASH=T
      AP=DCZ1*F2*SQRT(E1)
      E=E1+(AP+BP*T)*T
      IE=INT(E/ESTEP)+1
      IE=MIN(IE,2048)
      IF(TCF(IE).GT.TLIM) THEN
       TDASH=TDASH+LOG(R1)/TLIM
       TCFMAX(I)=1.05D0*TCFMAX(I)
      if(lbmcpr)WRITE(lunout,996)
996   FORMAT(/,5X,' WARNING NULL COLLISION TIME INCREASED',/)
       GO TO 1
      ENDIF
C
C     TEST FOR REAL OR NULL COLLISION
C
      R5=drand48(RDUM)
      TLIM=TCF(IE)/TLIM
      IF(R5.GT.TLIM) THEN
       NNULL=NNULL+1
       GO TO 1
      ENDIF
C
C  CALCULATE DIRECTION COSINES AND POSITIONS AT INSTANT BEFORE COLLISION
C    ALSO UPDATE DIFFUSION  AND ENERGY CALCULATIONS.
      T2=T*T
      IF(T.GE.TMAX1) TMAX1=T
      TDASH=0.0D0
      CONST6=SQRT(E1/E)
      DCX2=DCX1*CONST6
      DCY2=DCY1*CONST6
      DCZ2=DCZ1*CONST6+EMAG*T*CONST5/SQRT(E)
      A=AP*T
      B=BP*T2
      SUME2=SUME2+T*(E1+A/2.0D0+B/3.0D0)
      CONST7=CONST9*SQRT(E1)
      A=T*CONST7
      NCOL=NCOL+1
      CX1=DCX1*CONST7
      CY1=DCY1*CONST7
      CZ1=DCZ1*CONST7
      X=X+DCX1*A
      Y=Y+DCY1*A
      Z=Z+DCZ1*A+T2*F1
      ST=ST+T
      IT=INT(T+1.0)
      IT=MIN(IT,300)
      TIME(IT)=TIME(IT)+1.0D0
      SPEC(IE)=SPEC(IE)+1.0D0
      WZ=Z/ST
      SUMVX=SUMVX+CX1*CX1*T2
      SUMVY=SUMVY+CY1*CY1*T2
      IF(ID.EQ.0) GO TO 121
      KDUM=0
      DO 120 JDUM=1,4
      ST2=ST2+T
      NCOLDM=NCOL+KDUM
      IF(NCOLDM.GT.NCOLM) NCOLDM=NCOLDM-NCOLM
      SDIF=ST-STO(NCOLDM)
      SUMXX=SUMXX+((X-XST(NCOLDM))**2)*T/SDIF
      SUMYY=SUMYY+((Y-YST(NCOLDM))**2)*T/SDIF
      IF(J1.LT.3) GO TO 120
      ST1=ST1+T
      SUMZZ=SUMZZ+((Z-ZST(NCOLDM)-WZ*SDIF)**2)*T/SDIF
  120 KDUM=KDUM+12500
  121 continue
C      XST(NCOL)=X
C      YST(NCOL)=Y
C      ZST(NCOL)=Z
C      STO(NCOL)=ST
C      IF(NCOL.GE.NCOLM) THEN
C       ID=ID+1
C       XID=DBLE(ID)
C       NCOL=0
C      ENDIF
*** Add new point
       IF(Z*1.0D2.GT.1)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 RETURN
            ENDIF
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
            ISTAT=-1
            RETURN
       ELSEIF(NMC*(NCOL/NMC).EQ.NCOL)THEN
            IF(NU.GE.MXLIST)THEN
                 ISTAT=-2
                 RETURN
            ENDIF
            NU=NU+1
            XU(NU)=X*1.0D2
            YU(NU)=Y*1.0D2
            ZU(NU)=Z*1.0D2
            TU(NU)=ST*1.0D-6
       ENDIF
C ---------------------------------------------------------------------
C     DETERMINATION OF REAL COLLISION TYPE
C ---------------------------------------------------------------------
      R2=drand48(RDUM)
C FIND LOCATION WITHIN 4 UNITS IN COLLISION ARRAY
      CALL SORT(I,R2,IE)
  140 I=I+1
      IF(CF(IE,I).LT.R2) GO TO 140
      S1=RGAS(I)
      EI=EIN(I)
      IF(IPN(I).LE.0) GO TO 666
C  USE FLAT DISTRIBUTION OF  ELECTRON ENERGY BETWEEN E-EION AND 0.0 EV
C  SAME AS IN BOLTZMANN
      R9=drand48(RDUM)
      EXTRA=R9*(E-EI)
      EI=EXTRA+EI
C
C  GENERATE SCATTERING ANGLES AND UPDATE  LABORATORY COSINES AFTER
C   COLLISION ALSO UPDATE ENERGY OF ELECTRON.
C
  666 IPT=IARRY(I)
      ICOLL(IPT)=ICOLL(IPT)+1
      ICOLN(I)=ICOLN(I)+1
      IF(E.LT.EI) THEN
      if(lbmcpr)WRITE(lunout,994) E,EI,J2
 994  FORMAT(2X,' WARNING ENERGY =',F8.3,' LESS THAN ENERGY LOSS EI=',F8
     /.3,' AT ITER=',I12,' DUE TO BINNING ERROR')
C  FIX ENERGY LOSS SMALLER THAN INCIDENT ENERGY IF ERROR OCCURS
       EI=E-0.0001D0
      ENDIF
      S2=(S1*S1)/(S1-1.0D0)
C  ANISOTROPIC SCATTERING
      IF(INDEX(I).NE.0) THEN
       R31=drand48(RDUM)
       R3=drand48(RDUM)
       F3=1.0D0-R3*ANGCT(IE,I)
       IF(R31.GT.PSCT(IE,I)) F3=-F3
      ELSE
C ISOTROPIC  SCATTERING
       R3=drand48(RDUM)
       F3=1.0D0-2.0D0*R3
      ENDIF
      THETA0=ACOS(F3)
      R4=drand48(RDUM)
      PHI0=F4*R4
      F8=SIN(PHI0)
      F9=COS(PHI0)
      ARG1=1.0D0-S1*EI/E
      ARG1=MAX(ARG1,SMALL)
      D=1.0D0-F3*SQRT(ARG1)
      E1=E*(1.0D0-EI/(S1*E)-2.0D0*D/S2)
      E1=MAX(E1,SMALL)
      Q=SQRT((E/E1)*ARG1)/S1
      Q=MIN(Q,1.0D0)
      THETA=ASIN(Q*SIN(THETA0))
      F6=COS(THETA)
      U=(S1-1.0D0)*(S1-1.0D0)/ARG1
      CSQD=F3*F3
      IF(F3.LT.0.0D0.AND.CSQD.GT.U) F6=-1.0D0*F6
      F5=SIN(THETA)
      DCZ2=MIN(DCZ2,1.0D0)
      ARGZ=SQRT(DCX2*DCX2+DCY2*DCY2)
      IF(ARGZ.EQ.0.0D0) THEN
      if(lbmcpr)WRITE(lunout,9232) ITER,ID,E1
 9232  FORMAT(3X,'WARNING ARGZ= 0.0 AT ITER =',I10,' ID =',I10,' E1=',E1
     /2.3)
       DCZ1=F6
       DCX1=F9*F5
       DCY1=F8*F5
       GO TO 130
      ENDIF
      DCZ1=DCZ2*F6+ARGZ*F5*F8
      DCY1=DCY2*F6+(F5/ARGZ)*(DCX2*F9-DCY2*DCZ2*F8)
      DCX1=DCX2*F6-(F5/ARGZ)*(DCY2*F9+DCX2*DCZ2*F8)
  130 CONTINUE
  133 CONTINUE
C   ------------------------------------------
      IF(J1.EQ.1.and.lbmcpr) WRITE(lunout,201)
  201 FORMAT(/,'    VEL      POS        TIME      ENERGY   COUNT   DIFXX
     /     DIFYY     DIFZZ',/)
      WZ=WZ*1.0D+09
      AVE=SUME2/ST
      DIFLN=0.0D0
      IF(NISO.EQ.0) THEN
       DIFXX=5.0D+15*SUMVX/ST
       DIFYY=5.0D+15*SUMVY/ST
       DFXXST(J1)=5.0D+15*(SUMVX-SVXOLD)/(ST-STOLD)
       DFYYST(J1)=5.0D+15*(SUMVY-SVYOLD)/(ST-STOLD)
      ELSE
       IF(ST2.NE.0.0D0) THEN
        DIFYY=5.0D+15*SUMYY/ST2
        DIFXX=5.0D+15*SUMXX/ST2
        DFXXST(J1)=5.0D+15*(SUMXX-SXXOLD)/(ST2-ST2OLD)
        DFYYST(J1)=5.0D+15*(SUMYY-SYYOLD)/(ST2-ST2OLD)
       ELSE
        DFXXST(J1)=0.0D0
        DFYYST(J1)=0.0D0
       ENDIF
      ENDIF
      IF(ST1.NE.0.0D0) THEN
       DIFZZ=5.0D+15*SUMZZ/ST1
       DFZZST(J1)=5.0D+15*(SUMZZ-SZZOLD)/(ST1-ST1OLD)
      ELSE
       DFZZST(J1)=0.0D0
      ENDIF
      WZST(J1)=(Z-ZOLD)/(ST-STOLD)*1.0D+09
      AVEST(J1)=(SUME2-SME2OLD)/(ST-STOLD)
      ZOLD=Z
      STOLD=ST
      ST1OLD=ST1
      ST2OLD=ST2
      SVXOLD=SUMVX
      SVYOLD=SUMVY
      SZZOLD=SUMZZ
      SXXOLD=SUMXX
      SYYOLD=SUMYY
      SME2OLD=SUME2
      if(lbmcpr)WRITE(lunout,202) WZ,Z,ST,AVE,ID,DIFXX,DIFYY,DIFZZ
  202 FORMAT(1X,F8.2,2(1X,D10.3),F9.4,1X,I5,1X,3(2X,F8.1))
C LOOP
  210 CONTINUE
C CALCULATE ERRORS AND CHECK AVERAGES
      TWZST=0.0D0
      TAVE=0.0D0
      T2WZST=0.0D0
      T2AVE=0.0D0
      TZZST=0.0D0
      TYYST=0.0D0
      TXXST=0.0D0
      T2ZZST=0.0D0
      T2YYST=0.0D0
      T2XXST=0.0D0
      DO 768 K=1,10
      TWZST=TWZST+WZST(K)
      TAVE=TAVE+AVEST(K)
      T2WZST=T2WZST+WZST(K)*WZST(K)
      T2AVE=T2AVE+AVEST(K)*AVEST(K)
      TXXST=TXXST+DFXXST(K)
      TYYST=TYYST+DFYYST(K)
      T2YYST=T2YYST+DFYYST(K)*DFYYST(K)
      T2XXST=T2XXST+DFXXST(K)*DFXXST(K)
      IF(K.LT.3) GO TO 768
      TZZST=TZZST+DFZZST(K)
      T2ZZST=T2ZZST+DFZZST(K)*DFZZST(K)
  768 CONTINUE
      DWZ=100.0D0*SQRT((T2WZST-TWZST*TWZST/10.0D0)/9.0D0)/WZ
      DEN=100.0D0*SQRT((T2AVE-TAVE*TAVE/10.0D0)/9.0D0)/AVE
      DXXER=100.0D0*SQRT((T2XXST-TXXST*TXXST/10.0D0)/9.0D0)/DIFXX
      DYYER=100.0D0*SQRT((T2YYST-TYYST*TYYST/10.0D0)/9.0D0)/DIFYY
      DZZER=100.0D0*SQRT((T2ZZST-TZZST*TZZST/8.0D0)/7.0D0)/DIFZZ
      DIFLN=DIFZZ
      DIFTR=(DIFXX+DIFYY)/2.0D0
C  CONVERT CM/SEC
      WZ=WZ*1.0D05
      DFLER=DZZER
      DFTER=(DXXER+DYYER)/2.0D0
C CALCULATE TOWNSEND COEFICIENTS AND ERRORS
      ANCATT=0.0D0
      ANCION=0.0D0
      DO 800 I=1,NGAS
      ANCATT=ANCATT+ICOLL((5*I)-2)
  800 ANCION=ANCION+ICOLL((5*I)-3)
      ATTER=0.0D0
      IF(ANCATT.EQ.0.0D0) GO TO 810
      ATTER=100.0D0*SQRT(ANCATT)/ANCATT
  810 ATT=ANCATT/(ST*WZ)*1.0D12
      ALPER=0.0D0
      IF(ANCION.EQ.0.0D0) GO TO 820
      ALPER=100.0D0*SQRT(ANCION)/ANCION
  820 ALPHA=ANCION/(ST*WZ)*1.0D12
      END
CDECK  ID>, MONTEFD.
      SUBROUTINE MONTEFD(IFAIL)
*-----------------------------------------------------------------------
*   MONTEFD - Calculates collision events and updates diffusion and
*             velocity. this routine handles terminations at fixed
*             drift distances.
*   Author: Steve Biagi, with modifications.
*   (Last changed on 16/ 3/08.)
*-----------------------------------------------------------------------
       implicit none
*   Array dimensions.
       integer mxngas
       parameter(mxngas=6)
       INTEGER NGAS,NSTEP,IDBG
       DOUBLE PRECISION EFINAL,ESTEP,AKT,ARY,TEMPC,TORR
       PARAMETER(ARY=13.60569172)
       COMMON/INPT/NGAS,NSTEP,EFINAL,ESTEP,AKT,TEMPC,TORR,IDBG
       DOUBLE PRECISION CONST1,CONST2,CONST3,CONST4,CONST5
       COMMON/CNSTS1/CONST1,CONST2,CONST3,CONST4,CONST5
       DOUBLE PRECISION TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX,RSTART,
     -      EMAG
       INTEGER NMAX
       COMMON/SETP/TMAX,SMALL,API,ESTART,THETA,PHI,TCFMAX(8),RSTART,
     -      EMAG,NMAX
*   Sometimes IPLAST is called LAST
       DOUBLE PRECISION CF,EIN,TCF,RGAS,WPL
       INTEGER IARRY,IPN,IPLAST,ISIZE
       COMMON/LARGE/CF(2048,512),EIN(512),TCF(2048),IARRY(512),
     -      RGAS(512),IPN(512),WPL(512),IPLAST,ISIZE
       DOUBLE PRECISION ALPHAST,VDST,TSTEP,ZSTEP,TFINAL,ZFINAL
       INTEGER ITFINAL,IPRIM
       COMMON/CION/ALPHAST,VDST,TSTEP,ZSTEP,TFINAL,ZFINAL,ITFINAL,IPRIM
*   Adjusted size of ICOLL
       DOUBLE PRECISION TIME,SPEC,TMAX1,AVE,DEN,XID,X,Y,Z,ST
       INTEGER ICOLL,NNULL,ICOLN
       COMMON/OUTPT/TIME(300),ICOLL(5*mxngas),SPEC(2048),TMAX1,
     -      AVE,DEN,XID,X,Y,Z,ST,NNULL,ICOLN(512)
       DOUBLE PRECISION ZTOT,TTOT,ZTOTS,TTOTS
       COMMON/TTRM/ZTOT,TTOT,ZTOTS,TTOTS
       DOUBLE PRECISION XSS,YSS,ZSS,TSS,ESS,DCXS,DCYS,DCZS
       INTEGER IPLS
       COMMON/IPS/XSS(200),YSS(200),ZSS(200),TSS(200),ESS(200),
     -      DCXS(200),DCYS(200),DCZS(200),IPLS(200)
       DOUBLE PRECISION ESPL,XSPL,YSPL,ZSPL,TSPL,XXSPL,YYSPL,ZZSPL,
     -      VZSPL,TSSUM,TSSUM2,ATTOION,ATTIOER,ATTATER
       INTEGER NESST
       COMMON/SPLOUT/ESPL(8),XSPL(8),YSPL(8),ZSPL(8),TSPL(8),XXSPL(8),
     -      YYSPL(8),ZZSPL(8),VZSPL(8),TSSUM(8),TSSUM2(8),ATTOION,
     -      ATTIOER,ATTATER,NESST(9)
       DOUBLE PRECISION TMSPL,TTMSPL,RSPL,RRSPL,RRSPM
       COMMON/SPL1/TMSPL(8),TTMSPL(8),RSPL(8),RRSPL(8),RRSPM(8)
       DOUBLE PRECISION ZPLANE1,ZPLANE2,ZPLANE3,ZPLANE4,ZPLANE5,ZPLANE6,
     -      ZPLANE7,ZPLANE8
       INTEGER IZFINAL
       COMMON/CTCALC/ZPLANE1,ZPLANE2,ZPLANE3,ZPLANE4,ZPLANE5,ZPLANE6,
     -      ZPLANE7,ZPLANE8,IZFINAL
*   Is in effect the old ANCT common.
       DOUBLE PRECISION PSCT,ANGCT
       INTEGER INDEX,NISO
       COMMON/ANIS/PSCT(2048,512),ANGCT(2048,512),INDEX(512),NISO
*-----------------------------------------------------------------------
*   MAGPAR - Interface parameters for gas mixing with Magboltz.
*   (Last changed on  2/ 3/08.)
*-----------------------------------------------------------------------
       INTEGER MXGNAM
       PARAMETER(MXGNAM=60)
       DOUBLE PRECISION FRAMIX
       LOGICAL LF0PLT,LCSPLT,LGKEEP,LBMCPR
       COMMON /MAGPAR/ FRAMIX(MXGNAM),LF0PLT,LCSPLT,LGKEEP,LBMCPR
       LOGICAL         LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD
       INTEGER LUNOUT,JFAIL,JEXMEM
       COMMON /PRTPLT/ LINPUT,LCELPR,LCELPL,LWRMRK,LISOCL,LCHGCH,
     -         LDRPLT,LDRPRT,LCLPRT,LCLPLT,LMAPCH,LCNTAM,
     -         LDEBUG,LIDENT,LKEYPL,LRNDMI,LPROPR,LPROF,LGSTOP,LGSIG,
     -         LSYNCH,LINPRD,LUNOUT,JFAIL,JEXMEM
       DOUBLE PRECISION EPRM(4000000),DRAND48,S,RDUM,E1,AP,BP,E,EI,
     -      CONST6,CONST7,CONST9,CX1,CY1,CZ1,THETA0,PHI0,
     -      TLIM,TDASH,T,T2,TOLD,TLFT,TTEM,EPOT,TZSTOP,TZSTOP1,ESEC,
     -      F1,F2,F3,F4,F5,F6,F8,F9,R1,R2,R3,R4,R5,R9,R31,S1,S2,A,B,
     -      DCX1,DCY1,DCZ1,DCX100,DCY100,DCZ100,DCX2,DCY2,DCZ2,E100,
     -      ZSTRT,TSSTRT,ARG1,D,Q,U,CSQD,ARGZ,W,ANEION,ANBT,EPRMBAR,
     -      E2PRM,EBAR,EERR
       INTEGER IESPECP(100),I,ID,INTEM,I100,NCOL,NELEC,NEION,NMXADD,
     -      NPONT,NCLUS,J1,JPRINT,IPRINT,IDUM,ISOL,IE,IT,IPT,IDM1,
     -      ITER,IZPLANE,JCT,IFAIL
       EXTERNAL DRAND48
       logical lab18,lab20
*** Identify the routine if desired.
       IF(LIDENT)PRINT *,' /// ROUTINE MONTEFD ///'
*** This will usually work.
       IFAIL=0
*** Initialise
      S=0.0D0
      ST=0.0D0
      X=0.0D0
      Y=0.0D0
      Z=0.0D0
      ZTOT=0.0D0
      ZTOTS=0.0D0
      TTOT=0.0D0
      TTOTS=0.0D0
      SMALL=1.0D-20
      TMAX1=0.0D0
      RDUM=RSTART
      E1=ESTART
      CONST9=CONST3*0.01D0
      API=ACOS(-1.0D0)
      DO 25 I=1,300
   25 TIME(I)=0.0D0
      DO 26 I=1,5*mxngas
   26 ICOLL(I)=0
      DO 27 I=1,512
   27 ICOLN(I)=0
      DO 28 I=1,2048
   28 SPEC(I)=0.0D0
      DO 33 I=1,100
   33 IESPECP(I)=0
      DO 34 I=1,8
      ESPL(I)=0.0D0
      XSPL(I)=0.0D0
      YSPL(I)=0.0D0
      ZSPL(I)=0.0D0
      TSPL(I)=0.0D0
      XXSPL(I)=0.0D0
      YYSPL(I)=0.0D0
      ZZSPL(I)=0.0D0
      VZSPL(I)=0.0D0
      TSSUM(I)=0.0D0
      TSSUM2(I)=0.0D0
      TMSPL(I)=0.0D0
      TTMSPL(I)=0.0D0
      RSPL(I)=0.0D0
      RRSPL(I)=0.0D0
      RRSPM(I)=0.0D0
   34 NESST(I)=0
      NESST(9)=0
      ID=0
      INTEM=8
      I100=0
      NCOL=0
      NNULL=0
      NELEC=0
      NEION=0
      NMXADD=0
      NPONT=0
      NCLUS=0
      J1=1
      ZSTRT=0.0D0
      TSSTRT=0.0D0
*** Initial direction cosines
      DCZ1=COS(THETA)
      DCX1=SIN(THETA)*COS(PHI)
      DCY1=SIN(THETA)*SIN(PHI)
      DCX100=DCX1
      DCY100=DCY1
      DCZ100=DCZ1
      E100=E1
      BP=EMAG*EMAG*CONST1
      F1=EMAG*CONST2
      F2=EMAG*CONST3
      F4=2.0D0*API
*** Set to maximum possible collision freq.
      TLIM=TCFMAX(1)
      DO 35 I=2,INTEM
   35 IF(TLIM.LT.TCFMAX(I)) TLIM=TCFMAX(I)
      JPRINT=NMAX/10
      IPRINT=0
      ITER=0
      IPRIM=0
*** Loop for new starting electrons
 544  IPRIM=IPRIM+1
      if(ldebug)print *,' ++++++ MONTEFD DEBUG : New primary: ',IPRIM
      IZPLANE=0
      TZSTOP=1000.0D0
      IF(IPRIM.GT.1) THEN
*** Check if program will exceed maximum number of iterations in this
*   cycle , if so output current results.
           IF(ITER.GT.NMAX) THEN
                IPRIM=IPRIM-1
                GO TO 700
           ENDIF
           X=0.0D0
           Y=0.0D0
           Z=0.0D0
           DCZ1=DCZ100
           DCX1=DCX100
           DCY1=DCY100
           NCLUS=NCLUS+1
           E1=E100
           ST=0.0D0
           ZSTRT=0.0D0
           TSSTRT=0.0D0
      ENDIF
      IF(IPRIM.GT.4000000) THEN
          IF(LBMCPR)WRITE(LUNOUT,944) IPRIM
  944     FORMAT(2X,' PROGRAM STOPPED TOO MANY PRIMARIES IPRIM=',I7)
          IFAIL=1
           PRINT *,' !!!!!! MONTEFD WARNING: Attachment too high;'//
     -          ' unable to compute transport parameters.'
          RETURN
C          STOP
      ENDIF
      EPRM(IPRIM)=E1
      IDUM=INT(E1)+1
      IDUM=MIN(IDUM,100)
      IESPECP(IDUM)=IESPECP(IDUM)+1
*** Start of loop for newly created electrons .
 555  TDASH=0.0D0
      NELEC=NELEC+1
*** Main loop
    1 CONTINUE
C      if(100000*(iter/100000).eq.iter)print *,' Iter = ',iter
C     IF(ITER.GT.NMAX)  GO TO 315
      R1=drand48(RDUM)
      T=-LOG(R1)/TLIM+TDASH
      TOLD=TDASH
      TDASH=T
      AP=DCZ1*F2*SQRT(E1)
      lab18=.false.
      lab20=.false.
   15 continue
      IF((T.GE.TZSTOP.AND.TOLD.LT.TZSTOP) .or. lab18 .or. lab20) THEN
           if((.not.lab18) .and. (.not.lab20))then
                TLFT=TZSTOP
*** Store position and energy at z plane = IZPLANE.
                CALL SPLANE(T,E1,DCX1,DCY1,DCZ1,AP,BP,EMAG,TLFT,
     -               IZPLANE)
           endif
*   Change  IF statement from (IZFINAL+1) to (IZFINAL-1)
*   for anode termination .
           IF(IZPLANE.GE.(IZFINAL+1) .or. lab18 .or. lab20) THEN
  18            continue
                lab18=.false.
                if(.not.lab20)then
                     ZTOT=ZTOT+Z
                     TTOT=TTOT+ST
                     ZTOTS=ZTOTS+Z-ZSTRT
                     TTOTS=TTOTS+ST-TSSTRT
*   No more electrons in cascade return to main.
                     IF(NELEC.EQ.(NCLUS+1)) GO TO 544
                endif
*   Take electrons from store
C  20           continue
                lab20=.false.
                X=XSS(NPONT)
                Y=YSS(NPONT)
                Z=ZSS(NPONT)
                ST=TSS(NPONT)
                E1=ESS(NPONT)
                DCX1=DCXS(NPONT)
                DCY1=DCYS(NPONT)
                DCZ1=DCZS(NPONT)
                IZPLANE=IPLS(NPONT)
                NPONT=NPONT-1
                ZSTRT=Z
                TSSTRT=ST
                IF(Z.GT.ZFINAL) THEN
*   Check if electron has enough energy to go back to final plane
                     EPOT=EMAG*(Z-ZFINAL)*100.0D0
                     IF(E1.LT.EPOT) THEN
                          NELEC=NELEC+1
                          ISOL=1
                          GO TO 18
                     ENDIF
                ENDIF
                CALL TCALC(Z,DCZ1,E1,EMAG,TZSTOP,TZSTOP1,ISOL,
     -               IZPLANE)
                IF(TZSTOP.EQ.-99.0D0) THEN
*   Catch runaway electrons at high field
                     NELEC=NELEC+1
                     ISOL=1
                     GO TO 18
                ENDIF
                GO TO 555
           ENDIF
*   If two solutions repeat entry for second solution.
           IF(ISOL.EQ.2) THEN
                TZSTOP=TZSTOP1
                ISOL=1
                GO TO 15
           ENDIF
      ENDIF
      E=E1+(AP+BP*T)*T
      IF(E.LT.0.0D0) THEN
            IF(LBMCPR)WRITE(LUNOUT,999) E,E1,AP,BP,T,DCZ1,ITER
 999        FORMAT(2X,' WARNING ENERGY LT.0. E=',D12.3,' E1=',D12.3,
     -           ' AP=',D12.3,' BP=',D12.3,' T=',D12.3,/,' DCZ1=',D12.3,
     -           ' ITER=',I10)
            E=0.001D0
      ENDIF
      IE=INT(E/ESTEP)+1
      IE=MIN(IE,2048)
*** Test for real or null collision
      R5=drand48(RDUM)
      TTEM=TCF(IE)/TLIM
      IF(R5.LE.TTEM)GO TO 137
      NNULL=NNULL+1
      GO TO 1
*** Calculate direction cosines and positions at instant before
*   collision also update diffusion  and energy calculations.
  137 T2=T*T
      IF(T.GE.TMAX1) TMAX1=T
      TDASH=0.0D0
      CONST6=SQRT(E1/E)
      DCX2=DCX1*CONST6
      DCY2=DCY1*CONST6
      DCZ2=DCZ1*CONST6+EMAG*T*CONST5/SQRT(E)
      A=AP*T
      B=BP*T2
      CONST7=CONST9*SQRT(E1)
      A=T*CONST7
      NCOL=NCOL+1
      CZ1=DCZ1*CONST7
      X=X+DCX1*A
      Y=Y+DCY1*A
      Z=Z+DCZ1*A+T2*F1
      ST=ST+T
      IT=INT(T+1.0D0)
      IT=MIN(IT,300)
      TIME(IT)=TIME(IT)+1.0D0
      CX1=DCX1*CONST7
      CY1=DCY1*CONST7
      SPEC(IE)=SPEC(IE)+1.0D0
*** Determination of real collision type
      R2=drand48(RDUM)
*   Find location within 4 units in collision array
      CALL SORT(I,R2,IE)
  140 I=I+1
      IF(CF(IE,I).LT.R2) GO TO 140
      S1=RGAS(I)
      EI=EIN(I)
      IF(E.LT.EI) THEN
*** Fix energy loss smaller than incident energy if a bining error
*   occurs.
C          IF(LBMCPR)WRITE(LUNOUT,994) E,EI,ITER
C994       FORMAT(3X,' WARNING BINNING ERROR ENERGY =',F8.3,' EI=',
C    -          F8.3,' ITER =',I12)
           EI=E-0.0001D0
      ENDIF
      IF(IPN(I).EQ.0) GO TO 666
*   Attachment
      IF(IPN(I).EQ.-1) THEN
           NEION=NEION+1
           IPT=IARRY(I)
           ID=ID+1
           ITER=ITER+1
           IF(ITER.LT.0)GOTO 315
           IPRINT=IPRINT+1
           ICOLL(IPT)=ICOLL(IPT)+1
           ICOLN(I)=ICOLN(I)+1
           IT=INT(T+1.0D0)
           IT=MIN(IT,300)
           TIME(IT)=TIME(IT)+1.0D0
           ZTOT=ZTOT+Z
           TTOT=TTOT+ST
           ZTOTS=ZTOTS+Z-ZSTRT
           TTOTS=TTOTS+ST-TSSTRT
           IDM1=1+INT(Z/ZSTEP)
           IF(IDM1.GT.9) IDM1=9
*   Next line added to avoid IDM1=0 (RV 6/11/2007).
           IF(IDM1.LT.1) IDM1=1
*   End of modification.
           NESST(IDM1)=NESST(IDM1)-1
*   Electron captured start new primary
           IF(NELEC.EQ.(NCLUS+1)) GO TO 544
*   Electron captured take next electron from store
C           GO TO 20
           lab20=.true.
           goto 15
      ENDIF
      R9=drand48(RDUM)
C     ESEC=R9*(E-EI)
*** Use OPAL Peterson and Beaty splitting factor.
      ESEC=WPL(I)*TAN(R9*ATAN((E-EI)/(2.0D0*WPL(I))))
      EI=ESEC+EI
*** Store position ,energy, direction cosines and time of generation
*   of ionisation electron
      NCLUS=NCLUS+1
      NPONT=NPONT+1
      NMXADD=MAX(NPONT,NMXADD)
      IF(NPONT.GT.200) THEN
           IF(LBMCPR)WRITE(LUNOUT,546) NPONT,ITER
 546       FORMAT(2X,' PROGRAM STOPPED NPONT=',I3,' ITER=',I10)
           IFAIL=1
           RETURN
C           STOP
      ENDIF
      XSS(NPONT)=X
      YSS(NPONT)=Y
      ZSS(NPONT)=Z
      TSS(NPONT)=ST
      ESS(NPONT)=ESEC
*   Randomise secondary electron direction
      R3=drand48(RDUM)
      F3=1.0D0-2.0D0*R3
      THETA0=ACOS(F3)
      F6=COS(THETA0)
      F5=SIN(THETA0)
      R4=drand48(RDUM)
      PHI0=F4*R4
      F8=SIN(PHI0)
      F9=COS(PHI0)
      DCXS(NPONT)=F9*F5
      DCYS(NPONT)=F8*F5
      DCZS(NPONT)=F6
      IDM1=1+INT(Z/ZSTEP)
      IF(IDM1.GT.9) IDM1=9
*   Next line added to avoid IDM1=0 (RV 23/11/2007).
      IF(IDM1.LT.1) IDM1=1
*   End of modification.
      IPLS(NPONT)=IDM1
      NESST(IPLS(NPONT))=NESST(IPLS(NPONT))+1
*** Generate scattering angles and update  laboratory cosines after
*   collision also update energy of electron.
  666 IPT=IARRY(I)
      ID=ID+1
      ITER=ITER+1
      IF(ITER.LT.0)GOTO 315
      IPRINT=IPRINT+1
      ICOLL(IPT)=ICOLL(IPT)+1
      ICOLN(I)=ICOLN(I)+1
      S2=(S1*S1)/(S1-1.0D0)
*   Anisotropic scattering
      IF(INDEX(I).NE.0) THEN
           R31=drand48(RDUM)
           R3=drand48(RDUM)
           F3=1.0D0-R3*ANGCT(IE,I)
           IF(R31.GT.PSCT(IE,I)) F3=-F3
      ELSE
*  Isotropic scattering
           R3=drand48(RDUM)
           F3=1.0D0-2.0D0*R3
      ENDIF
      THETA0=ACOS(F3)
      R4=drand48(RDUM)
      PHI0=F4*R4
      F8=SIN(PHI0)
      F9=COS(PHI0)
      IF(E.LT.EI) EI=0.0D0
      ARG1=1.0D0-S1*EI/E
      ARG1=MAX(ARG1,SMALL)
      D=1.0D0-F3*SQRT(ARG1)
      E1=E*(1.0D0-EI/(S1*E)-2.0D0*D/S2)
      E1=MAX(E1,SMALL)
      Q=SQRT((E/E1)*ARG1)/S1
      Q=MIN(Q,1.0D0)
      THETA=ASIN(Q*SIN(THETA0))
      F6=COS(THETA)
      U=(S1-1.0D0)*(S1-1.0D0)/ARG1
      CSQD=F3*F3
      IF(F3.LT.0.0D0.AND.CSQD.GT.U) F6=-1.0D0*F6
      F5=SIN(THETA)
      DCZ2=MIN(DCZ2,1.0D0)
      ARGZ=SQRT(DCX2*DCX2+DCY2*DCY2)
      IF(ARGZ.EQ.0.0D0) THEN
C          IF(LBMCPR)WRITE(LUNOUT,9232) ITER,ID,E1
C9232      FORMAT(3X,' WARNING ARGZ= 0.0  AT ITER =',I10,' ID=',I10,
C    -         ' E1=',E12.3)
           DCZ1=F6
           DCX1=F9*F5
           DCY1=F8*F5
           GO TO 190
      ENDIF
      DCZ1=DCZ2*F6+ARGZ*F5*F8
      DCY1=DCY2*F6+(F5/ARGZ)*(DCX2*F9-DCY2*DCZ2*F8)
      DCX1=DCX2*F6-(F5/ARGZ)*(DCY2*F9+DCX2*DCZ2*F8)
 190  CONTINUE
*** Store direction cosines and energy after N collisions
*   for later reuse in primary generation.
      I100=I100+1
      IF(I100.EQ.200) THEN
           DCZ100=DCZ1
           DCX100=DCX1
           DCY100=DCY1
           E100=E1
           I100=0
      ENDIF
      IF(Z.GT.ZFINAL) THEN
*   Check if electron has enough energy to go back to final plane.
           EPOT=EMAG*(Z-ZFINAL)*100.0D0
           IF(E1.LT.EPOT)then
C               GO TO 18
                lab18=.true.
                goto 15
           endif
      ENDIF
*   Calculate time tzstop to arrive at next z plane IZPLANE.
      CALL TCALC(Z,DCZ1,E1,EMAG,TZSTOP,TZSTOP1,ISOL,IZPLANE)
*   Catch runaway electrons at high field
      IF(TZSTOP.EQ.-99.0D0)then
C          GO TO 18
           lab18=.true.
           goto 15
      endif
      IF(IPRINT.GT.JPRINT) GO TO 200
      GO TO 1
*   Intermediate printout
 200  IPRINT=0
      W=ZTOTS/TTOTS
      W=W*1.0D+09
      XID=DBLE(ID)
      JCT=ID/100000
C     IF(J1.EQ.1 .and. LBMCPR)WRITE(LUNOUT,201)
C 201 FORMAT(/,7X,'INTERMEDIATE OUTPUT',/,'    VEL       POS       TIME
C    /     COUNT')
C     IF(LBMCPR)WRITE(LUNOUT,202) W,ZTOTS,TTOTS,JCT
C 202 FORMAT(1X,F8.3,2(1X,D10.3),1X,I6)
      J1=J1+1
      GO TO 1
*** Main loop end
  700 XID=DBLE(ID)
      IF(NELEC.GT.IPRIM) THEN
           ANEION=DBLE(NEION)
           ANBT=DBLE(NELEC-IPRIM)
           ATTOION=ANEION/ANBT
           ATTATER=SQRT(ANEION)/ANEION
           ATTIOER=SQRT(ANBT)/ANBT
      ELSE
           ATTOION=-1.0D0
           ANEION=DBLE(NEION)
           ATTATER=SQRT(ANEION)/ANEION
      ENDIF
      JCT=ID/10000
      IF(J1.EQ.1) THEN
          IF(LBMCPR)WRITE(LUNOUT,940) NCLUS,ITER,NELEC,NEION
  940     FORMAT(2(/),' PROGRAM STOPPED (TOO FEW COLLISIONS),',
     -         ' DECREASE THE ESTIMATED ALPHA.  NCLUS=',I7,
     -         '  ITER =',I9,' NELEC=',I9,' NEION =',I6)
      ENDIF
      IF(LBMCPR)WRITE(LUNOUT,878) NELEC,NEION,IPRIM
 878  FORMAT(/,' TOTAL NO OF ELECTRONS=',I8,/,' TOTAL NO OF NEG. IONS=',
     /I8,/,' TOTAL NO OF PRIMARIES=',I8)
      EPRMBAR=0.0D0
      E2PRM=0.0D0
      IF(IPRIM.EQ.1) RETURN
      DO 310 I=1,IPRIM
      E2PRM=E2PRM+EPRM(I)*EPRM(I)
  310 EPRMBAR=EPRMBAR+EPRM(I)
      EBAR=EPRMBAR/IPRIM
      EERR=SQRT(E2PRM/IPRIM-EBAR**2)
      IF(LBMCPR)WRITE(LUNOUT,836) EBAR,EERR
  836 FORMAT(/,2X,'AVERAGE ENERGY OF PRIMARY ELECTRON =',F10.3,' EV.',/,
     /'   ENERGY SPREAD OF PRIMARY ELECTRON =',F10.3,' EV.')
C     IF(LBMCPR)WRITE(LUNOUT,837) (IESPECP(J),J=1,100)
C 837 FORMAT(/,2X,'ENERGY SPECTRUM OF PRIMARIES IN 1EV BINS',/,10(2X,10I
C    /5,/))
      RETURN
  315 IF(ITER.GT.NMAX) THEN
           IF(LBMCPR)WRITE(LUNOUT,991)
     -          ITER,NMAX,NPONT,NELEC,IPRIM,NMXADD
 991       FORMAT(2(/),' PROGRAM STOPPED.  ITER =',I10,'    NMAX =',I10/
     -          ' NPONT=',I4,' NELEC=',I8,' IPRIM=',I6,' NMXADD=',I3)
           IFAIL=1
           RETURN
C           STOP
      ENDIF
      END
